@page "/DrawCAD"
@inject IJSRuntime JSRuntime
@inject GEORGE.Client.Pages.KonfiguratorOkien.ShapeTransferService ShapeService
@inject NavigationManager Navigation
@using GEORGE.Client.Pages.KonfiguratorOkien
@using GEORGE.Client.Pages.Models

@using Blazor.Extensions.Canvas.Canvas2D
@implements IDisposable

<style>
    .toolbar {
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px;
    background: #f4f4f4;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .tool-button {
    background: #ffffff;
    border: 2px solid #ddd;
    padding: 10px;
    cursor: pointer;
    border-radius: 6px;
    transition: 0.3s;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .tool-button:hover {
    background: #e0e0e0;
    }

    .tool-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
    }

    .canvas-container {
    position: relative;
    border: 1px solid #fd7e14;
    width: @(_canvasX + "px");
    height: @(_canvasY + "px");
    margin: 20px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;
    overflow: auto;
    }


    canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
    background-color: transparent;
    }


    .tool-icon {
    width: 24px;
    height: 24px;
    fill: black;
    }

    .tool-button.active .tool-icon {
    fill: white;
    }

    .property-panel {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    }

    .property-row {
    display: flex;
    margin-bottom: 8px;
    align-items: center;
    }

    .property-label {
    width: 100px;
    font-weight: bold;
    }

    .property-input {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 180px;
    }

    .zoom-controls {
    position: absolute;
    top: 170px; /* Ustawienie 10px od góry */
    right: 10px; /* Ustawienie 10px od prawej */
    display: flex;
    gap: 10px; /* Odstęp między przyciskami */
    z-index: 1000; /* Upewnia się, że są na wierzchu */
    }
</style>

<script>
    function initCanvasEvents(container, dotNetHelper) {
    const canvas = container.querySelector('canvas');

    // Nasłuchuj zdarzenia na oknie zamiast na canvasie
    window.addEventListener('keydown', (e) => {
    if (e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', true);
    });
    window.addEventListener('keyup', (e) => {
    if (!e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', false);
    });

    // Reszta handlerów bez zmian
    const handler = (e) => {
    const rect = canvas.getBoundingClientRect();
    return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
    };
    };

    canvas.addEventListener('mousedown', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseDown', x, y);
    });

    canvas.addEventListener('mousemove', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseMove', x, y);
    });

    canvas.addEventListener('mouseup', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseUp', x, y);
    });
    }
</script>

<!-- Kontener na przyciski -->
<div class="zoom-controls">
    <button @onclick="() => FitToCanvas()" class="btn-zoom">🔄 Dopasuj</button>
    <button @onclick="() => RysOkna()" class="btn-window">🔥 Popraw szkic OKNA</button>
    <button @onclick="() => PowrotDoGenerowaniaOkna()" class="btn-window">📦 Wróć do budowy OKNA</button>
</div>

<div class="toolbar">
    <button class="tool-button @(_selectedTool == "line" ? "active" : "")" title="Linia poprzeczki lub słupka stałego"
    @onclick='() => SetTool("line")'>
        @SvgLine()
    </button>

    <button class="tool-button @(_selectedTool == "line_hv" ? "active" : "")" title="Linia poprzeczki lub słupka stałego rysowana tylko w poziomie lub pionie"
    @onclick='() => SetTool("line_hv")'>
        @SvgLineHV()
    </button>

    <button class="tool-button @(_selectedTool == "line_dual_ram_hv" ? "active" : "")" title="Linia podziału na dwie oddzielne ramy"
    @onclick='() => SetTool("line_dual_ram_hv")'>
        @SvgLineDualRamHV()
    </button>

    <button class="tool-button @(_selectedTool == "line_hvSLRuch" ? "active" : "")" title="Linia podziału słupja ruchomego"
    @onclick='() => SetTool("line_hvSLRuch")'>
        @SvgLineHVRS()
    </button>

    <button class="tool-button @(_selectedTool == "triangle" ? "active" : "")" title="Kształ ramy - trójkąt"
    @onclick='() => SetTool("triangle")'>
        @SvgTriangle()
    </button>

    <button class="tool-button @(_selectedTool == "circle" ? "active" : "")" title="Kształ ramy - kołowy"
    @onclick='() => SetTool("circle")'>
        @SvgCircle()
    </button>

    <button class="tool-button @(_selectedTool == "square" ? "active" : "")" title="Kształ ramy - kwadrat"
    @onclick='() => SetTool("square")'>
        @SvgSquare()
    </button>

    <button class="tool-button @(_selectedTool == "rectangle" ? "active" : "")" title="Kształ ramy - prostokąt"
    @onclick='() => SetTool("rectangle")'>
        @SvgRectangle()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoidLeft" ? "active" : "")" title="Kształ ramy - trapezoid"
    @onclick='() => SetTool("trapezoidLeft")'>
        @SvgTrapezoidLeft()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoidRight" ? "active" : "")" title="Kształ ramy - trapezoid"
    @onclick='() => SetTool("trapezoidRight")'>
        @SvgTrapezoidRight()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoid" ? "active" : "")" title="Kształ ramy - trapez"
    @onclick='() => SetTool("trapezoid")'>
        @SvgTrapezoid()
    </button>

    <button class="tool-button @(_selectedTool == "rounded_rect" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonymi górnymi rogami"
    @onclick='() => SetTool("rounded_rect")'>
        @SvgRoundedRect()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_rect_left" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonym lewem rogiem"
    @onclick='() => SetTool("rounded_rect_left")'>
        @SvgRoundedRectLeft()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_rect_right" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonym prawym rogiem"
    @onclick='() => SetTool("rounded_rect_right")'>
        @SvgRoundedRectRight()
    </button>
    <button class="tool-button @(_selectedTool == "house" ? "active" : "")" title="Kształ ramy - typ domek"
    @onclick='() => SetTool("house")'>
        @SvgHouse()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_top_rect" ? "active" : "")" title="Kształ ramy - prostokąt z łukiem u góry"
    @onclick='() => SetTool("rounded_top_rect")'>
        @SvgRoundedTopRect()
    </button>
</div>

<div class="canvas-container" @ref="_container">
    <BECanvas Width="@_canvasX" Height="@_canvasY" @ref="_canvas"></BECanvas>
</div>

@if (_shapes.Count > 0)
{
    <div class="property-panel">
        <h3>Właściwości kształtu</h3>

        @if (_selectedShapeIndex >= 0)
        {
            @foreach (var prop in _shapes[_selectedShapeIndex].GetEditableProperties())
            {
                <div class="property-row">
                    <span class="property-label">[@prop.NazwaObiektu] - @prop.Label</span>
                    @if (!prop.IsReadOnly)
                    {
                        <input class="property-input" type="number"
                        @bind="prop.Value"
                        @bind:event="onchange"
                        @bind:after="async () => await RedrawCanvas()" />
                    }
                    else
                    {
                        <span class="property-value">@prop.Value</span>
                    }
                </div>
            }
        }

        <button @onclick="SelectPreviousShape">Poprzedni obiekt</button>
        <button @onclick="SelectNextShape">Następny obiekt</button>
    </div>
}

@code {
    private Canvas2DContext? _ctx;
    private BECanvasComponent? _canvas;
    private ElementReference _container;
    private DotNetObjectReference<GEORGE.Client.Pages.CAD.DrawCAD>? _dotNetHelper;
    private bool _isDrawing = false;
    private double _startX, _startY, _currentX, _currentY;
    private string _selectedTool = "line";
    private List<IShapeDC> _shapes = new List<IShapeDC>();

    // Dodaj nowe pole dla wymuszenia kierunku
    private bool _forceHV = false;

    private long _canvasX = 900;
    private long _canvasY = 600;

    private int _selectedShapeIndex = -1; // Przechowuje indeks aktualnie edytowanego kształtu

    private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

    private void SetTool(string tool) => _selectedTool = tool;

    [JSInvokable]
    public void SetForceHV(bool state) => _forceHV = state;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _ctx = await _canvas.CreateCanvas2DAsync();
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initCanvasEvents", _container, _dotNetHelper);
            await ClearCanvas();
        }
    }

    private RenderFragment SvgLine() => builder =>
       {
           builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
       };

    private RenderFragment SvgLineHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='black' stroke-width='2'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
    };

    private RenderFragment SvgLineDualRamHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='orange' stroke-width='4'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='orange' stroke-width='4'/>
        </svg>");
    };

    private RenderFragment SvgLineHVRS() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='red' stroke-width='3'/>
        </svg>");
    };

    private RenderFragment SvgTriangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 4,20 20,20'
                     stroke='black'
                     stroke-width='2'
                     fill='none'/>
        </svg>");
    };

    private RenderFragment SvgCircle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <circle cx='12' cy='12' r='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgSquare() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='6' y='6' width='12' height='12' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRectangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='4' y='8' width='16' height='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoid() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoidLeft() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='4,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoidRight() => builder =>
     {
         builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 20,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
     };

    private RenderFragment SvgRoundedRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <path d='
                M8,7
                a3,3 0 0 0 -3,3
                v7
                h14
                v-7
                a3,3 0 0 0 -3,-3
                h-8
                z
            ' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedRectLeft() => builder =>
    {
        builder.AddMarkupContent(0, @"
    <svg class='tool-icon' viewBox='0 0 24 24'>
        <path d='
            M8,7
            a3,3 0 0 0 -3,3 
            v4
            a0,0 0 0 0 0,0
            h14
            a0,0 0 0 0 0,-0
            v-7
            h-11
            z
        ' stroke='black' stroke-width='2' fill='none'/>
    </svg>");
    };

    private RenderFragment SvgRoundedRectRight() => builder =>
    {
        builder.AddMarkupContent(0, @"
    <svg class='tool-icon' viewBox='0 0 24 24'>
        <path d='
            M5,7
            h11
            a3,3 0 0 1 3,3
            v4
            a0,0 0 0 1 -0,0
            h-14
            a0,0 0 0 1 0,0
            v-7
            z
        ' stroke='black' stroke-width='2' fill='none'/>
    </svg>");
    };

    private RenderFragment SvgHouse() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 20,10 20,20 4,20 4,10' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedTopRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <path d='M4 10 Q12 2, 20 10 V20 H4 Z' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    [JSInvokable]
    public async Task HandleMouseDown(double x, double y)
    {
        _isDrawing = true;
        _startX = x;
        _startY = y;
        _currentX = x;
        _currentY = y;
        await Task.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleMouseMove(double x, double y)
    {
        if (!_isDrawing) return;

        // Rozszerzona logika dla wymuszonego kierunku
        if (_selectedTool == "line_hv" || _selectedTool == "line_hvSLRuch" || _selectedTool == "line_dual_ram_hv" || _forceHV)
        {
            const double sensitivity = 5;
            var dx = Math.Abs(x - _startX);
            var dy = Math.Abs(y - _startY);

            if (dx < sensitivity && dy < sensitivity) return;

            var isHorizontal = dx > dy;
            _currentX = isHorizontal ? x : _startX;
            _currentY = isHorizontal ? _startY : y;
        }
        else
        {
            _currentX = x;
            _currentY = y;
        }

        await RedrawCanvas();
    }

    [JSInvokable]
    public async Task HandleMouseUp(double x, double y)
    {
        if (!_isDrawing) return;
        _isDrawing = false;

        IShapeDC newShape = _selectedTool switch
        {
            "line" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor,"Lina skośna"),
            "line_hv" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia pion. poziom.",false, true),
            "line_hvSLRuch" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia pion. sł. ruchomy", true),
            "line_dual_ram_hv" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia podziału ram", false, true, true),
            "circle" => new CircleShape(_startX, _startY, CalculateRadius(), _scaleFactor),
            "triangle" => new TriangleShape(_startX, _startY, _currentX, _currentY, _scaleFactor),
            "square" => new SquareShape(_startX, _startY, Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY)), _scaleFactor),
            "rectangle" => new RectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, _scaleFactor),
            "trapezoid" => new TrapezoidShape(_startX, _startY, _currentX, _currentY, 0.5, _scaleFactor, 0),
            "trapezoidLeft" => new TrapezoidShape(_startX, _startY, _currentX, _currentY, 0.5, _scaleFactor, 1),
            "trapezoidRight" => new TrapezoidShape(_startX, _startY, _currentX, _currentY, 0.5, _scaleFactor, 2),
            "rounded_rect" => new RoundedRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, 20, _scaleFactor),
            "rounded_rect_left" => new RoundedRectangleShapeLeft(_startX, _startY, _currentX - _startX, _currentY - _startY, 20, _scaleFactor),//left
            "rounded_rect_right" => new RoundedRectangleShapeRight(_startX, _startY, _currentX - _startX, _currentY - _startY, 20, _scaleFactor),//right
            "house" => new HouseShape(_startX, _startY, _currentX - _startX, _currentY - _startY, (_currentY - _startY) * 0.5, (_currentY - _startY) * 0.5, _scaleFactor),
            "rounded_top_rect" => new RoundedTopRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, (_currentX - _startX) / 2, _scaleFactor),

            _ => throw new NotImplementedException()
        };

        _shapes.Add(newShape);

        await RedrawCanvas();
    }

    private double CalculateRadius()
    {
        return Math.Sqrt(Math.Pow(_currentX - _startX, 2) + Math.Pow(_currentY - _startY, 2));
    }

    private async Task RedrawCanvas()
    {
        if (_ctx == null) return;

        await ClearCanvas();

        await _ctx.SaveAsync();
        await _ctx.ScaleAsync(_scaleFactor, _scaleFactor); // Skalowanie dla całego rysunku

        foreach (var shape in _shapes)
        {
            await shape.Draw(_ctx);
        }

        await _ctx.RestoreAsync(); // Przywrócenie oryginalnej skali

        // Rysuj podgląd aktualnie rysowanego kształtu
        if (_isDrawing)
        {
            await _ctx.SetStrokeStyleAsync("rgba(0,0,0,0.5)");
            await _ctx.SetLineWidthAsync(2);

            switch (_selectedTool)
            {
                case "line":
                case "line_hv":
                    await DrawPreviewLine();
                    break;
                case "line_dual_ram_hv":
                    await DrawPreviewDualRamLine();
                    break;
                case "line_hvSLRuch":
                    await DrawPreviewVerticalLine();
                    break;
                case "circle":
                    await DrawPreviewCircle();
                    break;
                case "square":
                    await DrawPreviewSquare();
                    break;
                case "rectangle":
                    await DrawPreviewRectangle();
                    break;
                case "trapezoid":
                    await DrawPreviewTrapezoid();
                    break;
                case "trapezoidLeft":
                    await DrawPreviewTrapezoidLeft();
                    break;
                case "trapezoidRight":
                    await DrawPreviewTrapezoidRight();
                    break;
                case "triangle":
                    await DrawPreviewTriangle();
                    break;
                case "rounded_rect":
                    await DrawPreviewRoundedRect();
                    break;
                case "rounded_rect_left":
                    await DrawPreviewRoundedRectLeft();
                    break;
                case "rounded_rect_right":
                    await DrawPreviewRoundedRectRight();
                    break;
                case "house":
                    await DrawPreviewHouse();
                    break;
                case "rounded_top_rect":
                    await DrawPreviewRoundedTopRect();
                    break;

            }
        }
    }

    private async Task DrawPreviewSquare()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var size = Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY));
        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, size, size);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRectangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, _currentX - _startX, _currentY - _startY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTriangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        // Oblicz środkowy punkt podstawy
        var baseCenterX = (_startX + _currentX) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(baseCenterX, _startY);       // Górny wierzchołek
        await _ctx.LineToAsync(_currentX, _currentY);      // Prawy dolny wierzchołek
        await _ctx.LineToAsync(_startX, _currentY);        // Lewy dolny wierzchołek
        await _ctx.ClosePathAsync();                       // Automatycznie łączy z pierwszym punktem

        await _ctx.StrokeAsync();

    }

    private async Task DrawPreviewTrapezoid()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTrapezoidLeft()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX;// + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTrapezoidRight()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(_currentX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 20; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRectLeft()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 20; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width, _startY);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRectRight()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 20; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewLine()
    {
        await _ctx.SetStrokeStyleAsync("blue");
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewDualRamLine()
    {
        await _ctx.SetStrokeStyleAsync("orange");
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewVerticalLine()
    {
        await _ctx.SetStrokeStyleAsync("red"); // Kolor linii
        await _ctx.BeginPathAsync();

        // X nie zmienia się - linia zawsze pionowa!
        await _ctx.MoveToAsync(_startX, Math.Min(_startY, _currentY));
        await _ctx.LineToAsync(_startX, Math.Max(_startY, _currentY));

        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewCircle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await _ctx.SetStrokeStyleAsync("black");
        await ClearCanvas();

        var radius = CalculateRadius();
        await _ctx.BeginPathAsync();
        await _ctx.ArcAsync(_startX, _startY, radius, 0, 2 * Math.PI);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewHouse()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        // Zapewniamy poprawne współrzędne
        var x = Math.Min(_startX, _currentX);
        var y = Math.Min(_startY, _currentY);
        var width = Math.Abs(_currentX - _startX);
        var height = Math.Abs(_currentY - _startY);
        var roofHeight = height * 0.5; // Dach zajmuje 50% wysokości

        var baseY = y + roofHeight;
        var roofPeakX = x + width / 2;
        var roofPeakY = y;

        await _ctx.BeginPathAsync();

        // Dach (trójkąt) – zaczynamy od lewego rogu dachu
        await _ctx.MoveToAsync(x, baseY);
        await _ctx.LineToAsync(roofPeakX, roofPeakY);
        await _ctx.LineToAsync(x + width, baseY);

        // Podstawa (prostokąt) – rysujemy płynnie
        await _ctx.LineToAsync(x + width, y + height);
        await _ctx.LineToAsync(x, y + height);
        await _ctx.LineToAsync(x, baseY);

        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedTopRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var width = _currentX - _startX;
        var height = _currentY - _startY;
        var arcRadius = width / 2; // Łuk rozciąga się na całą szerokość

        await _ctx.BeginPathAsync();

        // Rysowanie dolnej części prostokąta
        await _ctx.MoveToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX + width, _startY + arcRadius);

        // Rysowanie górnego łuku
        await _ctx.ArcAsync(_startX + arcRadius, _startY + arcRadius, arcRadius, 0, Math.PI, true);

        // Dokończenie prostokąta
        await _ctx.LineToAsync(_startX, _startY + arcRadius);
        await _ctx.LineToAsync(_startX, _startY + height);

        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task ClearCanvas()
    {
        await _ctx.SetFillStyleAsync("white");
        await _ctx.FillRectAsync(0, 0, _canvasX, _canvasY);

        _scaleFactor = 1.0; // Reset skali
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }

    // 🖌️ KLASA LINII
    public class LineShape : IShapeDC
    {
        public double X1 { get; set; }
        public double Y1 { get; set; }
        public double X2 { get; set; }
        public double Y2 { get; set; }
        public string NazwaObj { get; set; } = "Linia";
        public bool RuchomySlupek { get; set; } = false;
        public bool PionPoziom { get; set; } = false;
        public bool DualRama { get; set; } = false;

        private double _scaleFactor = 1.0; // Skalowanie

        public LineShape(double x1, double y1, double x2, double y2, double scaleFactor, string nazwaObj, bool ruchomySlupek = false, bool pionPoziom = false, bool dualRama = false)
        {
            X1 = x1;
            Y1 = y1;
            X2 = x2;
            Y2 = y2;
            _scaleFactor = scaleFactor;
            NazwaObj = nazwaObj;
            RuchomySlupek = ruchomySlupek;
            PionPoziom = pionPoziom;
            DualRama = dualRama;
            // Wymuszenie pionowej linii
            if (RuchomySlupek)
            {
                X2 = X1;
            }

            if (PionPoziom)
            {
                if (X1 != X2)
                {
                    Y2 = Y1;
                }
                else
                {
                    X2 = X1;
                }
            }
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            if (RuchomySlupek)
            {
                X2 = X1; // Ustawienie X2 równego X1, aby wymusić pionową linię
                await ctx.SetStrokeStyleAsync("red");
            }
            else
            {
                if (DualRama)
                {
                    await ctx.SetStrokeStyleAsync("orange");
                }
                else
                {
                    await ctx.SetStrokeStyleAsync("green");
                }
            }

            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X1, Y1);
            await ctx.LineToAsync(X2, Y2);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties()
        {
            bool isReadOnly = RuchomySlupek; // Jeśli RuchomySlupek == false, to Y1 i Y2 mogą być edytowalne
            bool someOtherFlag = RuchomySlupek; // Jeśli masz drugi parametr, np. do blokowania

            bool someHFlag = false; // Parametr blokowania poziomego ruchu
            bool someVFlag = false; // Parametr blokowania pionowego ruchu

            if (PionPoziom)
            {
                if (X1 != X2)
                {
                    someHFlag = true;
                    Y2 = Y1; // Blokujemy ruch w pionie, ustawiając Y2 na Y1
                }
                else
                {
                    someVFlag = true;
                    X2 = X1; // Blokujemy ruch w poziomie, ustawiając X2 na X1
                }
            }

            var properties = new List<EditableProperty>
    {
        new EditableProperty("X1", () => X1, v => X1 = v, NazwaObj),
        new EditableProperty("Y1", () => Y1, v => Y1 = v, NazwaObj, isReadOnly, someOtherFlag, someHFlag),
        new EditableProperty("Y2", () => Y2, v => Y2 = v, NazwaObj, isReadOnly || someHFlag, someOtherFlag, someVFlag) // Jeśli someHFlag = true, Y2 jest tylko do odczytu
    };

            if (!RuchomySlupek)
            {
                properties.Add(new EditableProperty("X2", () => X2, v => X2 = v, NazwaObj, isReadOnly || someVFlag, someOtherFlag, someVFlag)); // Jeśli someVFlag = true, X2 jest tylko do odczytu
            }

            return properties;
        }


        public void Scale(double factor)
        {
            double centerX = (X1 + X2) / 2;
            double centerY = (Y1 + Y2) / 2;

            X1 = centerX + (X1 - centerX) * factor;
            Y1 = centerY + (Y1 - centerY) * factor;
            X2 = centerX + (X2 - centerX) * factor;
            Y2 = centerY + (Y2 - centerY) * factor;

            // Zapewniamy, że linia pozostaje pionowa, jeśli trzeba
            if (RuchomySlupek)
            {
                X2 = X1;
            }
        }

        public void Move(double offsetX, double offsetY)
        {
            X1 += offsetX;
            Y1 += offsetY;
            X2 += offsetX;
            Y2 += offsetY;

            if (RuchomySlupek)
            {
                X2 = X1; // Zapewniamy pionową linię po przesunięciu
            }

            Console.WriteLine($"Offset X: {offsetX}, Offset Y: {offsetY}");
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(Math.Min(X1, X2), Math.Min(Y1, Y2), Math.Abs(X2 - X1), Math.Abs(Y2 - Y1), NazwaObj);
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X1 = (X1 * scale) + offsetX;
            Y1 = (Y1 * scale) + offsetY;
            X2 = (X2 * scale) + offsetX;
            Y2 = (Y2 * scale) + offsetY;

            if (RuchomySlupek)
            {
                X2 = X1; // Zapewniamy pionową linię po transformacji
            }
        }
    }

    // 🟥 Klasa prostokąta (Rectangle)
    private class RectangleShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public string NazwaObj { get; set; } = "Prostokąt";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RectangleShape(double x, double y, double width, double height, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Width, Height);
            await ctx.StrokeAsync();
        }


        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X", () => GetBoundingBox().X, _ => { }, NazwaObj, true),
            new EditableProperty("Y", () => GetBoundingBox().Y, _ => { }, NazwaObj, true),
            new EditableProperty("Szerokość", () => Width, v => Width = v, NazwaObj),
            new EditableProperty("Wysokość", () => Height, v => Height = v, NazwaObj)
        };


        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height, "Prostokąt");
        }

        public RectangleShape ToRectangleShape()
        {
            return new RectangleShape(X, Y, Width, Height, _scaleFactor);
        }

        public List<(Point Start, Point End)> GetEdges()
        {
            List<(Point, Point)> edges = new()
            {
                (new Point(X, Y), new Point(X + Width, Y)), // Górna krawędź
                (new Point(X + Width, Y), new Point(X + Width, Y + Height)), // Prawa krawędź
                (new Point(X + Width, Y + Height), new Point(X, Y + Height)), // Dolna krawędź
                (new Point(X, Y + Height), new Point(X, Y)) // Lewa krawędź
            };

            return edges;
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
        }

    }

    // /\ Klasa prostokąta (TriangleShape)
    private class TriangleShape : IShapeDC
    {
        // Współrzędne w przestrzeni "world" (bez transformacji)
        public double BaseX1 { get; set; }
        public double BaseY { get; set; }
        public double BaseWidth { get; set; }
        public double Height { get; set; }
        public string NazwaObj { get; set; } = "Trójkąt";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public TriangleShape(double startX, double startY, double endX, double endY, double scaleFactor)
        {
            // Konwersja do współrzędnych bazowych
            BaseX1 = Math.Min(startX, endX);
            BaseY = Math.Max(startY, endY);
            BaseWidth = Math.Abs(endX - startX);
            Height = Math.Abs(startY - endY);
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            var apexX = BaseX1 + BaseWidth / 2;
            var apexY = BaseY - Height;
            var baseX2 = BaseX1 + BaseWidth;

            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(apexX, apexY);
            await ctx.LineToAsync(baseX2, BaseY);
            await ctx.LineToAsync(BaseX1, BaseY);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("Lewa podstawa X", () => BaseX1, v => BaseX1 = v, NazwaObj, true),
        new EditableProperty("Pozycja Y podstawy", () => BaseY, v => BaseY = v, NazwaObj, true),
        new EditableProperty("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v, NazwaObj),
        new EditableProperty("Wysokość", () => Height, v => Height = v, NazwaObj)
    };

        public void Scale(double factor)
        {
            BaseWidth *= factor;
            Height *= factor;
            BaseX1 -= (BaseWidth * (factor - 1)) / 2; // Przesuwamy, aby trójkąt skalował się symetrycznie
            BaseY += (Height * (factor - 1)); // Przesuwamy punkt bazowy
        }

        public void Move(double offsetX, double offsetY)
        {
            BaseX1 += offsetX;
            BaseY += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            double minX = BaseX1;
            double minY = BaseY - Height; // Wierzchołek trójkąta
            double maxX = BaseX1 + BaseWidth;
            double maxY = BaseY;

            double width = maxX - minX;
            double height = maxY - minY;

            return new BoundingBox(minX, minY, width, height, "Trójkąt");
        }

        public List<Point> GetVertices()
        {
            var apexX = BaseX1 + BaseWidth / 2;
            var apexY = BaseY - Height;
            var baseX2 = BaseX1 + BaseWidth;

            return new List<Point>
            {
                new Point(apexX, apexY),  // Wierzchołek trójkąta
                new Point(baseX2, BaseY), // Prawy dolny róg podstawy
                new Point(BaseX1, BaseY)  // Lewy dolny róg podstawy
            };
        }

        public List<(Point Start, Point End)> GetEdges()
        {
            var apexX = BaseX1 + BaseWidth / 2;
            var apexY = BaseY - Height;
            var baseX2 = BaseX1 + BaseWidth;

            return new List<(Point, Point)>
            {
                (new Point(apexX, apexY), new Point(baseX2, BaseY)), // Dolna krawędź
                (new Point(baseX2, BaseY), new Point(BaseX1, BaseY) ), // Lewa ściana
                (new Point(BaseX1, BaseY) , new Point(apexX, apexY)) // Prawa ściana
            };
        }

        public void Transform(double scaleFactor, double offsetX, double offsetY)
        {
            Scale(scaleFactor);
            Move(offsetX, offsetY);
        }

    }

    // ⬛ Klasa kwadratu (Square)
    private class SquareShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Size { get; set; }
        public string NazwaObj { get; set; } = "Kwadrat";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public SquareShape(double x, double y, double size, double scaleFactor)
        {
            X = x;
            Y = y;
            Size = size;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Size, Size);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v, NazwaObj, true),
        new EditableProperty("Y", () => Y, v => Y = v, NazwaObj, true),
        new EditableProperty("Rozmiar", () => Size, v => Size = v, NazwaObj)
    };

        public void Scale(double factor)
        {
            Size *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Size, Size, "Kształt inny");
        }

        public RectangleShape ToRectangleShape()
        {
            return new RectangleShape(X, Y, Size, Size, _scaleFactor);
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            // Poprawiona implementacja
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Size *= scale;
        }

    }

    private class RoundedRectangleShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }
        public string NazwaObj { get; set; } = "Prostoką z zaokr. naroż.";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RoundedRectangleShape(double x, double y, double width, double height, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X + Radius, Y);
            await ctx.LineToAsync(X + Width - Radius, Y);
            await ctx.ArcToAsync(X + Width, Y, X + Width, Y + Radius, Radius);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X, Y + Height);
            await ctx.LineToAsync(X, Y + Radius);
            await ctx.ArcToAsync(X, Y, X + Radius, Y, Radius);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new("X", () => X, v => X = v, NazwaObj, true),
            new("Y", () => Y, v => Y = v, NazwaObj, true),
            new("Szerokość", () => Width, v => Width = v, NazwaObj),
            new("Wysokość", () => Height, v => Height = v, NazwaObj),
            new("Promień", () => Radius, v => Radius = v, NazwaObj)
        };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            Radius *= factor;
        }
        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height, "Prostokąt");
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
            Radius *= scale;
        }

    }

    private class RoundedRectangleShapeLeft : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }
        public string NazwaObj { get; set; } = "Prostoką z 1 zaokr. naroż. lewym";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RoundedRectangleShapeLeft(double x, double y, double width, double height, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X + Radius, Y);
            await ctx.LineToAsync(X + Width, Y);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X, Y + Height);
            await ctx.LineToAsync(X, Y + Radius);
            await ctx.ArcToAsync(X, Y, X + Radius, Y, Radius);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new("X", () => X, v => X = v, NazwaObj, true),
            new("Y", () => Y, v => Y = v, NazwaObj, true),
            new("Szerokość", () => Width, v => Width = v, NazwaObj),
            new("Wysokość", () => Height, v => Height = v, NazwaObj),
            new("Promień", () => Radius, v => Radius = v, NazwaObj)
        };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            Radius *= factor;
        }
        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height, "Prostokąt");
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
            Radius *= scale;
        }

    }

    private class RoundedRectangleShapeRight : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }
        public string NazwaObj { get; set; } = "Prostoką z 1 zaokr. naroż. prawym";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RoundedRectangleShapeRight(double x, double y, double width, double height, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X + Radius, Y);
            await ctx.LineToAsync(X + Width - Radius, Y);
            await ctx.ArcToAsync(X + Width, Y, X + Width, Y + Radius, Radius);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X, Y + Height);
            await ctx.LineToAsync(X, Y);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new("X", () => X, v => X = v, NazwaObj, true),
            new("Y", () => Y, v => Y = v, NazwaObj, true),
            new("Szerokość", () => Width, v => Width = v, NazwaObj),
            new("Wysokość", () => Height, v => Height = v, NazwaObj),
            new("Promień", () => Radius, v => Radius = v, NazwaObj)
        };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            Radius *= factor;
        }
        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height, "Prostokąt");
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
            Radius *= scale;
        }

    }

    private class TrapezoidShape : IShapeDC
    {
        public double BaseWidth { get; set; }
        public double TopWidth { get; set; }
        public double Height { get; set; }
        public double X { get; set; }
        public double Y { get; set; }
        public string NazwaObj { get; set; } = "Trapezoid";

        private int Typ { get; set; }
        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        // Konstruktor przyjmujący współrzędne i współczynnik szerokości góry
        public TrapezoidShape(double startX, double startY, double endX, double endY, double topWidthFactor, double scaleFactor, int typ)
        {
            X = Math.Min(startX, endX);           // Ustal minimalne X (lewy brzeg)
            Y = Math.Min(startY, endY);           // Ustal minimalne Y (dolny brzeg)
            BaseWidth = Math.Abs(endX - startX);  // Oblicz szerokość podstawy trapezu
            Height = Math.Abs(endY - startY);     // Oblicz wysokość trapezu
            TopWidth = Math.Min(BaseWidth, BaseWidth * topWidthFactor);  // Oblicz szerokość góry trapezu
            _scaleFactor = scaleFactor;
            Typ = typ;
        }

        // Metoda rysująca trapez
        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            if (Typ == 0)
            {
                // Oblicz pozycje wierzchołków trapezu
                var baseLeft = X;
                var baseRight = X + BaseWidth;
                var topLeft = X + (BaseWidth - TopWidth) / 2;   // Oblicz pozycję lewej strony góry
                var topRight = topLeft + TopWidth;               // Oblicz pozycję prawej strony góry
                var verticalY = Y + Height;                      // Oblicz wysokość (dolna krawędź)

                // Rysowanie trapezu za pomocą punktów
                await ctx.BeginPathAsync();
                await ctx.MoveToAsync(topLeft, Y);            // Lewy górny
                await ctx.LineToAsync(topRight, Y);           // Prawy górny
                await ctx.LineToAsync(baseRight, verticalY);  // Prawy dolny
                await ctx.LineToAsync(baseLeft, verticalY);   // Lewy dolny
                await ctx.ClosePathAsync();

                await ctx.StrokeAsync();
            }
            else if (Typ == 1)
            {
                // Oblicz pozycje wierzchołków trapezu
                var baseLeft = X;
                var baseRight = X + BaseWidth;
                var topLeft = X + (BaseWidth - TopWidth) / 2;   // Oblicz pozycję lewej strony góry
                var topRight = topLeft + TopWidth;               // Oblicz pozycję prawej strony góry
                var verticalY = Y + Height;                      // Oblicz wysokość (dolna krawędź)

                // Rysowanie trapezu za pomocą punktów
                await ctx.BeginPathAsync();
                await ctx.MoveToAsync(baseLeft, Y);            // Lewy górny
                await ctx.LineToAsync(topRight, Y);           // Prawy górny
                await ctx.LineToAsync(baseRight, verticalY);  // Prawy dolny
                await ctx.LineToAsync(baseLeft, verticalY);   // Lewy dolny
                await ctx.ClosePathAsync();

                await ctx.StrokeAsync();
            }
            else if (Typ == 2)
            {
                // Oblicz pozycje wierzchołków trapezu
                var baseLeft = X;
                var baseRight = X + BaseWidth;
                var topLeft = X + (BaseWidth - TopWidth) / 2;   // Oblicz pozycję lewej strony góry
                var topRight = topLeft + TopWidth;               // Oblicz pozycję prawej strony góry
                var verticalY = Y + Height;                      // Oblicz wysokość (dolna krawędź)

                // Rysowanie trapezu za pomocą punktów
                await ctx.BeginPathAsync();
                await ctx.MoveToAsync(topLeft, Y);            // Lewy górny
                await ctx.LineToAsync(baseRight, Y);           // Prawy górny
                await ctx.LineToAsync(baseRight, verticalY);  // Prawy dolny
                await ctx.LineToAsync(baseLeft, verticalY);   // Lewy dolny
                await ctx.ClosePathAsync();

                await ctx.StrokeAsync();
            }

        }

        // Właściwości edytowalne
        public List<EditableProperty> GetEditableProperties() => new()
    {
        new("Pozycja X", () => X, v => X = v, NazwaObj, true),
        new("Pozycja Y", () => Y, v => Y = v, NazwaObj, true),
        new("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v, NazwaObj),
        new("Szerokość góry", () => TopWidth, v => TopWidth = Math.Clamp(v, 10, BaseWidth - 10), NazwaObj),
        new("Wysokość", () => Height, v => Height = v, NazwaObj)
    };

        public void Scale(double factor)
        {
            BaseWidth *= factor;
            TopWidth *= factor;
            Height *= factor;
            X -= (BaseWidth * (factor - 1)) / 2; // Przesuwamy trapez w lewo, aby zachować środek
            Y -= (Height * (factor - 1)) / 2; // Przesuwamy go w górę
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, BaseWidth, Height ,"Trapezoid");
        }

        public List<(Point Start, Point End)> GetEdges()
        {
            var baseLeft = X;
            var baseRight = X + BaseWidth;
            var topLeft = X + (BaseWidth - TopWidth) / 2;
            var topRight = topLeft + TopWidth;
            var verticalY = Y + Height;

            if (Typ == 0)
            {
                return new List<(Point, Point)>
        {
            (new Point(topLeft, Y), new Point(topRight, Y)),         // Górna krawędź trapezu
            (new Point(topRight, Y), new Point(baseRight, verticalY)), // Prawa skośna krawędź
            (new Point(baseRight, verticalY), new Point(baseLeft, verticalY)), // Dolna krawędź
            (new Point(baseLeft, verticalY), new Point(topLeft, Y))  // Lewa skośna krawędź
        };
            }
            else if (Typ == 1)
            {
                return new List<(Point, Point)>
        {
            (new Point(baseLeft, Y), new Point(topRight, Y)),        // Górna krawędź trapezu
            (new Point(topRight, Y), new Point(baseRight, verticalY)), // Prawa skośna krawędź
            (new Point(baseRight, verticalY), new Point(baseLeft, verticalY)), // Dolna krawędź
            (new Point(baseLeft, verticalY), new Point(baseLeft, Y))  // Lewa pionowa krawędź
        };
            }
            else if (Typ == 2)
            {
                return new List<(Point, Point)>
        {
            (new Point(topLeft, Y), new Point(baseRight, Y)),         // Górna krawędź trapezu
            (new Point(baseRight, Y), new Point(baseRight, verticalY)), // Prawa pionowa krawędź
            (new Point(baseRight, verticalY), new Point(baseLeft, verticalY)), // Dolna krawędź
            (new Point(baseLeft, verticalY), new Point(topLeft, Y))  // Lewa skośna krawędź
        };
            }

            return new List<(Point, Point)>();
        }

        public List<Point> GetVertices()
        {
            var baseLeft = X;
            var baseRight = X + BaseWidth;
            var topLeft = X + (BaseWidth - TopWidth) / 2;
            var topRight = topLeft + TopWidth;
            var verticalY = Y + Height;

            return new List<Point>
        {
            new Point(topLeft, Y),
            new Point(baseRight, Y),
            new Point(baseRight, verticalY),
            new Point(baseLeft, verticalY),
             new Point(topLeft, Y)
             // Do sprawdzenia czy działa
        };
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            BaseWidth *= scale;
            TopWidth *= scale;
            Height *= scale;
        }
    }

    // 🟢 KLASA KOŁA
    private class CircleShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Radius { get; set; }
        public string NazwaObj { get; set; } = "Okrąg";

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public CircleShape(double x, double y, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.ArcAsync(X, Y, Radius, 0, 2 * Math.PI);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X", () => X, v => X = v, NazwaObj, true),
            new EditableProperty("Y", () => Y, v => Y = v, NazwaObj, true),
            new EditableProperty("Promień", () => Radius, v => Radius = v, NazwaObj)
        };

        public void Scale(double factor)
        {
            Radius *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X - Radius, Y - Radius, Radius * 2, Radius * 2, "Okrąg");
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Radius *= scale;
        }

    }

    public class HouseShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double HeightLeft { get; set; }
        public double HeightRight { get; set; }
        private double _scaleFactor;
        public string NazwaObj { get; set; } = "Domek";

        public HouseShape(double x, double y, double width, double height, double heightLeft, double heightRight, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            HeightLeft = heightLeft;
            HeightRight = heightRight;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            //double roofHeight = Height * 0.5;
            double baseYL = Y + Height - Math.Max(HeightLeft, 0);
            double baseYR = Y + Height - Math.Max(HeightRight, 0);

            double roofPeakX = X + Width / 2;
            double roofPeakY = Y;

            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();

            // Dach (trójkąt)
            await ctx.MoveToAsync(X, baseYL);  // Lewy róg dachu
            await ctx.LineToAsync(roofPeakX, roofPeakY);  // Szczyt dachu
            await ctx.LineToAsync(X + Width, baseYR);  // Prawy róg dachu

            // Podstawa (prostokąt)
            await ctx.LineToAsync(X + Width, Y + Height);  // Prawy dolny róg
            await ctx.LineToAsync(X, Y + Height);  // Lewy dolny róg
            await ctx.LineToAsync(X, baseYL);  // Powrót do początku

            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();

            Console.WriteLine($"BaseYL: {baseYL}, BaseYR: {baseYR}, RoofPeakY: {roofPeakY}");
            Console.WriteLine($"Drawing at: X={X}, Y={Y}, Width={Width}, Height={Height}");


        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height, "Domek");
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v, NazwaObj, true),
        new EditableProperty("Y", () => Y, v => Y = v, NazwaObj, true),
        new EditableProperty("Szerokość", () => Width, v => Width = v, NazwaObj),
        new EditableProperty("Wysokość", () => Height, v => Height = v, NazwaObj),
        new EditableProperty("Wysokość bok lewy", () => HeightLeft, v => HeightLeft = v, NazwaObj),
        new EditableProperty("Wysokość bok prawy", () => HeightRight, v => HeightRight = v, NazwaObj)
    };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            HeightRight *= factor;
            HeightLeft *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public List<(Point Start, Point End)> GetEdges()
        {
            double roofHeight = Height * 0.5;
            double baseY = Y + roofHeight;
            double roofPeakX = X + Width / 2;
            double roofPeakY = Y;
            double bottomY = Y + Height; // Dolna krawędź domu

            return new List<(Point, Point)>
            {
                (new Point(X, baseY), new Point(roofPeakX, roofPeakY)), // Dach - lewa krawędź
                (new Point(roofPeakX, roofPeakY), new Point(X + Width, baseY)), // Dach - prawa krawędź
                (new Point(X, baseY), new Point(X + Width, baseY)), // Podstawa dachu
                (new Point(X, baseY), new Point(X, bottomY)), // Lewa ściana domu
                (new Point(X + Width, baseY), new Point(X + Width, bottomY)), // Prawa ściana domu
                (new Point(X, bottomY), new Point(X + Width, bottomY)) // **Podstawa domu (DOLNA KRAWĘDŹ)**
            };
        }

        public (List<Point> Roof, List<Point> House) GetVertices()
        {
            // double roofHeight = Height * 0.5;
            double baseY = Y + HeightLeft;
            double roofPeakX = X + Width / 2;
            double roofPeakY = Y;
            double bottomY = Y + Height; // Dolna krawędź domu

            // Trójkąt dachu
            List<Point> roof = new List<Point>
        {
            new Point(X, baseY),         // Lewy dolny róg dachu
            new Point(roofPeakX, roofPeakY), // Szczyt dachu
            new Point(X + Width, baseY)  // Prawy dolny róg dachu
        };

            // Prostokąt (ściany domu)
            List<Point> house = new List<Point>
        {
            new Point(X, baseY),          // Lewy górny róg ściany
            new Point(X + Width, baseY),  // Prawy górny róg ściany
            new Point(X + Width, bottomY), // Prawy dolny róg ściany
            new Point(X, bottomY)         // Lewy dolny róg ściany
        };

            return (roof, house);
        }

        public (List<(Point Start, Point End)> RoofEdges, List<(Point Start, Point End)> BaseEdges) GetEdgesDel()
        {
            double roofHeight = Height * 0.5;
            double baseY = Y + roofHeight;
            double roofPeakX = X + Width / 2;
            double roofPeakY = Y;
            double bottomY = Y + Height;

            List<(Point, Point)> roofEdges = new()
        {
            (new Point(X, baseY), new Point(roofPeakX, roofPeakY)), // Dach - lewa krawędź
            (new Point(roofPeakX, roofPeakY), new Point(X + Width, baseY)), // Dach - prawa krawędź
            (new Point(X, baseY), new Point(X + Width, baseY)) // Podstawa dachu
        };

            List<(Point, Point)> baseEdges = new()
        {
            (new Point(X, baseY), new Point(X, bottomY)), // Lewa ściana domu
            (new Point(X + Width, baseY), new Point(X + Width, bottomY)), // Prawa ściana domu
            (new Point(X, bottomY), new Point(X + Width, bottomY)) // Podstawa domu
        };

            return (roofEdges, baseEdges);
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
            HeightLeft *= scale;
            HeightRight *= scale;
        }

    }

    public class RoundedTopRectangleShape : IShapeDC
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }
        private double _scaleFactor;
        public string NazwaObj { get; set; } = "Prostokąt z zaokr. naroż.";

        public RoundedTopRectangleShape(double x, double y, double width, double height, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            double arcCenterX = X + Width / 2;
            double arcCenterY = Y + Radius; // Środek łuku znajduje się na wysokości promienia

            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();

            // Dolna część prostokąta
            await ctx.MoveToAsync(X, Y + Height);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X + Width, arcCenterY);

            // Górny łuk
            await ctx.ArcAsync(arcCenterX, arcCenterY, Radius, 0, Math.PI, true);

            // Dokończenie prostokąta – BEZ GÓRNEJ LINII!
            await ctx.LineToAsync(X, arcCenterY);
            await ctx.LineToAsync(X, Y + Height);

            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height,"Prostokąt z zaokr. narożami");
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v, NazwaObj, true),
        new EditableProperty("Y", () => Y, v => Y = v, NazwaObj, true),
        new EditableProperty("Szerokość", () => Width, v => Width = v, NazwaObj),
        new EditableProperty("Wysokość", () => Height, v => Height = v, NazwaObj),
        new EditableProperty("Promień łuku", () => Radius, v => Radius = v, NazwaObj)
    };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            Radius *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public List<(Point Start, Point End)> GetEdges()
        {
            return new List<(Point, Point)>
            {
                (new Point(X, Y + Height), new Point(X + Width, Y + Height)), // Dolna krawędź
                (new Point(X, Y + Radius), new Point(X, Y + Height)), // Lewa ściana
                (new Point(X + Width, Y + Radius), new Point(X + Width, Y + Height)) // Prawa ściana
            };
        }

        public void Transform(double scale, double offsetX, double offsetY)
        {
            X = (X * scale) + offsetX;
            Y = (Y * scale) + offsetY;
            Width *= scale;
            Height *= scale;
            Radius *= scale;
        }

    }

    private List<(Point Start, Point End)> GetApproximateEdges(CircleShape circle, int segments)
    {
        var edges = new List<(Point Start, Point End)>();
        double centerX = circle.X;
        double centerY = circle.Y;
        double radius = circle.Radius;
        double angleStep = 2 * Math.PI / segments;

        Point firstPoint = new Point(centerX + radius * Math.Cos(0), centerY + radius * Math.Sin(0));
        Point prevPoint = firstPoint;

        for (int i = 1; i <= segments; i++)
        {
            double angle = i * angleStep;
            Point newPoint = new Point(centerX + radius * Math.Cos(angle), centerY + radius * Math.Sin(angle));
            edges.Add((prevPoint, newPoint));
            prevPoint = newPoint;
        }

        return edges;
    }


    // // 🔧 KLASY EDYTOWALNYCH WŁAŚCIWOŚCI
    // public record EditableProperty(
    //     string Label,
    //     Func<double> GetValue,
    //     Action<double> SetValue,
    //     string NazwaObiektu,
    //     bool IsReadOnly = false,
    //     bool slupekRuchomy = false,
    //     bool pionPoziom = false)
    // {
    //     public double Value
    //     {
    //         get => GetValue();
    //         set
    //         {
    //             if (!IsReadOnly) SetValue(value);
    //         }
    //     }

    //     public EditableProperty SetObjectName(string newName) => this with { NazwaObiektu = newName };
    // }

    private void SelectNextShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex + 1) % _shapes.Count;
    }

    private void SelectPreviousShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex - 1 + _shapes.Count) % _shapes.Count;
    }

    private async Task FitToCanvas()
    {
        if (_shapes.Count == 0) return;

        // Znajdź granice wszystkich kształtów
        double minX = _shapes.Min(s => s.GetBoundingBox().X);
        double minY = _shapes.Min(s => s.GetBoundingBox().Y);
        double maxX = _shapes.Max(s => s.GetBoundingBox().X + s.GetBoundingBox().Width);
        double maxY = _shapes.Max(s => s.GetBoundingBox().Y + s.GetBoundingBox().Height);

        double shapesWidth = maxX - minX;
        double shapesHeight = maxY - minY;

        if (shapesWidth == 0 || shapesHeight == 0) return;

        // Oblicz współczynnik skali z marginesem
        double scaleX = _canvasX / shapesWidth;
        double scaleY = _canvasY / shapesHeight;
        double scaleFactor = Math.Min(scaleX, scaleY) * 0.9;

        // Oblicz przesunięcie dla skalowanych kształtów
        double scaledWidth = shapesWidth * scaleFactor;
        double scaledHeight = shapesHeight * scaleFactor;
        double offsetX = (_canvasX - scaledWidth) / 2 - (minX * scaleFactor);
        double offsetY = (_canvasY - scaledHeight) / 2 - (minY * scaleFactor);

        // Zastosuj skalowanie i przesunięcie do każdego kształtu
        // Zastosuj przesunięcie do każdego kształtu
        foreach (var shape in _shapes)
        {
            // Przesuń kształt przed skalowaniem!
            // shape.Move(-minX, -minY);

            // Przesuń kształt do środka canvasu
            shape.Move(offsetX, offsetY);

            // Skaluj kształt (zakładając, że metoda Scale istnieje)
            shape.Scale(scaleFactor);

            // // Przesuń kształt do środka canvasu
            // shape.Move(offsetX, offsetY);
        }


        await RedrawCanvas();

        await FitToCanvasSpr();
    }

    private async Task FitToCanvasSpr()
    {
        if (_shapes.Count == 0) return;

        // Znajdź granice wszystkich kształtów
        double minX = _shapes.Min(s => s.GetBoundingBox().X);
        double minY = _shapes.Min(s => s.GetBoundingBox().Y);
        double maxX = _shapes.Max(s => s.GetBoundingBox().X + s.GetBoundingBox().Width);
        double maxY = _shapes.Max(s => s.GetBoundingBox().Y + s.GetBoundingBox().Height);

        double shapesWidth = maxX - minX;
        double shapesHeight = maxY - minY;

        if (shapesWidth == 0 || shapesHeight == 0) return;

        // Oblicz współczynnik skali z marginesem
        double scaleX = _canvasX / shapesWidth;
        double scaleY = _canvasY / shapesHeight;
        double scaleFactor = Math.Min(scaleX, scaleY) * 0.9;

        // Oblicz przesunięcie dla skalowanych kształtów
        double scaledWidth = shapesWidth * scaleFactor;
        double scaledHeight = shapesHeight * scaleFactor;
        double offsetX = (_canvasX - scaledWidth) / 2 - (minX * scaleFactor);
        double offsetY = (_canvasY - scaledHeight) / 2 - (minY * scaleFactor);

        // Zastosuj skalowanie i przesunięcie do każdego kształtu
        foreach (var shape in _shapes)
        {
            // Przesuń kształt przed skalowaniem!
            // shape.Move(-minX, -minY);

            // Przesuń kształt do środka canvasu
            shape.Move(offsetX, offsetY);

            // Skaluj kształt (zakładając, że metoda Scale istnieje)
            shape.Scale(scaleFactor);

            // // Przesuń kształt do środka canvasu
            // shape.Move(offsetX, offsetY);
        }

        await RedrawCanvas();
    }

    private async Task PowrotDoGenerowaniaOkna()
    {
        var noweShapes = _shapes.Select(ConvertOldShapeToNew).ToList();

        ShapeService.Shapes = noweShapes; // Przekazanie danych do serwisu
        Navigation.NavigateTo("/Modele-okienne");

        await Task.CompletedTask;
    }

    private async Task RysOkna()
    {
        Console.WriteLine($"Sprawdzanie RysOkna -->  Start");

        if (_selectedShapeIndex < 0 || _selectedShapeIndex >= _shapes.Count)
        {
            SelectNextShape();
        }

        if (_selectedShapeIndex < 0 || _selectedShapeIndex >= _shapes.Count) return;

        var closedShapes = _shapes.Where(shape => shape is not LineShape).ToList();
        var linesToCheck = _shapes.Where(shape => shape is LineShape).Cast<LineShape>().ToList();

        RemoveLinesOutsideShapes();

        linesToCheck = _shapes.Where(shape => shape is LineShape).Cast<LineShape>().ToList();

        foreach (var line in linesToCheck)
        {
            foreach (var shape in closedShapes)
            {
                var bbox = shape.GetBoundingBox();
                var extendedLine = ExtendLineToBoundingBox(line, bbox);
                _shapes.Remove(line); // Usuń starą linię
                _shapes.Add(extendedLine); // Dodaj nową wydłużoną
            }
        }

        linesToCheck = _shapes.Where(shape => shape is LineShape).Cast<LineShape>().ToList();

        foreach (var line in linesToCheck)
        {
            Console.WriteLine($"Sprawdzanie linii ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");

            foreach (var shape in closedShapes)
            {
                if (shape is CircleShape circle)
                {
                    if (IsLineInsideCircle(line, circle))
                    {
                        Console.WriteLine("Linia przecina okrąg – przycinanie.");

                        ShortenLineInsideCircle(line, circle);
                    }
                }
                else if (shape is TriangleShape triangle)
                {
                    var vertices = triangle.GetVertices();

                    var edges = triangle.GetEdges();

                    List<Point> intersections = GetLinePolygonIntersections(line, vertices);

                    if (intersections.Count >= 2)
                    {
                        Console.WriteLine("Linia przecina trójkąt – przycinanie.");
                        ShortenLineInsidePolygon(line, vertices);
                    }
                }
                else if (shape is HouseShape house)
                {
                    Console.WriteLine("Linia przecina HouseShape – przycinanie.");

                    var (roofVertices, houseVertices) = house.GetVertices();

                    var edges = house.GetEdges();

                    // Sprawdzamy przecięcia z dachem (tylko jeśli linia przecina skosy)
                    List<Point> roofIntersections = GetLinePolygonIntersections(line, roofVertices);
                    if (roofIntersections.Count >= 2)
                    {
                        Console.WriteLine("Przycinanie linii dla dowolnego kształtu.");

                        ShortenLineToShape(line, edges);
                    }

                    var shapeBox = shape.GetBoundingBox();
                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);

                }
                else if (shape is RoundedTopRectangleShape roundedRect)
                {
                    Console.WriteLine("Linia przecina RoundedTopRectangleShape – przycinanie.");

                    var edges = roundedRect.GetEdges();

                    Point arcCenter = new Point(roundedRect.X + roundedRect.Width / 2, roundedRect.Y + roundedRect.Radius);
                    ShortenLineInsideEdges(line, edges, arcCenter, roundedRect.Radius);
                }
                else if (shape is TrapezoidShape trapShepae)
                {
                    var edges = trapShepae.GetEdges(); // To zrobić uniwersalne

                    ShortenLineToShape(line, edges);

                    var shapeBox = shape.GetBoundingBox();
                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);
                }
                else
                {

                    var shapeBox = shape.GetBoundingBox();

                    // var edges = shapeBox.GetEdges(); // To zrobić uniwersalne

                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);
                }
            }
        }

        _scaleFactor = 1;

        await RedrawCanvas();
    }

    private void ShortenLineInsideCircle(LineShape line, CircleShape circle)
    {
        List<Point> intersections = new List<Point>();

        // Znajdź przecięcia linii z okręgiem
        FindCircleIntersections(circle, line, ref intersections);

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsideCircle(line.X1, line.Y1, circle))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private List<Point> GetLinePolygonIntersections(LineShape line, List<Point> polygonVertices)
    {
        List<Point> intersections = new List<Point>();
        int count = polygonVertices.Count;

        for (int i = 0; i < count; i++)
        {
            Point p1 = polygonVertices[i];
            Point p2 = polygonVertices[(i + 1) % count];

            if (FindIntersection(p1.X, p1.Y, p2.X, p2.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        return intersections;
    }

    private bool IsLineInsideTrangle(LineShape line, List<Point> polygonVertices)
    {
        List<Point> intersections = GetLinePolygonIntersections(line, polygonVertices);

        return intersections.Count >= 2; // Jeśli są dwa punkty przecięcia, linia przecina trójkąt
    }


    private bool IsLineInsidePolygon(LineShape line, List<Point> polygon)
    {
        // Pobierz kilka dodatkowych punktów na linii i sprawdź, czy wszystkie są wewnątrz
        int numSamples = 5; // Ilość punktów do sprawdzenia na linii
        for (int i = 0; i <= numSamples; i++)
        {
            double t = (double)i / numSamples;
            double px = line.X1 + t * (line.X2 - line.X1);
            double py = line.Y1 + t * (line.Y2 - line.Y1);

            if (!IsPointInsidePolygon(px, py, polygon))
            {
                return false; // Jeśli jakikolwiek punkt linii jest poza kształtem, linia odpada
            }
        }
        return true;
    }

    private bool IsLineInsideCircle(LineShape line, CircleShape circle)
    {
        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - circle.X;
        double fy = line.Y1 - circle.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (circle.Radius * circle.Radius);

        double discriminant = b * b - 4 * a * c;
        return discriminant >= 0; // Jeśli Δ > 0, linia przecina okrąg
    }

    private void ShortenLineInsideEdgesHause(LineShape line, List<(Point Start, Point End)> edges)
    {
        List<Point> intersections = new List<Point>();

        foreach (var (start, end) in edges)
        {
            if (FindIntersection(start.X, start.Y, end.X, end.Y, line.X1, line.Y1, line.X2, line.Y2, out double ix, out double iy))
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        Console.WriteLine($"ShortenLineInsideEdgesHause -> intersections.Count: {intersections.Count}");

        if (intersections.Count >= 2)
        {
            Console.WriteLine($"Przycinam linię do dwóch przecięć: ({intersections[0].X}, {intersections[0].Y}) → ({intersections[1].X}, {intersections[1].Y})");
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            // Sprawdzenie, czy linia powinna być ucięta na dole
            double bottomY = edges.Max(e => Math.Max(e.Start.Y, e.End.Y));

            if (line.Y1 > bottomY) // Linia sięga za daleko w dół
            {
                Console.WriteLine($"Przycinam linię do dolnej krawędzi domu: ({intersections[0].X}, {bottomY})");
                line.Y2 = bottomY;
            }
            else
            {
                Console.WriteLine($"Przycinam linię do pierwszego przecięcia: ({intersections[0].X}, {intersections[0].Y})");
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }


    private void ShortenLineInsideEdges(LineShape line, List<(Point Start, Point End)> edges, Point arcCenter, double arcRadius)
    {
        List<Point> intersections = new List<Point>();

        // Sprawdzenie przecięć z prostymi krawędziami
        foreach (var edge in edges)
        {
            if (FindIntersection(edge.Start.X, edge.Start.Y, edge.End.X, edge.End.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                if (IsPointOnSegment(edge.Start, edge.End, new Point(ix, iy)))
                {
                    intersections.Add(new Point(ix, iy));
                }
            }
        }

        // Sprawdzenie przecięć z łukiem
        List<Point> arcIntersections = FindCircleLineIntersections(arcCenter, arcRadius, line);
        intersections.AddRange(arcIntersections);

        Console.WriteLine($"Znalezione przecięcia (po filtracji): {intersections.Count}");
        foreach (var p in intersections)
        {
            Console.WriteLine($"Punkt przecięcia: ({p.X}, {p.Y})");
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        if (intersections.Count == 2)
        {
            Console.WriteLine($"Przycinam linię do dwóch przecięć: ({intersections[0].X}, {intersections[0].Y}) → ({intersections[1].X}, {intersections[1].Y})");
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsideEdges(line.X1, line.Y1, edges, arcCenter, arcRadius))
            {
                Console.WriteLine($"Przycinam linię do punktu ({intersections[0].X}, {intersections[0].Y}) na końcu.");
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                Console.WriteLine($"Przycinam linię do punktu ({intersections[0].X}, {intersections[0].Y}) na początku.");
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private void ShortenLineInsideShape(LineShape line, BoundingBox shapeBox)
    {
        List<Point> intersections = new List<Point>();

        // Sprawdź przecięcia z krawędziami zamkniętego kształtu
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y, shapeBox.X + shapeBox.Width, shapeBox.Y, line, ref intersections); // Góra
        CheckEdgeIntersection(shapeBox.X + shapeBox.Width, shapeBox.Y, shapeBox.X + shapeBox.Width, shapeBox.Y + shapeBox.Height, line, ref intersections); // Prawa
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y + shapeBox.Height, shapeBox.X + shapeBox.Width, shapeBox.Y + shapeBox.Height, line, ref intersections); // Dół
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y, shapeBox.X, shapeBox.Y + shapeBox.Height, line, ref intersections); // Lewa

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (shapeBox.Contains(line.X1, line.Y1))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private void FindCircleIntersections(CircleShape circle, LineShape line, ref List<Point> intersections)
    {
        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - circle.X;
        double fy = line.Y1 - circle.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (circle.Radius * circle.Radius);

        double discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return; // Brak przecięć

        discriminant = Math.Sqrt(discriminant);
        double t1 = (-b - discriminant) / (2 * a);
        double t2 = (-b + discriminant) / (2 * a);

        if (t1 >= 0 && t1 <= 1)
            intersections.Add(new Point(line.X1 + t1 * dx, line.Y1 + t1 * dy));

        if (t2 >= 0 && t2 <= 1)
            intersections.Add(new Point(line.X1 + t2 * dx, line.Y1 + t2 * dy));
    }

    private bool IsPointInsideCircle(double x, double y, CircleShape circle)
    {
        double dx = x - circle.X;
        double dy = y - circle.Y;
        return (dx * dx + dy * dy) <= (circle.Radius * circle.Radius);
    }

    public void ShortenLineToShape(LineShape line, List<(Point Start, Point End)> edges)
    {
        List<Point> intersections = new List<Point>();

        Console.WriteLine($"Sprawdzanie linii ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");

        // 1️⃣ Znajdź wszystkie przecięcia linii z krawędziami domu
        foreach (var (start, end) in edges)
        {
            if (FindIntersection(start.X, start.Y, end.X, end.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        // 2️⃣ Usuń duplikaty i posortuj przecięcia względem wysokości (Y)
        intersections = intersections
            .Distinct()
            .OrderBy(p => p.Y) // Sortujemy od góry do dołu
            .ToList();

        Console.WriteLine($"Znalezione przecięcia: {intersections.Count}");

        if (intersections.Count >= 2)
        {
            // 3️⃣ Przycinamy do najwyższego i najniższego przecięcia
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[^1].X; // Ostatni element listy to dolne przecięcie (bottomY)
            line.Y2 = intersections[^1].Y;

            Console.WriteLine($"Linia obcięta do: ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");
        }
        else if (intersections.Count == 1)
        {
            List<Point> vertices = edges
                .SelectMany(e => new[] { e.Start, e.End })
                .Distinct()
                .ToList();

            if (IsPointInsidePolygon(line.X1, line.Y1, vertices))
            {
                // Jeśli linia zaczyna się wewnątrz kształtu – przycinamy koniec
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
                Console.WriteLine($"Przycinam końcówkę do: ({line.X2}, {line.Y2})");
            }
            else
            {
                // Jeśli linia zaczyna się na zewnątrz – przycinamy początek
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
                Console.WriteLine($"Przycinam początek do: ({line.X1}, {line.Y1})");
            }
        }
        else
        {
            Console.WriteLine("Brak przecięć – linia pozostaje bez zmian.");
        }
    }

    private LineShape ExtendLineToBoundingBox(LineShape line, BoundingBox bbox)
    {
        double x1 = line.X1, y1 = line.Y1, x2 = line.X2, y2 = line.Y2;
        double dx = x2 - x1, dy = y2 - y1;

        if (dx == 0)
        {
            return new LineShape(x1, bbox.Y, x2, bbox.Y + bbox.Height, _scaleFactor, line.NazwaObj, line.RuchomySlupek, line.PionPoziom, line.DualRama);
        }
        if (dy == 0)
        {
            return new LineShape(bbox.X, y1, bbox.X + bbox.Width, y2, _scaleFactor, line.NazwaObj, line.RuchomySlupek, line.PionPoziom, line.DualRama);
        }

        double leftFactor = (bbox.X - x1) / dx;
        double rightFactor = ((bbox.X + bbox.Width) - x1) / dx;
        double topFactor = (bbox.Y - y1) / dy;
        double bottomFactor = ((bbox.Y + bbox.Height) - y1) / dy;

        double minFactor = Math.Min(leftFactor, Math.Min(rightFactor, Math.Min(topFactor, bottomFactor)));
        double maxFactor = Math.Max(leftFactor, Math.Max(rightFactor, Math.Max(topFactor, bottomFactor)));

        double newX1 = x1 + dx * minFactor;
        double newY1 = y1 + dy * minFactor;
        double newX2 = x1 + dx * maxFactor;
        double newY2 = y1 + dy * maxFactor;

        return new LineShape(newX1, newY1, newX2, newY2, _scaleFactor, line.NazwaObj, line.RuchomySlupek);
    }

    public void RemoveLinesOutsideShapes()
    {
        Console.WriteLine("Start RemoveLinesOutsideShapes");

        if (_shapes == null || !_shapes.Any())
        {
            Console.WriteLine("Kolekcja _shapes jest pusta!");
            return;
        }

        var linesToCheck = _shapes.OfType<LineShape>().ToList();

        var shapesWithEdges = _shapes
            .Where(shape => shape is not LineShape)
            .Select(shape => new
            {
                Shape = shape,
                Edges = GetShapeEdges(shape) ?? new List<(Point Start, Point End)>()
            })
            .ToList();

        var linesToRemove = new List<LineShape>();

        foreach (var line in linesToCheck)
        {
            bool isCompletelyOutside = true;

            foreach (var shapeWithEdges in shapesWithEdges)
            {
                if (!shapeWithEdges.Edges.Any()) continue;

                var polygonVertices = shapeWithEdges.Edges
                    .SelectMany(e => new[] { e.Start, e.End })
                    .Distinct()
                    .ToList();

                bool startInside = IsPointInsidePolygon(line.X1, line.Y1, polygonVertices);
                bool endInside = IsPointInsidePolygon(line.X2, line.Y2, polygonVertices);
                bool intersects = DoesLineIntersectPolygon(line, shapeWithEdges.Edges);

                // Jeśli linia jest CAŁKOWICIE wewnątrz lub ją przecina, nie usuwaj
                if (startInside || endInside || intersects)
                {
                    isCompletelyOutside = false;
                    break;
                }
            }

            if (isCompletelyOutside)
            {
                Console.WriteLine($"Linia ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2}) jest poza wszystkimi kształtami.");
                linesToRemove.Add(line);
            }
        }

        foreach (var line in linesToRemove)
        {
            _shapes.Remove(line);
        }

        Console.WriteLine($"Usunięto {linesToRemove.Count} linii");
    }

    private bool DoesLineIntersectPolygon(LineShape line, List<(Point Start, Point End)> edges)
    {
        foreach (var edge in edges)
        {
            if (DoLinesIntersect(line.X1, line.Y1, line.X2, line.Y2,
                                 edge.Start.X, edge.Start.Y, edge.End.X, edge.End.Y))
            {
                return true; // Linia przecina kształt
            }
        }
        return false;
    }

    private bool DoLinesIntersect(double x1, double y1, double x2, double y2,
                              double x3, double y3, double x4, double y4)
    {
        double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (d == 0) return false; // Linie są równoległe

        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d;
        double u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / d;

        return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    private List<(Point Start, Point End)> GetShapeEdges(IShapeDC shape)
    {
        switch (shape)
        {
            case CircleShape circle:
                return GetApproximateEdges(circle, 32); // Przybliżenie okręgu wielokątem
            case RectangleShape rect:
                return rect.GetEdges();
            case TriangleShape triangle:
                return triangle.GetEdges();
            case TrapezoidShape trapezoid:
                return trapezoid.GetEdges();
            case HouseShape house:
                var (roofEdges, baseEdges) = house.GetEdgesDel();
                return roofEdges.Concat(baseEdges).ToList();
            case RoundedTopRectangleShape roundedRect:
                return roundedRect.GetEdges();
            default:
                return shape.GetBoundingBox()?.GetEdges()
                .Select(edge => (new Point(edge.Start.X, edge.Start.Y), new Point(edge.End.X, edge.End.Y)))
                .ToList()
                ?? new List<(Point, Point)>();

        }
    }

    private bool IsPointInsideAnyShape(double x, double y, List<object> shapes)
    {
        foreach (var shape in shapes)
        {
            if (shape is CircleShape circle && IsPointInsideCircle(x, y, circle))
                return true;

            if (shape is TriangleShape triangle && IsPointInsidePolygon(x, y, triangle.GetVertices()))
                return true;

            if (shape is SquareShape square && IsPointInsideRectangle(x, y, square.ToRectangleShape()))
                return true;

            if (shape is RectangleShape rectangle && IsPointInsideRectangle(x, y, rectangle.ToRectangleShape()))
                return true;

            if (shape is TrapezoidShape trapezoid && IsPointInsidePolygon(x, y, trapezoid.GetVertices()))
                return true;

            if (shape is HouseShape house)
            {
                var (roof, walls) = house.GetVertices();
                if (IsPointInsidePolygon(x, y, roof) || IsPointInsidePolygon(x, y, walls))
                    return true;
            }

            if (shape is RoundedTopRectangleShape roundedRect && IsPointInsideRoundedRectangle(x, y, roundedRect))
                return true;
        }

        return false; // Jeśli żaden kształt nie zawiera punktu
    }


    private void ShortenLineInsidePolygon(LineShape line, List<Point> polygonVertices)
    {
        List<Point> intersections = new List<Point>();

        int count = polygonVertices.Count;
        for (int i = 0; i < count; i++)
        {
            Point p1 = polygonVertices[i];
            Point p2 = polygonVertices[(i + 1) % count];

            if (FindIntersection(p1.X, p1.Y, p2.X, p2.Y, line.X1, line.Y1, line.X2, line.Y2, out double ix, out double iy))
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        Console.WriteLine($"ShortenLineInsidePolygon -> intersections.Count: {intersections.Count}");

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsidePolygon(line.X1, line.Y1, polygonVertices))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private List<Point> FindCircleLineIntersections(Point center, double radius, LineShape line)
    {
        List<Point> intersections = new List<Point>();

        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - center.X;
        double fy = line.Y1 - center.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (radius * radius);

        double discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return intersections; // Brak przecięć

        discriminant = Math.Sqrt(discriminant);
        double t1 = (-b - discriminant) / (2 * a);
        double t2 = (-b + discriminant) / (2 * a);

        if (t1 >= 0 && t1 <= 1)
        {
            double ix = line.X1 + t1 * dx;
            double iy = line.Y1 + t1 * dy;
            if (iy <= center.Y) // Punkt musi być wewnątrz górnego łuku
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        if (t2 >= 0 && t2 <= 1)
        {
            double ix = line.X1 + t2 * dx;
            double iy = line.Y1 + t2 * dy;
            if (iy <= center.Y) // Punkt musi być wewnątrz górnego łuku
            {
                intersections.Add(new Point(ix, iy));
            }
        }

        return intersections;
    }

    private bool IsPointInsideEdges(double x, double y, List<(Point Start, Point End)> edges, Point? arcCenter = null, double arcRadius = 0)
    {
        int intersections = 0;

        foreach (var edge in edges)
        {
            double x1 = edge.Start.X, y1 = edge.Start.Y;
            double x2 = edge.End.X, y2 = edge.End.Y;

            // Sprawdzamy, czy pozioma linia przecina dany odcinek
            if ((y1 > y) != (y2 > y))
            {
                double intersectX = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                if (intersectX > x)
                {
                    intersections++;
                }
            }
        }

        // Jeśli mamy łuk – sprawdzamy, czy punkt jest wewnątrz okręgu
        if (arcCenter.HasValue)
        {
            double dx = x - arcCenter.Value.X;
            double dy = y - arcCenter.Value.Y;
            double distanceSquared = dx * dx + dy * dy;

            if (distanceSquared <= arcRadius * arcRadius)
            {
                return true; // Punkt jest wewnątrz łuku
            }
        }

        return (intersections % 2) == 1; // Jeśli liczba przecięć jest nieparzysta, punkt jest wewnątrz
    }

    private bool IsPointInsideRoundedRectangle(double x, double y, RoundedTopRectangleShape rect)
    {
        return IsPointInsideRoundedRectangle(x, y, new RoundedRectangleShape(rect.X, rect.Y, rect.Width, rect.Height, rect.Radius, _scaleFactor));
    }

    private bool IsPointInsideRoundedRectangle(double x, double y, RoundedRectangleShape rect)
    {
        // Pobieramy wymiary prostokąta i promień zaokrąglenia
        double left = rect.X;
        double top = rect.Y;
        double right = rect.X + rect.Width;
        double bottom = rect.Y + rect.Height;
        double radius = rect.Radius;

        // Sprawdzenie, czy punkt znajduje się w prostokątnej części (bez zaokrągleń)
        if (x >= left + radius && x <= right - radius &&
            y >= top && y <= bottom)
        {
            return true;
        }

        if (x >= left && x <= right &&
            y >= top + radius && y <= bottom - radius)
        {
            return true;
        }

        // Sprawdzenie, czy punkt znajduje się w jednym z czterech zaokrąglonych rogów
        return IsPointInsideCircle(x, y, left + radius, top + radius, radius) ||  // Lewy górny róg
               IsPointInsideCircle(x, y, right - radius, top + radius, radius) || // Prawy górny róg
               IsPointInsideCircle(x, y, left + radius, bottom - radius, radius) || // Lewy dolny róg
               IsPointInsideCircle(x, y, right - radius, bottom - radius, radius);  // Prawy dolny róg
    }

    // Pomocnicza funkcja sprawdzająca, czy punkt znajduje się wewnątrz okręgu
    private bool IsPointInsideCircle(double px, double py, double cx, double cy, double radius)
    {
        return Math.Pow(px - cx, 2) + Math.Pow(py - cy, 2) <= Math.Pow(radius, 2);
    }


    private bool IsPointInsideRectangle(double x, double y, RectangleShape rectangle)
    {
        var bbox = rectangle.GetBoundingBox(); // Powinno zwracać strukturalne dane o prostokącie
        return x >= bbox.X && x <= (bbox.X + bbox.Width) &&
               y >= bbox.Y && y <= (bbox.Y + bbox.Height);
    }

    private bool IsPointInsidePolygon(double x, double y, List<Point> polygonVertices)
    {
        int count = polygonVertices.Count;
        bool inside = false;

        for (int i = 0, j = count - 1; i < count; j = i++)
        {
            double xi = polygonVertices[i].X, yi = polygonVertices[i].Y;
            double xj = polygonVertices[j].X, yj = polygonVertices[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private bool IsPointInsidePolygonSkos(double x, double y, List<(Point Start, Point End)> edges)
    {
        // Konwersja krawędzi na listę unikalnych wierzchołków
        List<Point> polygonVertices = edges
            .Select(e => e.Start) // Pobieramy tylko początkowe punkty krawędzi
            .Distinct()
            .ToList();

        int count = polygonVertices.Count;
        bool inside = false;

        for (int i = 0, j = count - 1; i < count; j = i++)
        {
            double xi = polygonVertices[i].X, yi = polygonVertices[i].Y;
            double xj = polygonVertices[j].X, yj = polygonVertices[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }

        return inside;
    }


    private void CheckEdgeIntersection(double edgeX1, double edgeY1, double edgeX2, double edgeY2,
                                    LineShape line, ref List<Point> intersections)
    {
        if (FindIntersection(edgeX1, edgeY1, edgeX2, edgeY2,
                             line.X1, line.Y1, line.X2, line.Y2,
                             out double intersectX, out double intersectY))
        {
            var newPoint = new Point(intersectX, intersectY);
            if (!intersections.Any(p => Math.Abs(p.X - newPoint.X) < 0.001 && Math.Abs(p.Y - newPoint.Y) < 0.001))
            {
                intersections.Add(newPoint);
            }
        }
    }

    private bool FindIntersection(double aX1, double aY1, double aX2, double aY2,
                               double bX1, double bY1, double bX2, double bY2,
                               out double x, out double y)
    {
        x = 0;
        y = 0;

        double d = (aX1 - aX2) * (bY1 - bY2) - (aY1 - aY2) * (bX1 - bX2);
        if (Math.Abs(d) < 0.001) return false; // Linie równoległe

        double t = ((aX1 - bX1) * (bY1 - bY2) - (aY1 - bY1) * (bX1 - bX2)) / d;
        double u = -((aX1 - aX2) * (aY1 - bY1) - (aY1 - aY2) * (aX1 - bX1)) / d;

        if (t < 0 || t > 1 || u < 0 || u > 1) return false; // Punkt przecięcia poza odcinkami

        x = aX1 + t * (aX2 - aX1);
        y = aY1 + t * (aY2 - aY1);

        return true;
    }

    private bool IsPointOnSegment(Point start, Point end, Point point)
    {
        double crossProduct = (point.Y - start.Y) * (end.X - start.X) - (point.X - start.X) * (end.Y - start.Y);
        if (Math.Abs(crossProduct) > 0.001) return false; // Punkt nie leży dokładnie na linii

        double dotProduct = (point.X - start.X) * (end.X - start.X) + (point.Y - start.Y) * (end.Y - start.Y);
        if (dotProduct < 0) return false; // Punkt leży przed startem

        double squaredLength = (end.X - start.X) * (end.X - start.X) + (end.Y - start.Y) * (end.Y - start.Y);
        if (dotProduct > squaredLength) return false; // Punkt leży za końcem

        return true; // Punkt leży na odcinku
    }

    private double Distance(double x1, double y1, double x2, double y2)
    {
        return Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));
    }

    public struct Point
    {
        public double X { get; set; }
        public double Y { get; set; }
        public Point(double x, double y) { X = x; Y = y; }
    }

    public static IShapeDC ConvertOldShapeToNew(IShapeDC oldShape)
    {
        switch (oldShape)
        {
            case LineShape line:
              //  return line;
               return new XLineShape(line.X1, line.Y1, line.X2, line.Y2, 1.0, line.NazwaObj, line.RuchomySlupek, line.PionPoziom, line.DualRama);

            case RectangleShape rect:
                 return new XRectangleShape(rect.X, rect.Y, rect.Width, rect.Height, 1.0);

            case CircleShape circle:
                return new XCircleShape(circle.X, circle.Y, circle.Radius, 1.0);

            case TriangleShape triangle:
                return new XTriangleShape(triangle.BaseX1, triangle.BaseY, triangle.BaseWidth, triangle.BaseWidth, 1.0);

            case TrapezoidShape trapezoid:
                return new XTrapezoidShape(trapezoid.X, trapezoid.Y, trapezoid.X + trapezoid.BaseWidth, trapezoid.Y + trapezoid.Height, 0.5, 1.0, 0);

            case HouseShape house:
                return new XHouseShape(house.X, house.Y, house.Width, house.Height, house.HeightLeft, house.HeightRight, 1.0);

            case RoundedRectangleShape rounded:
                return new XRoundedTopRectangleShape(rounded.X, rounded.Y, rounded.Width, rounded.Height, rounded.Radius, 1.0);

            case RoundedTopRectangleShape roundedTop:
                return new XRoundedTopRectangleShape(roundedTop.X, roundedTop.Y, roundedTop.Width, roundedTop.Height, roundedTop.Radius, 1.0);

            // Dodaj pozostałe typy jeśli masz

            default:
                Console.WriteLine($"Nieznany typ kształtu: {oldShape.GetType()}");
                return oldShape;
        }
    }
}