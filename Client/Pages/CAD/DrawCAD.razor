@page "/DrawCAD"
@inject IJSRuntime JSRuntime
@inject GEORGE.Client.Pages.KonfiguratorOkien.ShapeTransferService ShapeService
@inject NavigationManager Navigation
@using GEORGE.Client.Pages.KonfiguratorOkien
@using GEORGE.Client.Pages.Models

@using Blazor.Extensions.Canvas.Canvas2D
@implements IDisposable

<style>
    .toolbar {
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px;
    background: #f4f4f4;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .tool-button {
    background: #ffffff;
    border: 2px solid #ddd;
    padding: 10px;
    cursor: pointer;
    border-radius: 6px;
    transition: 0.3s;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .tool-button:hover {
    background: #e0e0e0;
    }

    .tool-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
    }

    .canvas-container {
    position: relative;
    border: 1px solid #fd7e14;
    width: @(_canvasX + "px");
    height: @(_canvasY + "px");
    margin: 20px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;
    overflow: auto;
    }


    canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
    background-color: transparent;
    }


    .tool-icon {
    width: 24px;
    height: 24px;
    fill: black;
    }

    .tool-button.active .tool-icon {
    fill: white;
    }

    .property-panel {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    }

    .property-row {
    display: flex;
    margin-bottom: 8px;
    align-items: center;
    }

    .property-label {
    width: 100px;
    font-weight: bold;
    }

    .property-input {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 180px;
    }

    .zoom-controls {
    position: absolute;
    top: 170px; /* Ustawienie 10px od góry */
    right: 10px; /* Ustawienie 10px od prawej */
    display: flex;
    gap: 10px; /* Odstęp między przyciskami */
    z-index: 1000; /* Upewnia się, że są na wierzchu */
    }
</style>

<script>
    function initCanvasEvents(container, dotNetHelper) {
    const canvas = container.querySelector('canvas');

    // Nasłuchuj zdarzenia na oknie zamiast na canvasie
    window.addEventListener('keydown', (e) => {
    if (e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', true);
    });
    window.addEventListener('keyup', (e) => {
    if (!e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', false);
    });

    // Reszta handlerów bez zmian
    const handler = (e) => {
    const rect = canvas.getBoundingClientRect();
    return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
    };
    };

    canvas.addEventListener('mousedown', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseDown', x, y);
    });

    canvas.addEventListener('mousemove', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseMove', x, y);
    });

    canvas.addEventListener('mouseup', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseUp', x, y);
    });
    }
</script>

<!-- Kontener na przyciski -->
<div class="zoom-controls">
    <button @onclick="() => FitToCanvas()" class="btn-zoom">🔄 Dopasuj</button>
    <button @onclick="() => RysOkna()" class="btn-window">🔥 Popraw szkic OKNA</button>
    <button @onclick="() => PowrotDoGenerowaniaOkna()" class="btn-window"><strong>📦 Wróć do budowy OKNA</strong></button>
</div>

<div class="toolbar">
    <button class="tool-button @(_selectedTool == "line" ? "active" : "")" title="Linia poprzeczki lub słupka stałego"
    @onclick='() => SetTool("line")'>
        @SvgLine()
    </button>

    <button class="tool-button @(_selectedTool == "line_hv" ? "active" : "")" title="Linia poprzeczki lub słupka stałego rysowana tylko w poziomie lub pionie"
    @onclick='() => SetTool("line_hv")'>
        @SvgLineHV()
    </button>

    <button class="tool-button @(_selectedTool == "line_dual_ram_hv" ? "active" : "")" title="Linia podziału na dwie oddzielne ramy"
    @onclick='() => SetTool("line_dual_ram_hv")'>
        @SvgLineDualRamHV()
    </button>

    <button class="tool-button @(_selectedTool == "line_hvSLRuch" ? "active" : "")" title="Linia podziału słupja ruchomego"
    @onclick='() => SetTool("line_hvSLRuch")'>
        @SvgLineHVRS()
    </button>

    <button class="tool-button @(_selectedTool == "triangle" ? "active" : "")" title="Kształ ramy - trójkąt"
    @onclick='() => SetTool("triangle")'>
        @SvgTriangle()
    </button>

    <button class="tool-button @(_selectedTool == "circle" ? "active" : "")" title="Kształ ramy - kołowy"
    @onclick='() => SetTool("circle")'>
        @SvgCircle()
    </button>

    <button class="tool-button @(_selectedTool == "square" ? "active" : "")" title="Kształ ramy - kwadrat"
    @onclick='() => SetTool("square")'>
        @SvgSquare()
    </button>

    <button class="tool-button @(_selectedTool == "rectangle" ? "active" : "")" title="Kształ ramy - prostokąt"
    @onclick='() => SetTool("rectangle")'>
        @SvgRectangle()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoidLeft" ? "active" : "")" title="Kształ ramy - trapezoid"
    @onclick='() => SetTool("trapezoidLeft")'>
        @SvgTrapezoidLeft()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoidRight" ? "active" : "")" title="Kształ ramy - trapezoid"
    @onclick='() => SetTool("trapezoidRight")'>
        @SvgTrapezoidRight()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoid" ? "active" : "")" title="Kształ ramy - trapez"
    @onclick='() => SetTool("trapezoid")'>
        @SvgTrapezoid()
    </button>

    <button class="tool-button @(_selectedTool == "rounded_rect" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonymi górnymi rogami"
    @onclick='() => SetTool("rounded_rect")'>
        @SvgRoundedRect()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_rect_left" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonym lewem rogiem"
    @onclick='() => SetTool("rounded_rect_left")'>
        @SvgRoundedRectLeft()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_rect_right" ? "active" : "")" title="Kształ ramy - prostokąt z zaokrąglonym prawym rogiem"
    @onclick='() => SetTool("rounded_rect_right")'>
        @SvgRoundedRectRight()
    </button>
    <button class="tool-button @(_selectedTool == "house" ? "active" : "")" title="Kształ ramy - typ domek"
    @onclick='() => SetTool("house")'>
        @SvgHouse()
    </button>
    <button class="tool-button @(_selectedTool == "rounded_top_rect" ? "active" : "")" title="Kształ ramy - prostokąt z łukiem u góry"
    @onclick='() => SetTool("rounded_top_rect")'>
        @SvgRoundedTopRect()
    </button>
</div>

<div class="canvas-container" @ref="_container">
    <BECanvas Width="@_canvasX" Height="@_canvasY" @ref="_canvas"></BECanvas>
</div>

@if (_shapes.Count > 0)
{
    <div class="property-panel">
        <h3>Właściwości kształtu</h3>

        @if (_selectedShapeIndex >= 0)
        {
            @foreach (var prop in _shapes[_selectedShapeIndex].GetEditableProperties())
            {
                <div class="property-row">
                    <span class="property-label">[@prop.NazwaObiektu] - @prop.Label</span>
                    @if (!prop.IsReadOnly)
                    {
                        <input class="property-input" type="number"
                        @bind="prop.Value"
                        @bind:event="onchange"
                        @bind:after="async () => await RedrawCanvas()" />
                    }
                    else
                    {
                        <span class="property-value">@prop.Value</span>
                    }
                </div>
            }
        }

        <button @onclick="SelectPreviousShape">Poprzedni obiekt</button>
        <button @onclick="SelectNextShape">Następny obiekt</button>
    </div>
}

@code {
    private Canvas2DContext? _ctx;
    private BECanvasComponent? _canvas;
    private ElementReference _container;
    private DotNetObjectReference<GEORGE.Client.Pages.CAD.DrawCAD>? _dotNetHelper;
    private bool _isDrawing = false;
    private double _startX, _startY, _currentX, _currentY;
    private string _selectedTool = "line";
    private List<IShapeDC> _shapes = new List<IShapeDC>();

    // Dodaj nowe pole dla wymuszenia kierunku
    private bool _forceHV = false;

    private long _canvasX = 900;
    private long _canvasY = 600;

    private int _selectedShapeIndex = -1; // Przechowuje indeks aktualnie edytowanego kształtu

    private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

    private List<IShapeDC> _originalShapes;


    private void SetTool(string tool) => _selectedTool = tool;

    [JSInvokable]
    public void SetForceHV(bool state) => _forceHV = state;

    protected override async Task OnInitializedAsync()
    {
        _shapes = ShapeService.Shapes; // Odbiór danych z serwisu

        if(_shapes != null)
        {
            _originalShapes = _shapes.Select(s => s.Clone()).ToList();

            await FitToCanvas();

            StateHasChanged();
        }
        else
        {
            Console.WriteLine("Nie udało się pobrać kształtów z serwisu ShapeService.");
        }
    }

    private bool _hasInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_hasInitialized)
        {
            _hasInitialized = true;
            _ctx = await _canvas.CreateCanvas2DAsync();
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initCanvasEvents", _container, _dotNetHelper);
            await ClearCanvas();

            if (_shapes != null)
            {
                await RedrawCanvas();     // <- teraz canvas już istnieje w DOM
                await FitToCanvas();

                StateHasChanged();
            }
        }
    }

    private RenderFragment SvgLine() => builder =>
       {
           builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
       };

    private RenderFragment SvgLineHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='black' stroke-width='2'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
    };

    private RenderFragment SvgLineDualRamHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='orange' stroke-width='4'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='orange' stroke-width='4'/>
        </svg>");
    };

    private RenderFragment SvgLineHVRS() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='red' stroke-width='3'/>
        </svg>");
    };

    private RenderFragment SvgTriangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 4,20 20,20'
                     stroke='black'
                     stroke-width='2'
                     fill='none'/>
        </svg>");
    };

    private RenderFragment SvgCircle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <circle cx='12' cy='12' r='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgSquare() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='6' y='6' width='12' height='12' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRectangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='4' y='8' width='16' height='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoid() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoidLeft() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='4,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoidRight() => builder =>
     {
         builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 20,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
     };

    private RenderFragment SvgRoundedRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <path d='
                M8,7
                a3,3 0 0 0 -3,3
                v7
                h14
                v-7
                a3,3 0 0 0 -3,-3
                h-8
                z
            ' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedRectLeft() => builder =>
    {
        builder.AddMarkupContent(0, @"
    <svg class='tool-icon' viewBox='0 0 24 24'>
        <path d='
            M8,7
            a3,3 0 0 0 -3,3 
            v4
            a0,0 0 0 0 0,0
            h14
            a0,0 0 0 0 0,-0
            v-7
            h-11
            z
        ' stroke='black' stroke-width='2' fill='none'/>
    </svg>");
    };

    private RenderFragment SvgRoundedRectRight() => builder =>
    {
        builder.AddMarkupContent(0, @"
    <svg class='tool-icon' viewBox='0 0 24 24'>
        <path d='
            M5,7
            h11
            a3,3 0 0 1 3,3
            v4
            a0,0 0 0 1 -0,0
            h-14
            a0,0 0 0 1 0,0
            v-7
            z
        ' stroke='black' stroke-width='2' fill='none'/>
    </svg>");
    };

    private RenderFragment SvgHouse() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 20,10 20,20 4,20 4,10' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedTopRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <path d='M4 10 Q12 2, 20 10 V20 H4 Z' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    [JSInvokable]
    public async Task HandleMouseDown(double x, double y)
    {
        _isDrawing = true;
        _startX = x;
        _startY = y;
        _currentX = x;
        _currentY = y;
        await Task.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleMouseMove(double x, double y)
    {
        if (!_isDrawing) return;

        // Rozszerzona logika dla wymuszonego kierunku
        if (_selectedTool == "line_hv" || _selectedTool == "line_hvSLRuch" || _selectedTool == "line_dual_ram_hv" || _forceHV)
        {
            const double sensitivity = 5;
            var dx = Math.Abs(x - _startX);
            var dy = Math.Abs(y - _startY);

            if (dx < sensitivity && dy < sensitivity) return;

            var isHorizontal = dx > dy;
            _currentX = isHorizontal ? x : _startX;
            _currentY = isHorizontal ? _startY : y;
        }
        else
        {
            _currentX = x;
            _currentY = y;
        }

        await RedrawCanvas();
    }

    [JSInvokable]
    public async Task HandleMouseUp(double x, double y)
    {
        if (!_isDrawing) return;
        _isDrawing = false;

        IShapeDC newShape = _selectedTool switch
        {
            "line" => new XLineShape(_startX, _startY, _currentX, _currentY, _scaleFactor,"Lina skośna"),
            "line_hv" => new XLineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia pion. poziom.",false, true),
            "line_hvSLRuch" => new XLineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia pion. sł. ruchomy", true),
            "line_dual_ram_hv" => new XLineShape(_startX, _startY, _currentX, _currentY, _scaleFactor, "Linia podziału ram", false, true, true),
            "circle" => new XCircleShape(_startX, _startY, CalculateRadius(), _scaleFactor),
            "triangle" => new XTriangleShape(_startX, _startY, _currentX, _currentY, _scaleFactor),
            "square" => new XSquareShape(_startX, _startY, Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY)), _scaleFactor),
            "rectangle" => new XRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, _scaleFactor),
            "trapezoid" => new XTrapezoidShape(_startX, _startY, _currentX, _currentY, 0.6, _scaleFactor, 0),
            "trapezoidLeft" => new XTrapezoidShape(_startX, _startY, _currentX, _currentY, 0.6, _scaleFactor, 1),
            "trapezoidRight" => new XTrapezoidShape(_startX, _startY, _currentX, _currentY, 0.6, _scaleFactor, 2),
            "rounded_rect" => new XRoundedRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, 100, _scaleFactor),
            "rounded_rect_left" => new XRoundedRectangleShapeLeft(_startX, _startY, _currentX - _startX, _currentY - _startY, 100, _scaleFactor),//left
            "rounded_rect_right" => new XRoundedRectangleShapeRight(_startX, _startY, _currentX - _startX, _currentY - _startY, 100, _scaleFactor),//right
            "house" => new XHouseShape(_startX, _startY, _currentX - _startX, _currentY - _startY, (_currentY - _startY) * 0.5, (_currentY - _startY) * 0.5, _scaleFactor),
            "rounded_top_rect" => new XRoundedTopRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, (_currentX - _startX) / 2, _scaleFactor),

            _ => throw new NotImplementedException()
        };

        _shapes.Add(newShape);

        await RedrawCanvas();
    }

    private double CalculateRadius()
    {
        return Math.Sqrt(Math.Pow(_currentX - _startX, 2) + Math.Pow(_currentY - _startY, 2));
    }

    private async Task RedrawCanvas()
    {
        if (_ctx == null)
        {
            Console.WriteLine("Kontekst Canvas2D nie jest zainicjalizowany.");
            return;
        }

        await ClearCanvas();

        await _ctx.SaveAsync();
        await _ctx.ScaleAsync(_scaleFactor, _scaleFactor); // Skalowanie dla całego rysunku

        foreach (var shape in _shapes)
        {
            await shape.Draw(_ctx);
        }

        await _ctx.RestoreAsync(); // Przywrócenie oryginalnej skali

        // Rysuj podgląd aktualnie rysowanego kształtu
        if (_isDrawing)
        {
            await _ctx.SetStrokeStyleAsync("rgba(0,0,0,0.5)");
            await _ctx.SetLineWidthAsync(2);

            switch (_selectedTool)
            {
                case "line":
                case "line_hv":
                    await DrawPreviewLine();
                    break;
                case "line_dual_ram_hv":
                    await DrawPreviewDualRamLine();
                    break;
                case "line_hvSLRuch":
                    await DrawPreviewVerticalLine();
                    break;
                case "circle":
                    await DrawPreviewCircle();
                    break;
                case "square":
                    await DrawPreviewSquare();
                    break;
                case "rectangle":
                    await DrawPreviewRectangle();
                    break;
                case "trapezoid":
                    await DrawPreviewTrapezoid();
                    break;
                case "trapezoidLeft":
                    await DrawPreviewTrapezoidLeft();
                    break;
                case "trapezoidRight":
                    await DrawPreviewTrapezoidRight();
                    break;
                case "triangle":
                    await DrawPreviewTriangle();
                    break;
                case "rounded_rect":
                    await DrawPreviewRoundedRect();
                    break;
                case "rounded_rect_left":
                    await DrawPreviewRoundedRectLeft();
                    break;
                case "rounded_rect_right":
                    await DrawPreviewRoundedRectRight();
                    break;
                case "house":
                    await DrawPreviewHouse();
                    break;
                case "rounded_top_rect":
                    await DrawPreviewRoundedTopRect();
                    break;

            }
        }
    }

    private async Task DrawPreviewSquare()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var size = Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY));
        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, size, size);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRectangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, _currentX - _startX, _currentY - _startY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTriangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        // Oblicz środkowy punkt podstawy
        var baseCenterX = (_startX + _currentX) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(baseCenterX, _startY);       // Górny wierzchołek
        await _ctx.LineToAsync(_currentX, _currentY);      // Prawy dolny wierzchołek
        await _ctx.LineToAsync(_startX, _currentY);        // Lewy dolny wierzchołek
        await _ctx.ClosePathAsync();                       // Automatycznie łączy z pierwszym punktem

        await _ctx.StrokeAsync();

    }

    private async Task DrawPreviewTrapezoid()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTrapezoidLeft()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX;// + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTrapezoidRight()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(_currentX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 100; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRectLeft()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 100; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width, _startY);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRectRight()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();
        await _ctx.SetStrokeStyleAsync("black");

        var radius = 100; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewLine()
    {
        await _ctx.SetStrokeStyleAsync("blue");
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewDualRamLine()
    {
        await _ctx.SetStrokeStyleAsync("orange");
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewVerticalLine()
    {
        await _ctx.SetStrokeStyleAsync("red"); // Kolor linii
        await _ctx.BeginPathAsync();

        // X nie zmienia się - linia zawsze pionowa!
        await _ctx.MoveToAsync(_startX, Math.Min(_startY, _currentY));
        await _ctx.LineToAsync(_startX, Math.Max(_startY, _currentY));

        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewCircle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await _ctx.SetStrokeStyleAsync("black");
        await ClearCanvas();

        var radius = CalculateRadius();
        await _ctx.BeginPathAsync();
        await _ctx.ArcAsync(_startX, _startY, radius, 0, 2 * Math.PI);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewHouse()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        // Zapewniamy poprawne współrzędne
        var x = Math.Min(_startX, _currentX);
        var y = Math.Min(_startY, _currentY);
        var width = Math.Abs(_currentX - _startX);
        var height = Math.Abs(_currentY - _startY);
        var roofHeight = height * 0.5; // Dach zajmuje 50% wysokości

        var baseY = y + roofHeight;
        var roofPeakX = x + width / 2;
        var roofPeakY = y;

        await _ctx.BeginPathAsync();

        // Dach (trójkąt) – zaczynamy od lewego rogu dachu
        await _ctx.MoveToAsync(x, baseY);
        await _ctx.LineToAsync(roofPeakX, roofPeakY);
        await _ctx.LineToAsync(x + width, baseY);

        // Podstawa (prostokąt) – rysujemy płynnie
        await _ctx.LineToAsync(x + width, y + height);
        await _ctx.LineToAsync(x, y + height);
        await _ctx.LineToAsync(x, baseY);

        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedTopRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var width = _currentX - _startX;
        var height = _currentY - _startY;
        var arcRadius = width / 2; // Łuk rozciąga się na całą szerokość

        await _ctx.BeginPathAsync();

        // Rysowanie dolnej części prostokąta
        await _ctx.MoveToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX + width, _startY + arcRadius);

        // Rysowanie górnego łuku
        await _ctx.ArcAsync(_startX + arcRadius, _startY + arcRadius, arcRadius, 0, Math.PI, true);

        // Dokończenie prostokąta
        await _ctx.LineToAsync(_startX, _startY + arcRadius);
        await _ctx.LineToAsync(_startX, _startY + height);

        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task ClearCanvas()
    {
        await _ctx.SetFillStyleAsync("white");
        await _ctx.FillRectAsync(0, 0, _canvasX, _canvasY);

        _scaleFactor = 1.0; // Reset skali
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }

    private List<(XPoint Start, XPoint End)> GetApproximateEdges(XCircleShape circle, int segments)
    {
        var edges = new List<(XPoint Start, XPoint End)>();
        double centerX = circle.X;
        double centerY = circle.Y;
        double radius = circle.Radius;
        double angleStep = 2 * Math.PI / segments;

        XPoint firstPoint = new XPoint(centerX + radius * Math.Cos(0), centerY + radius * Math.Sin(0));
        XPoint prevPoint = firstPoint;

        for (int i = 1; i <= segments; i++)
        {
            double angle = i * angleStep;
            XPoint newPoint = new XPoint(centerX + radius * Math.Cos(angle), centerY + radius * Math.Sin(angle));
            edges.Add((prevPoint, newPoint));
            prevPoint = newPoint;
        }

        return edges;
    }


    // // 🔧 KLASY EDYTOWALNYCH WŁAŚCIWOŚCI
    // public record EditableProperty(
    //     string Label,
    //     Func<double> GetValue,
    //     Action<double> SetValue,
    //     string NazwaObiektu,
    //     bool IsReadOnly = false,
    //     bool slupekRuchomy = false,
    //     bool pionPoziom = false)
    // {
    //     public double Value
    //     {
    //         get => GetValue();
    //         set
    //         {
    //             if (!IsReadOnly) SetValue(value);
    //         }
    //     }

    //     public EditableProperty SetObjectName(string newName) => this with { NazwaObiektu = newName };
    // }

    private void SelectNextShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex + 1) % _shapes.Count;
    }

    private void SelectPreviousShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex - 1 + _shapes.Count) % _shapes.Count;
    }

    private async Task FitToCanvas()
    {
        if (_shapes.Count == 0) return;

        if (_shapes == null || _shapes.Count == 0) _shapes = _originalShapes.Select(s => s.Clone()).ToList();

        SkalujIZastosujPrzesuniecie(_shapes, _canvasX, _canvasY);
        await RedrawCanvas();
    }

    private void SkalujIZastosujPrzesuniecie(List<IShapeDC> shapes, double canvasWidth, double canvasHeight)
    {
        double minX = shapes.Min(s => s.GetBoundingBox().X);
        double minY = shapes.Min(s => s.GetBoundingBox().Y);
        double maxX = shapes.Max(s => s.GetBoundingBox().X + s.GetBoundingBox().Width);
        double maxY = shapes.Max(s => s.GetBoundingBox().Y + s.GetBoundingBox().Height);

        double shapesWidth = maxX - minX;
        double shapesHeight = maxY - minY;

        if (shapesWidth == 0 || shapesHeight == 0) return;

        double scaleX = canvasWidth / shapesWidth;
        double scaleY = canvasHeight / shapesHeight;
        double scaleFactor = Math.Min(scaleX, scaleY) * 0.9;

        double scaledWidth = shapesWidth * scaleFactor;
        double scaledHeight = shapesHeight * scaleFactor;
        double offsetX = (canvasWidth - scaledWidth) / 2 - (minX * scaleFactor);
        double offsetY = (canvasHeight - scaledHeight) / 2 - (minY * scaleFactor);

        foreach (var shape in shapes)
        {
            shape.Transform(scaleFactor, offsetX, offsetY);

        }

        _scaleFactor = scaleFactor;

    }

    private async Task PowrotDoGenerowaniaOkna()
    {
        await RysOkna(true);
        ShapeService.Shapes = _shapes; // Przekazanie danych do serwisu
        Navigation.NavigateTo("/Modele-okienne");

        await Task.CompletedTask;
    }

    private async Task RysOkna(bool powrot = false)
    {
        Console.WriteLine($"Sprawdzanie RysOkna -->  Start");

        if (_selectedShapeIndex < 0 || _selectedShapeIndex >= _shapes.Count)
        {
            SelectNextShape();
        }

        if (_selectedShapeIndex < 0 || _selectedShapeIndex >= _shapes.Count) return;

        var closedShapes = _shapes.Where(shape => shape is not XLineShape).ToList();
        var linesToCheck = _shapes.Where(shape => shape is XLineShape).Cast<XLineShape>().ToList();

        RemoveLinesOutsideShapes();

        linesToCheck = _shapes.Where(shape => shape is XLineShape).Cast<XLineShape>().ToList();

        foreach (var line in linesToCheck)
        {
            foreach (var shape in closedShapes)
            {
                var bbox = shape.GetBoundingBox();
                var extendedLine = ExtendLineToBoundingBox(line, bbox);
                _shapes.Remove(line); // Usuń starą linię
                _shapes.Add(extendedLine); // Dodaj nową wydłużoną
            }
        }

        linesToCheck = _shapes.Where(shape => shape is XLineShape).Cast<XLineShape>().ToList();

        foreach (var line in linesToCheck)
        {
            Console.WriteLine($"Sprawdzanie linii ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");

            foreach (var shape in closedShapes)
            {
                if (shape is XCircleShape circle)
                {
                    if (IsLineInsideCircle(line, circle))
                    {
                        Console.WriteLine("Linia przecina okrąg – przycinanie.");

                        ShortenLineInsideCircle(line, circle);
                    }
                }
                else if (shape is XTriangleShape triangle)
                {
                    var vertices = triangle.GetVertices();

                    var edges = triangle.GetEdges();

                    List<XPoint> intersections = GetLinePolygonIntersections(line, vertices);

                    if (intersections.Count >= 2)
                    {
                        Console.WriteLine("Linia przecina trójkąt – przycinanie.");
                        ShortenLineInsidePolygon(line, vertices);
                    }
                }
                else if (shape is XHouseShape house)
                {
                    Console.WriteLine("Linia przecina HouseShape – przycinanie.");

                    var (roofVertices, houseVertices) = house.GetVertices();

                    var edges = house.GetEdges();

                    // Sprawdzamy przecięcia z dachem (tylko jeśli linia przecina skosy)
                    List<XPoint> roofIntersections = GetLinePolygonIntersections(line, roofVertices);
                    if (roofIntersections.Count >= 2)
                    {
                        Console.WriteLine("Przycinanie linii dla dowolnego kształtu.");

                        ShortenLineToShape(line, edges);
                    }

                    var shapeBox = shape.GetBoundingBox();
                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);

                }
                else if (shape is XRoundedTopRectangleShape roundedRect)
                {
                    Console.WriteLine("Linia przecina RoundedTopRectangleShape – przycinanie.");

                    var edges = roundedRect.GetEdges();

                    XPoint arcCenter = new XPoint(roundedRect.X + roundedRect.Width / 2, roundedRect.Y + roundedRect.Radius);
                    ShortenLineInsideEdges(line, edges, arcCenter, roundedRect.Radius);
                }
                else if (shape is XTrapezoidShape trapShepae)
                {
                    var edges = trapShepae.GetEdges(); // To zrobić uniwersalne

                    ShortenLineToShape(line, edges);

                    var shapeBox = shape.GetBoundingBox();
                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);
                }
                else
                {

                    var shapeBox = shape.GetBoundingBox();

                    // var edges = shapeBox.GetEdges(); // To zrobić uniwersalne

                    Console.WriteLine($"Linia sprawdzana z prostokątem: {shapeBox}");
                    ShortenLineInsideShape(line, shapeBox);
                }
            }
        }

        if (powrot) return;

        _scaleFactor = 1;

        await RedrawCanvas();
    }

    private void ShortenLineInsideCircle(XLineShape line, XCircleShape circle)
    {
        List<Point> intersections = new List<Point>();

        // Znajdź przecięcia linii z okręgiem
        FindCircleIntersections(circle, line, ref intersections);

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsideCircle(line.X1, line.Y1, circle))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private List<XPoint> GetLinePolygonIntersections(XLineShape line, List<XPoint> polygonVertices)
    {
        List<XPoint> intersections = new List<XPoint>();
        int count = polygonVertices.Count;

        for (int i = 0; i < count; i++)
        {
            XPoint p1 = polygonVertices[i];
            XPoint p2 = polygonVertices[(i + 1) % count];

            if (FindIntersection(p1.X, p1.Y, p2.X, p2.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        return intersections;
    }

    private bool IsLineInsideTrangle(XLineShape line, List<XPoint> polygonVertices)
    {
        List<XPoint> intersections = GetLinePolygonIntersections(line, polygonVertices);

        return intersections.Count >= 2; // Jeśli są dwa punkty przecięcia, linia przecina trójkąt
    }


    private bool IsLineInsidePolygon(XLineShape line, List<XPoint> polygon)
    {
        // Pobierz kilka dodatkowych punktów na linii i sprawdź, czy wszystkie są wewnątrz
        int numSamples = 5; // Ilość punktów do sprawdzenia na linii
        for (int i = 0; i <= numSamples; i++)
        {
            double t = (double)i / numSamples;
            double px = line.X1 + t * (line.X2 - line.X1);
            double py = line.Y1 + t * (line.Y2 - line.Y1);

            if (!IsPointInsidePolygon(px, py, polygon))
            {
                return false; // Jeśli jakikolwiek punkt linii jest poza kształtem, linia odpada
            }
        }
        return true;
    }

    private bool IsLineInsideCircle(XLineShape line, XCircleShape circle)
    {
        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - circle.X;
        double fy = line.Y1 - circle.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (circle.Radius * circle.Radius);

        double discriminant = b * b - 4 * a * c;
        return discriminant >= 0; // Jeśli Δ > 0, linia przecina okrąg
    }

    private void ShortenLineInsideEdgesHause(XLineShape line, List<(XPoint Start, XPoint End)> edges)
    {
        List<XPoint> intersections = new List<XPoint>();

        foreach (var (start, end) in edges)
        {
            if (FindIntersection(start.X, start.Y, end.X, end.Y, line.X1, line.Y1, line.X2, line.Y2, out double ix, out double iy))
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        Console.WriteLine($"ShortenLineInsideEdgesHause -> intersections.Count: {intersections.Count}");

        if (intersections.Count >= 2)
        {
            Console.WriteLine($"Przycinam linię do dwóch przecięć: ({intersections[0].X}, {intersections[0].Y}) → ({intersections[1].X}, {intersections[1].Y})");
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            // Sprawdzenie, czy linia powinna być ucięta na dole
            double bottomY = edges.Max(e => Math.Max(e.Start.Y, e.End.Y));

            if (line.Y1 > bottomY) // Linia sięga za daleko w dół
            {
                Console.WriteLine($"Przycinam linię do dolnej krawędzi domu: ({intersections[0].X}, {bottomY})");
                line.Y2 = bottomY;
            }
            else
            {
                Console.WriteLine($"Przycinam linię do pierwszego przecięcia: ({intersections[0].X}, {intersections[0].Y})");
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }


    private void ShortenLineInsideEdges(XLineShape line, List<(XPoint Start, XPoint End)> edges, XPoint arcCenter, double arcRadius)
    {
        List<XPoint> intersections = new List<XPoint>();

        // Sprawdzenie przecięć z prostymi krawędziami
        foreach (var edge in edges)
        {
            if (FindIntersection(edge.Start.X, edge.Start.Y, edge.End.X, edge.End.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                if (IsPointOnSegment(edge.Start, edge.End, new XPoint(ix, iy)))
                {
                    intersections.Add(new XPoint(ix, iy));
                }
            }
        }

        // Sprawdzenie przecięć z łukiem
        List<XPoint> arcIntersections = FindCircleLineIntersections(arcCenter, arcRadius, line);
        intersections.AddRange(arcIntersections);

        Console.WriteLine($"Znalezione przecięcia (po filtracji): {intersections.Count}");
        foreach (var p in intersections)
        {
            Console.WriteLine($"Punkt przecięcia: ({p.X}, {p.Y})");
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        if (intersections.Count == 2)
        {
            Console.WriteLine($"Przycinam linię do dwóch przecięć: ({intersections[0].X}, {intersections[0].Y}) → ({intersections[1].X}, {intersections[1].Y})");
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsideEdges(line.X1, line.Y1, edges, arcCenter, arcRadius))
            {
                Console.WriteLine($"Przycinam linię do punktu ({intersections[0].X}, {intersections[0].Y}) na końcu.");
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                Console.WriteLine($"Przycinam linię do punktu ({intersections[0].X}, {intersections[0].Y}) na początku.");
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private void ShortenLineInsideShape(XLineShape line, BoundingBox shapeBox)
    {
        List<Point> intersections = new List<Point>();

        // Sprawdź przecięcia z krawędziami zamkniętego kształtu
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y, shapeBox.X + shapeBox.Width, shapeBox.Y, line, ref intersections); // Góra
        CheckEdgeIntersection(shapeBox.X + shapeBox.Width, shapeBox.Y, shapeBox.X + shapeBox.Width, shapeBox.Y + shapeBox.Height, line, ref intersections); // Prawa
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y + shapeBox.Height, shapeBox.X + shapeBox.Width, shapeBox.Y + shapeBox.Height, line, ref intersections); // Dół
        CheckEdgeIntersection(shapeBox.X, shapeBox.Y, shapeBox.X, shapeBox.Y + shapeBox.Height, line, ref intersections); // Lewa

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (shapeBox.Contains(line.X1, line.Y1))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private void FindCircleIntersections(XCircleShape circle, XLineShape line, ref List<Point> intersections)
    {
        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - circle.X;
        double fy = line.Y1 - circle.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (circle.Radius * circle.Radius);

        double discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return; // Brak przecięć

        discriminant = Math.Sqrt(discriminant);
        double t1 = (-b - discriminant) / (2 * a);
        double t2 = (-b + discriminant) / (2 * a);

        if (t1 >= 0 && t1 <= 1)
            intersections.Add(new Point(line.X1 + t1 * dx, line.Y1 + t1 * dy));

        if (t2 >= 0 && t2 <= 1)
            intersections.Add(new Point(line.X1 + t2 * dx, line.Y1 + t2 * dy));
    }

    private bool IsPointInsideCircle(double x, double y, XCircleShape circle)
    {
        double dx = x - circle.X;
        double dy = y - circle.Y;
        return (dx * dx + dy * dy) <= (circle.Radius * circle.Radius);
    }

    public void ShortenLineToShape(XLineShape line, List<(XPoint Start, XPoint End)> edges)
    {
        List<XPoint> intersections = new List<XPoint>();

        Console.WriteLine($"Sprawdzanie linii ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");

        // 1️⃣ Znajdź wszystkie przecięcia linii z krawędziami domu
        foreach (var (start, end) in edges)
        {
            if (FindIntersection(start.X, start.Y, end.X, end.Y,
                                 line.X1, line.Y1, line.X2, line.Y2,
                                 out double ix, out double iy))
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        // 2️⃣ Usuń duplikaty i posortuj przecięcia względem wysokości (Y)
        intersections = intersections
            .Distinct()
            .OrderBy(p => p.Y) // Sortujemy od góry do dołu
            .ToList();

        Console.WriteLine($"Znalezione przecięcia: {intersections.Count}");

        if (intersections.Count >= 2)
        {
            // 3️⃣ Przycinamy do najwyższego i najniższego przecięcia
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[^1].X; // Ostatni element listy to dolne przecięcie (bottomY)
            line.Y2 = intersections[^1].Y;

            Console.WriteLine($"Linia obcięta do: ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2})");
        }
        else if (intersections.Count == 1)
        {
            List<XPoint> vertices = edges
                .SelectMany(e => new[] { e.Start, e.End })
                .Distinct()
                .ToList();

            if (IsPointInsidePolygon(line.X1, line.Y1, vertices))
            {
                // Jeśli linia zaczyna się wewnątrz kształtu – przycinamy koniec
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
                Console.WriteLine($"Przycinam końcówkę do: ({line.X2}, {line.Y2})");
            }
            else
            {
                // Jeśli linia zaczyna się na zewnątrz – przycinamy początek
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
                Console.WriteLine($"Przycinam początek do: ({line.X1}, {line.Y1})");
            }
        }
        else
        {
            Console.WriteLine("Brak przecięć – linia pozostaje bez zmian.");
        }
    }

    private XLineShape ExtendLineToBoundingBox(XLineShape line, BoundingBox bbox)
    {
        double x1 = line.X1, y1 = line.Y1, x2 = line.X2, y2 = line.Y2;
        double dx = x2 - x1, dy = y2 - y1;

        if (dx == 0)
        {
            return new XLineShape(x1, bbox.Y, x2, bbox.Y + bbox.Height, _scaleFactor, line.NazwaObj, line.RuchomySlupek, line.PionPoziom, line.DualRama);
        }
        if (dy == 0)
        {
            return new XLineShape(bbox.X, y1, bbox.X + bbox.Width, y2, _scaleFactor, line.NazwaObj, line.RuchomySlupek, line.PionPoziom, line.DualRama);
        }

        double leftFactor = (bbox.X - x1) / dx;
        double rightFactor = ((bbox.X + bbox.Width) - x1) / dx;
        double topFactor = (bbox.Y - y1) / dy;
        double bottomFactor = ((bbox.Y + bbox.Height) - y1) / dy;

        double minFactor = Math.Min(leftFactor, Math.Min(rightFactor, Math.Min(topFactor, bottomFactor)));
        double maxFactor = Math.Max(leftFactor, Math.Max(rightFactor, Math.Max(topFactor, bottomFactor)));

        double newX1 = x1 + dx * minFactor;
        double newY1 = y1 + dy * minFactor;
        double newX2 = x1 + dx * maxFactor;
        double newY2 = y1 + dy * maxFactor;

        return new XLineShape(newX1, newY1, newX2, newY2, _scaleFactor, line.NazwaObj, line.RuchomySlupek);
    }

    public void RemoveLinesOutsideShapes()
    {
        Console.WriteLine("Start RemoveLinesOutsideShapes");

        if (_shapes == null || !_shapes.Any())
        {
            Console.WriteLine("Kolekcja _shapes jest pusta!");
            return;
        }

        var linesToCheck = _shapes.OfType<XLineShape>().ToList();

        var shapesWithEdges = _shapes
            .Where(shape => shape is not XLineShape)
            .Select(shape => new
            {
                Shape = shape,
                Edges = GetShapeEdges(shape) ?? new List<(XPoint Start, XPoint End)>()
            })
            .ToList();

        var linesToRemove = new List<XLineShape>();

        foreach (var line in linesToCheck)
        {
            bool isCompletelyOutside = true;

            foreach (var shapeWithEdges in shapesWithEdges)
            {
                if (!shapeWithEdges.Edges.Any()) continue;

                var polygonVertices = shapeWithEdges.Edges
                    .SelectMany(e => new[] { e.Start, e.End })
                    .Distinct()
                    .ToList();

                bool startInside = IsPointInsidePolygon(line.X1, line.Y1, polygonVertices);
                bool endInside = IsPointInsidePolygon(line.X2, line.Y2, polygonVertices);
                bool intersects = DoesLineIntersectPolygon(line, shapeWithEdges.Edges);

                // Jeśli linia jest CAŁKOWICIE wewnątrz lub ją przecina, nie usuwaj
                if (startInside || endInside || intersects)
                {
                    isCompletelyOutside = false;
                    break;
                }
            }

            if (isCompletelyOutside)
            {
                Console.WriteLine($"Linia ({line.X1}, {line.Y1}) → ({line.X2}, {line.Y2}) jest poza wszystkimi kształtami.");
                linesToRemove.Add(line);
            }
        }

        foreach (var line in linesToRemove)
        {
            _shapes.Remove(line);
        }

        Console.WriteLine($"Usunięto {linesToRemove.Count} linii");
    }

    private bool DoesLineIntersectPolygon(XLineShape line, List<(XPoint Start, XPoint End)> edges)
    {
        foreach (var edge in edges)
        {
            if (DoLinesIntersect(line.X1, line.Y1, line.X2, line.Y2,
                                 edge.Start.X, edge.Start.Y, edge.End.X, edge.End.Y))
            {
                return true; // Linia przecina kształt
            }
        }
        return false;
    }

    private bool DoLinesIntersect(double x1, double y1, double x2, double y2,
                              double x3, double y3, double x4, double y4)
    {
        double d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (d == 0) return false; // Linie są równoległe

        double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d;
        double u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / d;

        return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    private List<(XPoint Start, XPoint End)> GetShapeEdges(IShapeDC shape)
    {
        switch (shape)
        {
            case XCircleShape circle:
                return GetApproximateEdges(circle, 32); // Przybliżenie okręgu wielokątem
            case XRectangleShape rect:
                return rect.GetEdges();
            case XTriangleShape triangle:
                return triangle.GetEdges();
            case XTrapezoidShape trapezoid:
                return trapezoid.GetEdges();
            case XHouseShape house:
                var (roofEdges, baseEdges) = house.GetEdgesDel();
                return roofEdges.Concat(baseEdges).ToList();
            case XRoundedTopRectangleShape roundedRect:
                return roundedRect.GetEdges();
            default:
                return shape.GetBoundingBox()?.GetEdges()
                .Select(edge => (new XPoint(edge.Start.X, edge.Start.Y), new XPoint(edge.End.X, edge.End.Y)))
                .ToList()
                ?? new List<(XPoint, XPoint)>();

        }
    }

    private bool IsPointInsideAnyShape(double x, double y, List<object> shapes)
    {
        foreach (var shape in shapes)
        {
            if (shape is XCircleShape circle && IsPointInsideCircle(x, y, circle))
                return true;

            if (shape is XTriangleShape triangle && IsPointInsidePolygon(x, y, triangle.GetVertices()))
                return true;

            if (shape is XSquareShape square && IsPointInsideRectangle(x, y, square.ToRectangleShape()))
                return true;

            if (shape is XRectangleShape rectangle && IsPointInsideRectangle(x, y, rectangle.ToRectangleShape()))
                return true;

            if (shape is XTrapezoidShape trapezoid && IsPointInsidePolygon(x, y, trapezoid.GetVertices()))
                return true;

            if (shape is XHouseShape house)
            {
                var (roof, walls) = house.GetVertices();
                if (IsPointInsidePolygon(x, y, roof) || IsPointInsidePolygon(x, y, walls))
                    return true;
            }

            if (shape is XRoundedTopRectangleShape roundedRect && IsPointInsideRoundedRectangle(x, y, roundedRect))
                return true;
        }

        return false; // Jeśli żaden kształt nie zawiera punktu
    }


    private void ShortenLineInsidePolygon(XLineShape line, List<XPoint> polygonVertices)
    {
        List<XPoint> intersections = new List<XPoint>();

        int count = polygonVertices.Count;
        for (int i = 0; i < count; i++)
        {
            XPoint p1 = polygonVertices[i];
            XPoint p2 = polygonVertices[(i + 1) % count];

            if (FindIntersection(p1.X, p1.Y, p2.X, p2.Y, line.X1, line.Y1, line.X2, line.Y2, out double ix, out double iy))
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        intersections = intersections.Distinct()
            .OrderBy(p => Distance(line.X1, line.Y1, p.X, p.Y))
            .ToList();

        Console.WriteLine($"ShortenLineInsidePolygon -> intersections.Count: {intersections.Count}");

        if (intersections.Count == 2)
        {
            line.X1 = intersections[0].X;
            line.Y1 = intersections[0].Y;
            line.X2 = intersections[1].X;
            line.Y2 = intersections[1].Y;
        }
        else if (intersections.Count == 1)
        {
            if (IsPointInsidePolygon(line.X1, line.Y1, polygonVertices))
            {
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
            else
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
            }
        }
    }

    private List<XPoint> FindCircleLineIntersections(XPoint center, double radius, XLineShape line)
    {
        List<XPoint> intersections = new List<XPoint>();

        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;
        double fx = line.X1 - center.X;
        double fy = line.Y1 - center.Y;

        double a = dx * dx + dy * dy;
        double b = 2 * (fx * dx + fy * dy);
        double c = (fx * fx + fy * fy) - (radius * radius);

        double discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return intersections; // Brak przecięć

        discriminant = Math.Sqrt(discriminant);
        double t1 = (-b - discriminant) / (2 * a);
        double t2 = (-b + discriminant) / (2 * a);

        if (t1 >= 0 && t1 <= 1)
        {
            double ix = line.X1 + t1 * dx;
            double iy = line.Y1 + t1 * dy;
            if (iy <= center.Y) // Punkt musi być wewnątrz górnego łuku
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        if (t2 >= 0 && t2 <= 1)
        {
            double ix = line.X1 + t2 * dx;
            double iy = line.Y1 + t2 * dy;
            if (iy <= center.Y) // Punkt musi być wewnątrz górnego łuku
            {
                intersections.Add(new XPoint(ix, iy));
            }
        }

        return intersections;
    }

    private bool IsPointInsideEdges(double x, double y, List<(XPoint Start, XPoint End)> edges, XPoint? arcCenter = null, double arcRadius = 0)
    {
        int intersections = 0;

        foreach (var edge in edges)
        {
            double x1 = edge.Start.X, y1 = edge.Start.Y;
            double x2 = edge.End.X, y2 = edge.End.Y;

            // Sprawdzamy, czy pozioma linia przecina dany odcinek
            if ((y1 > y) != (y2 > y))
            {
                double intersectX = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
                if (intersectX > x)
                {
                    intersections++;
                }
            }
        }

        // Jeśli mamy łuk – sprawdzamy, czy punkt jest wewnątrz okręgu
        if (arcCenter.HasValue)
        {
            double dx = x - arcCenter.Value.X;
            double dy = y - arcCenter.Value.Y;
            double distanceSquared = dx * dx + dy * dy;

            if (distanceSquared <= arcRadius * arcRadius)
            {
                return true; // Punkt jest wewnątrz łuku
            }
        }

        return (intersections % 2) == 1; // Jeśli liczba przecięć jest nieparzysta, punkt jest wewnątrz
    }

    private bool IsPointInsideRoundedRectangle(double x, double y, XRoundedTopRectangleShape rect)
    {
        return IsPointInsideRoundedRectangle(x, y, new XRoundedRectangleShape(rect.X, rect.Y, rect.Width, rect.Height, rect.Radius, _scaleFactor));
    }

    private bool IsPointInsideRoundedRectangle(double x, double y, XRoundedRectangleShape rect)
    {
        // Pobieramy wymiary prostokąta i promień zaokrąglenia
        double left = rect.X;
        double top = rect.Y;
        double right = rect.X + rect.Width;
        double bottom = rect.Y + rect.Height;
        double radius = rect.Radius;

        // Sprawdzenie, czy punkt znajduje się w prostokątnej części (bez zaokrągleń)
        if (x >= left + radius && x <= right - radius &&
            y >= top && y <= bottom)
        {
            return true;
        }

        if (x >= left && x <= right &&
            y >= top + radius && y <= bottom - radius)
        {
            return true;
        }

        // Sprawdzenie, czy punkt znajduje się w jednym z czterech zaokrąglonych rogów
        return IsPointInsideCircle(x, y, left + radius, top + radius, radius) ||  // Lewy górny róg
               IsPointInsideCircle(x, y, right - radius, top + radius, radius) || // Prawy górny róg
               IsPointInsideCircle(x, y, left + radius, bottom - radius, radius) || // Lewy dolny róg
               IsPointInsideCircle(x, y, right - radius, bottom - radius, radius);  // Prawy dolny róg
    }

    // Pomocnicza funkcja sprawdzająca, czy punkt znajduje się wewnątrz okręgu
    private bool IsPointInsideCircle(double px, double py, double cx, double cy, double radius)
    {
        return Math.Pow(px - cx, 2) + Math.Pow(py - cy, 2) <= Math.Pow(radius, 2);
    }


    private bool IsPointInsideRectangle(double x, double y, XRectangleShape rectangle)
    {
        var bbox = rectangle.GetBoundingBox(); // Powinno zwracać strukturalne dane o prostokącie
        return x >= bbox.X && x <= (bbox.X + bbox.Width) &&
               y >= bbox.Y && y <= (bbox.Y + bbox.Height);
    }

    private bool IsPointInsidePolygon(double x, double y, List<XPoint> polygonVertices)
    {
        int count = polygonVertices.Count;
        bool inside = false;

        for (int i = 0, j = count - 1; i < count; j = i++)
        {
            double xi = polygonVertices[i].X, yi = polygonVertices[i].Y;
            double xj = polygonVertices[j].X, yj = polygonVertices[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private bool IsPointInsidePolygonSkos(double x, double y, List<(Point Start, Point End)> edges)
    {
        // Konwersja krawędzi na listę unikalnych wierzchołków
        List<Point> polygonVertices = edges
            .Select(e => e.Start) // Pobieramy tylko początkowe punkty krawędzi
            .Distinct()
            .ToList();

        int count = polygonVertices.Count;
        bool inside = false;

        for (int i = 0, j = count - 1; i < count; j = i++)
        {
            double xi = polygonVertices[i].X, yi = polygonVertices[i].Y;
            double xj = polygonVertices[j].X, yj = polygonVertices[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect)
                inside = !inside;
        }

        return inside;
    }


    private void CheckEdgeIntersection(double edgeX1, double edgeY1, double edgeX2, double edgeY2,
                                    XLineShape line, ref List<Point> intersections)
    {
        if (FindIntersection(edgeX1, edgeY1, edgeX2, edgeY2,
                             line.X1, line.Y1, line.X2, line.Y2,
                             out double intersectX, out double intersectY))
        {
            var newPoint = new Point(intersectX, intersectY);
            if (!intersections.Any(p => Math.Abs(p.X - newPoint.X) < 0.001 && Math.Abs(p.Y - newPoint.Y) < 0.001))
            {
                intersections.Add(newPoint);
            }
        }
    }

    private bool FindIntersection(double aX1, double aY1, double aX2, double aY2,
                               double bX1, double bY1, double bX2, double bY2,
                               out double x, out double y)
    {
        x = 0;
        y = 0;

        double d = (aX1 - aX2) * (bY1 - bY2) - (aY1 - aY2) * (bX1 - bX2);
        if (Math.Abs(d) < 0.001) return false; // Linie równoległe

        double t = ((aX1 - bX1) * (bY1 - bY2) - (aY1 - bY1) * (bX1 - bX2)) / d;
        double u = -((aX1 - aX2) * (aY1 - bY1) - (aY1 - aY2) * (aX1 - bX1)) / d;

        if (t < 0 || t > 1 || u < 0 || u > 1) return false; // Punkt przecięcia poza odcinkami

        x = aX1 + t * (aX2 - aX1);
        y = aY1 + t * (aY2 - aY1);

        return true;
    }

    private bool IsPointOnSegment(XPoint start, XPoint end, XPoint point)
    {
        double crossProduct = (point.Y - start.Y) * (end.X - start.X) - (point.X - start.X) * (end.Y - start.Y);
        if (Math.Abs(crossProduct) > 0.001) return false; // Punkt nie leży dokładnie na linii

        double dotProduct = (point.X - start.X) * (end.X - start.X) + (point.Y - start.Y) * (end.Y - start.Y);
        if (dotProduct < 0) return false; // Punkt leży przed startem

        double squaredLength = (end.X - start.X) * (end.X - start.X) + (end.Y - start.Y) * (end.Y - start.Y);
        if (dotProduct > squaredLength) return false; // Punkt leży za końcem

        return true; // Punkt leży na odcinku
    }

    private double Distance(double x1, double y1, double x2, double y2)
    {
        return Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));
    }

    public struct Point
    {
        public double X { get; set; }
        public double Y { get; set; }
        public Point(double x, double y) { X = x; Y = y; }
    }

}