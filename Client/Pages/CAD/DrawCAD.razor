@page "/DrawCAD"
@inject IJSRuntime JSRuntime
@using Blazor.Extensions.Canvas.Canvas2D
@implements IDisposable

<style>
    .toolbar {
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px;
    background: #f4f4f4;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .tool-button {
    background: #ffffff;
    border: 2px solid #ddd;
    padding: 10px;
    cursor: pointer;
    border-radius: 6px;
    transition: 0.3s;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .tool-button:hover {
    background: #e0e0e0;
    }

    .tool-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
    }

    .canvas-container {
    position: relative;
    border: 3px solid #000;
    width: @(_canvasX + "px");
    height: @(_canvasY + "px");
    margin: 20px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;
    overflow: auto;
    }

    .tool-icon {
    width: 24px;
    height: 24px;
    fill: black;
    }

    .tool-button.active .tool-icon {
    fill: white;
    }

    .property-panel {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    }

    .property-row {
    display: flex;
    margin-bottom: 8px;
    align-items: center;
    }

    .property-label {
    width: 100px;
    font-weight: bold;
    }

    .property-input {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 180px;
    }
</style>
<script>
    function initCanvasEvents(container, dotNetHelper) {
    const canvas = container.querySelector('canvas');

    // Nasłuchuj zdarzenia na oknie zamiast na canvasie
    window.addEventListener('keydown', (e) => {
    if (e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', true);
    });
    window.addEventListener('keyup', (e) => {
    if (!e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', false);
    });

    // Reszta handlerów bez zmian
    const handler = (e) => {
    const rect = canvas.getBoundingClientRect();
    return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
    };
    };

    canvas.addEventListener('mousedown', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseDown', x, y);
    });

    canvas.addEventListener('mousemove', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseMove', x, y);
    });

    canvas.addEventListener('mouseup', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseUp', x, y);
    });
    }
</script>


<div class="toolbar">
    <button class="tool-button @(_selectedTool == "line" ? "active" : "")"
    @onclick='() => SetTool("line")'>
        @SvgLine()
    </button>

    <button class="tool-button @(_selectedTool == "line_hv" ? "active" : "")"
    @onclick='() => SetTool("line_hv")'>
        @SvgLineHV()
    </button>

    <button class="tool-button @(_selectedTool == "triangle" ? "active" : "")"
    @onclick='() => SetTool("triangle")'>
        @SvgTriangle()
    </button>

    <button class="tool-button @(_selectedTool == "circle" ? "active" : "")"
    @onclick='() => SetTool("circle")'>
        @SvgCircle()
    </button>

    <button class="tool-button @(_selectedTool == "square" ? "active" : "")"
    @onclick='() => SetTool("square")'>
        @SvgSquare()
    </button>

    <button class="tool-button @(_selectedTool == "rectangle" ? "active" : "")"
    @onclick='() => SetTool("rectangle")'>
        @SvgRectangle()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoid" ? "active" : "")"
    @onclick='() => SetTool("trapezoid")'>
        @SvgTrapezoid()
    </button>

    <button class="tool-button @(_selectedTool == "rounded_rect" ? "active" : "")"
    @onclick='() => SetTool("rounded_rect")'>
        @SvgRoundedRect()
    </button>
</div>

<div class="canvas-container" @ref="_container">
    <BECanvas Width="@_canvasX" Height="@_canvasY" @ref="_canvas"></BECanvas>
</div>
@if (_selectedShape != null)
{
    <div class="property-panel">
        <h3>Właściwości kształtu</h3>

        @foreach (var prop in _selectedShape.GetEditableProperties())
        {
            <div class="property-row">
                <span class="property-label">@prop.Label</span>
                <input class="property-input" type="number"
                @bind="prop.Value"
                @bind:event="onchange"
                @bind:after="async () => await RedrawCanvas()" />

            </div>
        }
    </div>
}

@code {
    private Canvas2DContext? _ctx;
    private BECanvasComponent? _canvas;
    private ElementReference _container;
    private DotNetObjectReference<GEORGE.Client.Pages.CAD.DrawCAD>? _dotNetHelper;
    private bool _isDrawing = false;
    private double _startX, _startY, _currentX, _currentY;
    private string _selectedTool = "line";
    private List<IShape> _shapes = new List<IShape>();

    // Dodaj nowe pole dla wymuszenia kierunku
    private bool _forceHV = false;

    private long _canvasX = 900;
    private long _canvasY = 600;

    private IShape? _selectedShape;

    private void SetTool(string tool) => _selectedTool = tool;

    [JSInvokable]
    public void SetForceHV(bool state) => _forceHV = state;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _ctx = await _canvas.CreateCanvas2DAsync();
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initCanvasEvents", _container, _dotNetHelper);
            await ClearCanvas();
        }
    }

    private RenderFragment SvgLine() => builder =>
       {
           builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
       };

    private RenderFragment SvgLineHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='black' stroke-width='2'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
    };

    private RenderFragment SvgTriangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 4,20 20,20'
                     stroke='black'
                     stroke-width='2'
                     fill='none'/>
        </svg>");
    };

    private RenderFragment SvgCircle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <circle cx='12' cy='12' r='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgSquare() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='6' y='6' width='12' height='12' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRectangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='4' y='8' width='16' height='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoid() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='5' y='7' width='14' height='10' rx='3' ry='3' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };


    [JSInvokable]
    public async Task HandleMouseDown(double x, double y)
    {
        _isDrawing = true;
        _startX = x;
        _startY = y;
        _currentX = x;
        _currentY = y;
        await Task.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleMouseMove(double x, double y)
    {
        if (!_isDrawing) return;

        // Rozszerzona logika dla wymuszonego kierunku
        if (_selectedTool == "line_hv" || _forceHV)
        {
            const double sensitivity = 5;
            var dx = Math.Abs(x - _startX);
            var dy = Math.Abs(y - _startY);

            if (dx < sensitivity && dy < sensitivity) return;

            var isHorizontal = dx > dy;
            _currentX = isHorizontal ? x : _startX;
            _currentY = isHorizontal ? _startY : y;
        }
        else
        {
            _currentX = x;
            _currentY = y;
        }

        await RedrawCanvas();
    }

    [JSInvokable]
    public async Task HandleMouseUp(double x, double y)
    {
        if (!_isDrawing) return;
        _isDrawing = false;

        IShape newShape = _selectedTool switch
        {
            "line" => new LineShape(_startX, _startY, _currentX, _currentY),
            "line_hv" => new LineShape(_startX, _startY, _currentX, _currentY),
            "circle" => new CircleShape(_startX, _startY, CalculateRadius()),
            "triangle" => new TriangleShape(_startX, _startY, _currentX, _currentY),
            "square" => new SquareShape(_startX, _startY, Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY))),
            "rectangle" => new RectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY),
            "trapezoid" => new TrapezoidShape(_startX, _startY, _currentX, _currentY, 0.5),
            "rounded_rect" => new RoundedRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, 20),
            _ => throw new NotImplementedException()
        };

        _shapes.Add(newShape);
        _selectedShape = newShape;
        await RedrawCanvas();
    }

    private double CalculateRadius()
    {
        return Math.Sqrt(Math.Pow(_currentX - _startX, 2) + Math.Pow(_currentY - _startY, 2));
    }


    private async Task RedrawCanvas()
    {
        if (_ctx == null) return;

        await ClearCanvas();

        // Rysuj wszystkie zapisane kształty
        foreach (var shape in _shapes)
        {
            await shape.Draw(_ctx);
        }

        // Rysuj podgląd aktualnie rysowanego kształtu
        if (_isDrawing)
        {
            await _ctx.SetStrokeStyleAsync("rgba(0,0,0,0.5)");
            await _ctx.SetLineWidthAsync(2);

            switch (_selectedTool)
            {
                case "line":
                case "line_hv":
                    await DrawPreviewLine();
                    break;
                case "circle":
                    await DrawPreviewCircle();
                    break;
                case "square":
                    await DrawPreviewSquare();
                    break;
                case "rectangle":
                    await DrawPreviewRectangle();
                    break;
                case "trapezoid":
                    await DrawPreviewTrapezoid();
                    break;
                case "triangle":
                    await DrawPreviewTriangle();
                    break;
                case "rounded_rect":
                    await DrawPreviewRoundedRect();
                    break;
            }
        }
    }

    private async Task DrawPreviewSquare()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var size = Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY));
        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, size, size);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRectangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, _currentX - _startX, _currentY - _startY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTriangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        // Oblicz środkowy punkt podstawy
        var baseCenterX = (_startX + _currentX) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(baseCenterX, _startY);       // Górny wierzchołek
        await _ctx.LineToAsync(_currentX, _currentY);      // Prawy dolny wierzchołek
        await _ctx.LineToAsync(_startX, _currentY);        // Lewy dolny wierzchołek
        await _ctx.ClosePathAsync();                       // Automatycznie łączy z pierwszym punktem

        await _ctx.StrokeAsync();

    }

    private async Task DrawPreviewTrapezoid()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var radius = 20; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewLine()
    {
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewCircle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var radius = CalculateRadius();
        await _ctx.BeginPathAsync();
        await _ctx.ArcAsync(_startX, _startY, radius, 0, 2 * Math.PI);
        await _ctx.StrokeAsync();
    }


    private async Task ClearCanvas()
    {
        await _ctx.SetFillStyleAsync("white");
        await _ctx.FillRectAsync(0, 0, _canvasX, _canvasY);
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }

    // 🎨 INTERFEJS KSZTAŁTÓW
    private interface IShape
    {
        Task Draw(Canvas2DContext ctx);
        List<EditableProperty> GetEditableProperties();
    }

    // 🖌️ KLASA LINII
    private class LineShape : IShape
    {
        public double X1 { get; set; }
        public double Y1 { get; set; }
        public double X2 { get; set; }
        public double Y2 { get; set; }

        public LineShape(double x1, double y1, double x2, double y2)
        {
            X1 = x1;
            Y1 = y1;
            X2 = x2;
            Y2 = y2;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X1, Y1);
            await ctx.LineToAsync(X2, Y2);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X1", () => X1, v => X1 = v),
            new EditableProperty("Y1", () => Y1, v => Y1 = v),
            new EditableProperty("X2", () => X2, v => X2 = v),
            new EditableProperty("Y2", () => Y2, v => Y2 = v)
        };
    }

    // 🟥 Klasa prostokąta (Rectangle)
    private class RectangleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }

        public RectangleShape(double x, double y, double width, double height)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Width, Height);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v),
        new EditableProperty("Y", () => Y, v => Y = v),
        new EditableProperty("Szerokość", () => Width, v => Width = v),
        new EditableProperty("Wysokość", () => Height, v => Height = v)
    };
    }

    // /\ Klasa prostokąta (TriangleShape)
    private class TriangleShape : IShape
    {
        // Współrzędne w przestrzeni "world" (bez transformacji)
        public double BaseX1 { get; set; }
        public double BaseY { get; set; }
        public double BaseWidth { get; set; }
        public double Height { get; set; }

        public TriangleShape(double startX, double startY, double endX, double endY)
        {
            // Konwersja do współrzędnych bazowych
            BaseX1 = Math.Min(startX, endX);
            BaseY = Math.Max(startY, endY);
            BaseWidth = Math.Abs(endX - startX);
            Height = Math.Abs(startY - endY);
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            var apexX = BaseX1 + BaseWidth / 2;
            var apexY = BaseY - Height;
            var baseX2 = BaseX1 + BaseWidth;

            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(apexX, apexY);
            await ctx.LineToAsync(baseX2, BaseY);
            await ctx.LineToAsync(BaseX1, BaseY);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("Lewa podstawa X", () => BaseX1, v => BaseX1 = v),
        new EditableProperty("Pozycja Y podstawy", () => BaseY, v => BaseY = v),
        new EditableProperty("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v),
        new EditableProperty("Wysokość", () => Height, v => Height = v)
    };
    }

    // ⬛ Klasa kwadratu (Square)
    private class SquareShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Size { get; set; }

        public SquareShape(double x, double y, double size)
        {
            X = x;
            Y = y;
            Size = size;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Size, Size);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v),
        new EditableProperty("Y", () => Y, v => Y = v),
        new EditableProperty("Rozmiar", () => Size, v => Size = v)
    };
    }

    private class RoundedRectangleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }

        public RoundedRectangleShape(double x, double y, double width, double height, double radius)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X + Radius, Y);
            await ctx.LineToAsync(X + Width - Radius, Y);
            await ctx.ArcToAsync(X + Width, Y, X + Width, Y + Radius, Radius);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X, Y + Height);
            await ctx.LineToAsync(X, Y + Radius);
            await ctx.ArcToAsync(X, Y, X + Radius, Y, Radius);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new("X", () => X, v => X = v),
            new("Y", () => Y, v => Y = v),
            new("Szerokość", () => Width, v => Width = v),
            new("Wysokość", () => Height, v => Height = v),
            new("Promień", () => Radius, v => Radius = v)
        };
    }

    private class TrapezoidShape : IShape
    {
        public double BaseWidth { get; set; }
        public double TopWidth { get; set; }
        public double Height { get; set; }
        public double X { get; set; }
        public double Y { get; set; }

        // Konstruktor przyjmujący współrzędne i współczynnik szerokości góry
        public TrapezoidShape(double startX, double startY, double endX, double endY, double topWidthFactor)
        {
            X = Math.Min(startX, endX);           // Ustal minimalne X (lewy brzeg)
            Y = Math.Min(startY, endY);           // Ustal minimalne Y (dolny brzeg)
            BaseWidth = Math.Abs(endX - startX);  // Oblicz szerokość podstawy trapezu
            Height = Math.Abs(endY - startY);     // Oblicz wysokość trapezu
            TopWidth = Math.Min(BaseWidth, BaseWidth * topWidthFactor);  // Oblicz szerokość góry trapezu
        }

        // Metoda rysująca trapez
        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            // Oblicz pozycje wierzchołków trapezu
            var baseLeft = X;
            var baseRight = X + BaseWidth;
            var topLeft = X + (BaseWidth - TopWidth) / 2;   // Oblicz pozycję lewej strony góry
            var topRight = topLeft + TopWidth;               // Oblicz pozycję prawej strony góry
            var verticalY = Y + Height;                      // Oblicz wysokość (dolna krawędź)

            // Rysowanie trapezu za pomocą punktów
            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(topLeft, Y);            // Lewy górny
            await ctx.LineToAsync(topRight, Y);           // Prawy górny
            await ctx.LineToAsync(baseRight, verticalY);  // Prawy dolny
            await ctx.LineToAsync(baseLeft, verticalY);   // Lewy dolny
            await ctx.ClosePathAsync();

            await ctx.StrokeAsync();
        }

        // Właściwości edytowalne
        public List<EditableProperty> GetEditableProperties() => new()
    {
        new("Pozycja X", () => X, v => X = v),
        new("Pozycja Y", () => Y, v => Y = v),
        new("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v),
        new("Szerokość góry", () => TopWidth, v => TopWidth = Math.Clamp(v, 10, BaseWidth - 10)),
        new("Wysokość", () => Height, v => Height = v)
    };
    }


    // 🟢 KLASA KOŁA
    private class CircleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Radius { get; set; }

        public CircleShape(double x, double y, double radius)
        {
            X = x;
            Y = y;
            Radius = radius;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync(2);

            await ctx.BeginPathAsync();
            await ctx.ArcAsync(X, Y, Radius, 0, 2 * Math.PI);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X", () => X, v => X = v),
            new EditableProperty("Y", () => Y, v => Y = v),
            new EditableProperty("Promień", () => Radius, v => Radius = v)
        };
    }

    // 🔧 KLASY EDYTOWALNYCH WŁAŚCIWOŚCI
    public record EditableProperty(string Label, Func<double> GetValue, Action<double> SetValue)
    {
        public double Value
        {
            get => GetValue();
            set => SetValue(value);
        }
    }
}
