@page "/DrawCAD"
@inject IJSRuntime JSRuntime
@using Blazor.Extensions.Canvas.Canvas2D
@implements IDisposable

<style>
    .toolbar {
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 10px;
    background: #f4f4f4;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .tool-button {
    background: #ffffff;
    border: 2px solid #ddd;
    padding: 10px;
    cursor: pointer;
    border-radius: 6px;
    transition: 0.3s;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    }

    .tool-button:hover {
    background: #e0e0e0;
    }

    .tool-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
    }

    .canvas-container {
    position: relative;
    border: 3px solid #001;
    width: @(_canvasX + "px");
    height: @(_canvasY + "px");
    margin: 20px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #fff;
    overflow: auto;
    }


    canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
    background-color: transparent;
    }


    .tool-icon {
    width: 24px;
    height: 24px;
    fill: black;
    }

    .tool-button.active .tool-icon {
    fill: white;
    }

    .property-panel {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    }

    .property-row {
    display: flex;
    margin-bottom: 8px;
    align-items: center;
    }

    .property-label {
    width: 100px;
    font-weight: bold;
    }

    .property-input {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 3px;
    width: 180px;
    }

    .zoom-controls {
    position: absolute;
    top: 170px; /* Ustawienie 10px od góry */
    right: 10px; /* Ustawienie 10px od prawej */
    display: flex;
    gap: 10px; /* Odstęp między przyciskami */
    z-index: 1000; /* Upewnia się, że są na wierzchu */
    }
</style>

<script>
    function initCanvasEvents(container, dotNetHelper) {
    const canvas = container.querySelector('canvas');

    // Nasłuchuj zdarzenia na oknie zamiast na canvasie
    window.addEventListener('keydown', (e) => {
    if (e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', true);
    });
    window.addEventListener('keyup', (e) => {
    if (!e.shiftKey) dotNetHelper.invokeMethodAsync('SetForceHV', false);
    });

    // Reszta handlerów bez zmian
    const handler = (e) => {
    const rect = canvas.getBoundingClientRect();
    return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
    };
    };

    canvas.addEventListener('mousedown', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseDown', x, y);
    });

    canvas.addEventListener('mousemove', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseMove', x, y);
    });

    canvas.addEventListener('mouseup', async (e) => {
    const {x, y} = handler(e);
    await dotNetHelper.invokeMethodAsync('HandleMouseUp', x, y);
    });
    }
</script>

<!-- Kontener na przyciski -->
<div class="zoom-controls">
    <button @onclick="() => ResizeAllShapes(1.1)" class="btn-zoom">➕</button>
    <button @onclick="() => ResizeAllShapes(0.9)" class="btn-zoom">➖</button>
    <button @onclick="() => FitToCanvas()" class="btn-zoom">🔄 Dopasuj</button>
    <button @onclick="RysOkna" class="btn-window">Generuj OKNO</button>

</div>

<div class="toolbar">
    <button class="tool-button @(_selectedTool == "line" ? "active" : "")"
    @onclick='() => SetTool("line")'>
        @SvgLine()
    </button>

    <button class="tool-button @(_selectedTool == "line_hv" ? "active" : "")"
    @onclick='() => SetTool("line_hv")'>
        @SvgLineHV()
    </button>

    <button class="tool-button @(_selectedTool == "triangle" ? "active" : "")"
    @onclick='() => SetTool("triangle")'>
        @SvgTriangle()
    </button>

    <button class="tool-button @(_selectedTool == "circle" ? "active" : "")"
    @onclick='() => SetTool("circle")'>
        @SvgCircle()
    </button>

    <button class="tool-button @(_selectedTool == "square" ? "active" : "")"
    @onclick='() => SetTool("square")'>
        @SvgSquare()
    </button>

    <button class="tool-button @(_selectedTool == "rectangle" ? "active" : "")"
    @onclick='() => SetTool("rectangle")'>
        @SvgRectangle()
    </button>

    <button class="tool-button @(_selectedTool == "trapezoid" ? "active" : "")"
    @onclick='() => SetTool("trapezoid")'>
        @SvgTrapezoid()
    </button>

    <button class="tool-button @(_selectedTool == "rounded_rect" ? "active" : "")"
    @onclick='() => SetTool("rounded_rect")'>
        @SvgRoundedRect()
    </button>
</div>

<div class="canvas-container" @ref="_container">
    <BECanvas Width="@_canvasX" Height="@_canvasY" @ref="_canvas"></BECanvas>
</div>

@if (_shapes.Count > 0)
{
    <div class="property-panel">
        <h3>Właściwości kształtu</h3>

        @if (_selectedShapeIndex >= 0)
        {
            @foreach (var prop in _shapes[_selectedShapeIndex].GetEditableProperties())
            {
                <div class="property-row">
                    <span class="property-label">@prop.Label</span>
                    @if (!prop.IsReadOnly)
                    {
                        <input class="property-input" type="number"
                               @bind="prop.Value"
                               @bind:event="onchange"
                               @bind:after="async () => await RedrawCanvas()" />
                    }
                    else
                    {
                        <span class="property-value">@prop.Value</span>
                    }
                </div>
            }
        }

        <button @onclick="SelectPreviousShape">Poprzedni obiekt</button>
        <button @onclick="SelectNextShape">Następny obiekt</button>
    </div>
}

@code {
    private Canvas2DContext? _ctx;
    private BECanvasComponent? _canvas;
    private ElementReference _container;
    private DotNetObjectReference<GEORGE.Client.Pages.CAD.DrawCAD>? _dotNetHelper;
    private bool _isDrawing = false;
    private double _startX, _startY, _currentX, _currentY;
    private string _selectedTool = "line";
    private List<IShape> _shapes = new List<IShape>();

    // Dodaj nowe pole dla wymuszenia kierunku
    private bool _forceHV = false;

    private long _canvasX = 900;
    private long _canvasY = 600;

    private int _selectedShapeIndex = -1; // Przechowuje indeks aktualnie edytowanego kształtu

    private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

    public record BoundingBox(double X, double Y, double Width, double Height);

    private void SetTool(string tool) => _selectedTool = tool;

    [JSInvokable]
    public void SetForceHV(bool state) => _forceHV = state;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _ctx = await _canvas.CreateCanvas2DAsync();
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initCanvasEvents", _container, _dotNetHelper);
            await ClearCanvas();
        }
    }

    private RenderFragment SvgLine() => builder =>
       {
           builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
       };

    private RenderFragment SvgLineHV() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <line x1='12' y1='4' x2='12' y2='20' stroke='black' stroke-width='2'/>
            <line x1='4' y1='12' x2='20' y2='12' stroke='black' stroke-width='2'/>
        </svg>");
    };

    private RenderFragment SvgTriangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='12,4 4,20 20,20'
                     stroke='black'
                     stroke-width='2'
                     fill='none'/>
        </svg>");
    };

    private RenderFragment SvgCircle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <circle cx='12' cy='12' r='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgSquare() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='6' y='6' width='12' height='12' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRectangle() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='4' y='8' width='16' height='8' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgTrapezoid() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <polygon points='6,8 18,8 20,16 4,16' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };

    private RenderFragment SvgRoundedRect() => builder =>
    {
        builder.AddMarkupContent(0, @"
        <svg class='tool-icon' viewBox='0 0 24 24'>
            <rect x='5' y='7' width='14' height='10' rx='3' ry='3' stroke='black' stroke-width='2' fill='none'/>
        </svg>");
    };


    [JSInvokable]
    public async Task HandleMouseDown(double x, double y)
    {
        _isDrawing = true;
        _startX = x;
        _startY = y;
        _currentX = x;
        _currentY = y;
        await Task.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleMouseMove(double x, double y)
    {
        if (!_isDrawing) return;

        // Rozszerzona logika dla wymuszonego kierunku
        if (_selectedTool == "line_hv" || _forceHV)
        {
            const double sensitivity = 5;
            var dx = Math.Abs(x - _startX);
            var dy = Math.Abs(y - _startY);

            if (dx < sensitivity && dy < sensitivity) return;

            var isHorizontal = dx > dy;
            _currentX = isHorizontal ? x : _startX;
            _currentY = isHorizontal ? _startY : y;
        }
        else
        {
            _currentX = x;
            _currentY = y;
        }

        await RedrawCanvas();
    }

    [JSInvokable]
    public async Task HandleMouseUp(double x, double y)
    {
        if (!_isDrawing) return;
        _isDrawing = false;

        IShape newShape = _selectedTool switch
        {
            "line" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor),
            "line_hv" => new LineShape(_startX, _startY, _currentX, _currentY, _scaleFactor),
            "circle" => new CircleShape(_startX, _startY, CalculateRadius(), _scaleFactor),
            "triangle" => new TriangleShape(_startX, _startY, _currentX, _currentY, _scaleFactor),
            "square" => new SquareShape(_startX, _startY, Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY)), _scaleFactor),
            "rectangle" => new RectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, _scaleFactor),
            "trapezoid" => new TrapezoidShape(_startX, _startY, _currentX, _currentY, 0.5, _scaleFactor),
            "rounded_rect" => new RoundedRectangleShape(_startX, _startY, _currentX - _startX, _currentY - _startY, 20, _scaleFactor),
            _ => throw new NotImplementedException()
        };

        _shapes.Add(newShape);

        await RedrawCanvas();
    }

    private double CalculateRadius()
    {
        return Math.Sqrt(Math.Pow(_currentX - _startX, 2) + Math.Pow(_currentY - _startY, 2));
    }

    private async Task RedrawCanvas()
    {
        if (_ctx == null) return;

        await ClearCanvas();

        await _ctx.SaveAsync();
        await _ctx.ScaleAsync(_scaleFactor, _scaleFactor); // Skalowanie dla całego rysunku

        foreach (var shape in _shapes)
        {
            await shape.Draw(_ctx);
        }

        await _ctx.RestoreAsync(); // Przywrócenie oryginalnej skali

        // Rysuj podgląd aktualnie rysowanego kształtu
        if (_isDrawing)
        {
            await _ctx.SetStrokeStyleAsync("rgba(0,0,0,0.5)");
            await _ctx.SetLineWidthAsync(2);

            switch (_selectedTool)
            {
                case "line":
                case "line_hv":
                    await DrawPreviewLine();
                    break;
                case "circle":
                    await DrawPreviewCircle();
                    break;
                case "square":
                    await DrawPreviewSquare();
                    break;
                case "rectangle":
                    await DrawPreviewRectangle();
                    break;
                case "trapezoid":
                    await DrawPreviewTrapezoid();
                    break;
                case "triangle":
                    await DrawPreviewTriangle();
                    break;
                case "rounded_rect":
                    await DrawPreviewRoundedRect();
                    break;
            }
        }
    }

    private async Task DrawPreviewSquare()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var size = Math.Max(Math.Abs(_currentX - _startX), Math.Abs(_currentY - _startY));
        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, size, size);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRectangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        await _ctx.BeginPathAsync();
        await _ctx.RectAsync(_startX, _startY, _currentX - _startX, _currentY - _startY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewTriangle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        // Oblicz środkowy punkt podstawy
        var baseCenterX = (_startX + _currentX) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(baseCenterX, _startY);       // Górny wierzchołek
        await _ctx.LineToAsync(_currentX, _currentY);      // Prawy dolny wierzchołek
        await _ctx.LineToAsync(_startX, _currentY);        // Lewy dolny wierzchołek
        await _ctx.ClosePathAsync();                       // Automatycznie łączy z pierwszym punktem

        await _ctx.StrokeAsync();

    }

    private async Task DrawPreviewTrapezoid()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var topWidthFactor = 0.6; // Możesz dodać parametr do kontroli
        var topX1 = _startX + (_currentX - _startX) * (1 - topWidthFactor) / 2;
        var topX2 = _startX + (_currentX - _startX) * (1 + topWidthFactor) / 2;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(topX1, _startY);
        await _ctx.LineToAsync(topX2, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.LineToAsync(_startX, _currentY);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewRoundedRect()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var radius = 20; // Możesz dodać parametr do kontroli
        var width = _currentX - _startX;
        var height = _currentY - _startY;

        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX + radius, _startY);
        await _ctx.LineToAsync(_startX + width - radius, _startY);
        await _ctx.ArcToAsync(_startX + width, _startY, _startX + width, _startY + radius, radius);
        await _ctx.LineToAsync(_startX + width, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + height);
        await _ctx.LineToAsync(_startX, _startY + radius);
        await _ctx.ArcToAsync(_startX, _startY, _startX + radius, _startY, radius);
        await _ctx.ClosePathAsync();
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewLine()
    {
        await _ctx.BeginPathAsync();
        await _ctx.MoveToAsync(_startX, _startY);
        await _ctx.LineToAsync(_currentX, _currentY);
        await _ctx.StrokeAsync();
    }

    private async Task DrawPreviewCircle()
    {
        // Reset i czyszczenie
        _shapes.Clear();
        await ClearCanvas();

        var radius = CalculateRadius();
        await _ctx.BeginPathAsync();
        await _ctx.ArcAsync(_startX, _startY, radius, 0, 2 * Math.PI);
        await _ctx.StrokeAsync();
    }


    private async Task ClearCanvas()
    {
        await _ctx.SetFillStyleAsync("white");
        await _ctx.FillRectAsync(0, 0, _canvasX, _canvasY);
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }

    // 🎨 INTERFEJS KSZTAŁTÓW
    private interface IShape
    {
        Task Draw(Canvas2DContext ctx);
        List<EditableProperty> GetEditableProperties();
        void Scale(double factor);
        void Move(double offsetX, double offsetY);
        BoundingBox GetBoundingBox();
    }

    // 🖌️ KLASA LINII
    private class LineShape : IShape
    {
        public double X1 { get; set; }
        public double Y1 { get; set; }
        public double X2 { get; set; }
        public double Y2 { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public LineShape(double x1, double y1, double x2, double y2, double scaleFactor)
        {
            X1 = x1;
            Y1 = y1;
            X2 = x2;
            Y2 = y2;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X1, Y1);
            await ctx.LineToAsync(X2, Y2);
            await ctx.StrokeAsync();
        }


        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X1", () => X1, v => X1 = v),
            new EditableProperty("Y1", () => Y1, v => Y1 = v),
            new EditableProperty("X2", () => X2, v => X2 = v),
            new EditableProperty("Y2", () => Y2, v => Y2 = v)
        };

        public void Scale(double factor)
        {
            X2 = X1 + (X2 - X1) * factor;
            Y2 = Y1 + (Y2 - Y1) * factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X1 += offsetX;
            Y1 += offsetY;
            X2 += offsetX;
            Y2 += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(Math.Min(X1, X2), Math.Min(Y1, Y2), Math.Abs(X2 - X1), Math.Abs(Y2 - Y1));
        }



    }

    // 🟥 Klasa prostokąta (Rectangle)
    private class RectangleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RectangleShape(double x, double y, double width, double height, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Width, Height);
            await ctx.StrokeAsync();
        }


        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X", () => GetBoundingBox().X, _ => { }, true),
            new EditableProperty("Y", () => GetBoundingBox().Y, _ => { }, true),
            new EditableProperty("Szerokość", () => Width, v => Width = v),
            new EditableProperty("Wysokość", () => Height, v => Height = v)
        };


        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height);
        }


    }

    // /\ Klasa prostokąta (TriangleShape)
    private class TriangleShape : IShape
    {
        // Współrzędne w przestrzeni "world" (bez transformacji)
        public double BaseX1 { get; set; }
        public double BaseY { get; set; }
        public double BaseWidth { get; set; }
        public double Height { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public TriangleShape(double startX, double startY, double endX, double endY, double scaleFactor)
        {
            // Konwersja do współrzędnych bazowych
            BaseX1 = Math.Min(startX, endX);
            BaseY = Math.Max(startY, endY);
            BaseWidth = Math.Abs(endX - startX);
            Height = Math.Abs(startY - endY);
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            var apexX = BaseX1 + BaseWidth / 2;
            var apexY = BaseY - Height;
            var baseX2 = BaseX1 + BaseWidth;

            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(apexX, apexY);
            await ctx.LineToAsync(baseX2, BaseY);
            await ctx.LineToAsync(BaseX1, BaseY);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("Lewa podstawa X", () => BaseX1, v => BaseX1 = v , true),
        new EditableProperty("Pozycja Y podstawy", () => BaseY, v => BaseY = v, true),
        new EditableProperty("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v),
        new EditableProperty("Wysokość", () => Height, v => Height = v)
    };

        public void Scale(double factor)
        {
            BaseWidth *= factor;
            Height *= factor;
            BaseX1 -= (BaseWidth * (factor - 1)) / 2; // Przesuwamy, aby trójkąt skalował się symetrycznie
            BaseY += (Height * (factor - 1)); // Przesuwamy punkt bazowy
        }

        public void Move(double offsetX, double offsetY)
        {
            BaseX1 += offsetX;
            BaseY += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            double minX = BaseX1;
            double minY = BaseY - Height; // Wierzchołek trójkąta
            double maxX = BaseX1 + BaseWidth;
            double maxY = BaseY;

            double width = maxX - minX;
            double height = maxY - minY;

            return new BoundingBox(minX, minY, width, height);
        }


    }

    // ⬛ Klasa kwadratu (Square)
    private class SquareShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Size { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public SquareShape(double x, double y, double size, double scaleFactor)
        {
            X = x;
            Y = y;
            Size = size;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.RectAsync(X, Y, Size, Size);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
    {
        new EditableProperty("X", () => X, v => X = v, true),
        new EditableProperty("Y", () => Y, v => Y = v, true),
        new EditableProperty("Rozmiar", () => Size, v => Size = v)
    };

        public void Scale(double factor)
        {
            Size *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Size, Size);
        }


    }

    private class RoundedRectangleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Radius { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public RoundedRectangleShape(double x, double y, double width, double height, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(X + Radius, Y);
            await ctx.LineToAsync(X + Width - Radius, Y);
            await ctx.ArcToAsync(X + Width, Y, X + Width, Y + Radius, Radius);
            await ctx.LineToAsync(X + Width, Y + Height);
            await ctx.LineToAsync(X, Y + Height);
            await ctx.LineToAsync(X, Y + Radius);
            await ctx.ArcToAsync(X, Y, X + Radius, Y, Radius);
            await ctx.ClosePathAsync();
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new("X", () => X, v => X = v, true),
            new("Y", () => Y, v => Y = v, true),
            new("Szerokość", () => Width, v => Width = v),
            new("Wysokość", () => Height, v => Height = v),
            new("Promień", () => Radius, v => Radius = v)
        };

        public void Scale(double factor)
        {
            Width *= factor;
            Height *= factor;
            Radius *= factor;
        }
        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, Width, Height);
        }

    }

    private class TrapezoidShape : IShape
    {
        public double BaseWidth { get; set; }
        public double TopWidth { get; set; }
        public double Height { get; set; }
        public double X { get; set; }
        public double Y { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        // Konstruktor przyjmujący współrzędne i współczynnik szerokości góry
        public TrapezoidShape(double startX, double startY, double endX, double endY, double topWidthFactor, double scaleFactor)
        {
            X = Math.Min(startX, endX);           // Ustal minimalne X (lewy brzeg)
            Y = Math.Min(startY, endY);           // Ustal minimalne Y (dolny brzeg)
            BaseWidth = Math.Abs(endX - startX);  // Oblicz szerokość podstawy trapezu
            Height = Math.Abs(endY - startY);     // Oblicz wysokość trapezu
            TopWidth = Math.Min(BaseWidth, BaseWidth * topWidthFactor);  // Oblicz szerokość góry trapezu
            _scaleFactor = scaleFactor;
        }

        // Metoda rysująca trapez
        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            // Oblicz pozycje wierzchołków trapezu
            var baseLeft = X;
            var baseRight = X + BaseWidth;
            var topLeft = X + (BaseWidth - TopWidth) / 2;   // Oblicz pozycję lewej strony góry
            var topRight = topLeft + TopWidth;               // Oblicz pozycję prawej strony góry
            var verticalY = Y + Height;                      // Oblicz wysokość (dolna krawędź)

            // Rysowanie trapezu za pomocą punktów
            await ctx.BeginPathAsync();
            await ctx.MoveToAsync(topLeft, Y);            // Lewy górny
            await ctx.LineToAsync(topRight, Y);           // Prawy górny
            await ctx.LineToAsync(baseRight, verticalY);  // Prawy dolny
            await ctx.LineToAsync(baseLeft, verticalY);   // Lewy dolny
            await ctx.ClosePathAsync();

            await ctx.StrokeAsync();
        }

        // Właściwości edytowalne
        public List<EditableProperty> GetEditableProperties() => new()
    {
        new("Pozycja X", () => X, v => X = v, true),
        new("Pozycja Y", () => Y, v => Y = v, true),
        new("Szerokość podstawy", () => BaseWidth, v => BaseWidth = v),
        new("Szerokość góry", () => TopWidth, v => TopWidth = Math.Clamp(v, 10, BaseWidth - 10)),
        new("Wysokość", () => Height, v => Height = v)
    };

        public void Scale(double factor)
        {
            BaseWidth *= factor;
            TopWidth *= factor;
            Height *= factor;
            X -= (BaseWidth * (factor - 1)) / 2; // Przesuwamy trapez w lewo, aby zachować środek
            Y -= (Height * (factor - 1)) / 2; // Przesuwamy go w górę
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X, Y, BaseWidth, Height);
        }

    }

    // 🟢 KLASA KOŁA
    private class CircleShape : IShape
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Radius { get; set; }

        private double _scaleFactor = 1.0; // Początkowa skala = 1.0 (bez skalowania)

        public CircleShape(double x, double y, double radius, double scaleFactor)
        {
            X = x;
            Y = y;
            Radius = radius;
            _scaleFactor = scaleFactor;
        }

        public async Task Draw(Canvas2DContext ctx)
        {
            await ctx.SetStrokeStyleAsync("black");
            await ctx.SetLineWidthAsync((float)(2 * _scaleFactor));

            await ctx.BeginPathAsync();
            await ctx.ArcAsync(X, Y, Radius, 0, 2 * Math.PI);
            await ctx.StrokeAsync();
        }

        public List<EditableProperty> GetEditableProperties() => new()
        {
            new EditableProperty("X", () => X, v => X = v, true),
            new EditableProperty("Y", () => Y, v => Y = v, true),
            new EditableProperty("Promień", () => Radius, v => Radius = v)
        };

        public void Scale(double factor)
        {
            Radius *= factor;
        }

        public void Move(double offsetX, double offsetY)
        {
            X += offsetX;
            Y += offsetY;
        }

        public BoundingBox GetBoundingBox()
        {
            return new BoundingBox(X - Radius, Y - Radius, Radius * 2, Radius * 2);
        }

    }

    // 🔧 KLASY EDYTOWALNYCH WŁAŚCIWOŚCI
    public record EditableProperty(string Label, Func<double> GetValue, Action<double> SetValue, bool IsReadOnly = false)
    {
        public double Value
        {
            get => GetValue();
            set
            {
                if (!IsReadOnly) SetValue(value);
            }
        }
    }

    private void SelectNextShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex + 1) % _shapes.Count;
    }

    private void SelectPreviousShape()
    {
        if (_shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex - 1 + _shapes.Count) % _shapes.Count;
    }

    private async Task ResizeAllShapes(double factor)
    {
        if (_shapes.Count == 0) return;

        _scaleFactor *= factor; // Zmieniamy globalny współczynnik skali

        await RedrawCanvas();
    }

    private async Task FitToCanvas()
    {
        if (_shapes.Count == 0) return;

        // Znajdź granice wszystkich kształtów
        double minX = _shapes.Min(s => s.GetBoundingBox().X);
        double minY = _shapes.Min(s => s.GetBoundingBox().Y);
        double maxX = _shapes.Max(s => s.GetBoundingBox().X + s.GetBoundingBox().Width);
        double maxY = _shapes.Max(s => s.GetBoundingBox().Y + s.GetBoundingBox().Height);

        double shapesWidth = maxX - minX;
        double shapesHeight = maxY - minY;

        if (shapesWidth == 0 || shapesHeight == 0) return;

        // Obliczamy nowy współczynnik skali
        double scaleX = _canvasX / shapesWidth;
        double scaleY = _canvasY / shapesHeight;
        _scaleFactor = Math.Min(scaleX, scaleY) * 0.9; // Skalujemy z marginesem

        // Obliczamy przesunięcie, aby obiekty były na środku
        double offsetX = (_canvasX - (shapesWidth * _scaleFactor)) / 2 - (minX * _scaleFactor);
        double offsetY = (_canvasY - (shapesHeight * _scaleFactor)) / 2 - (minY * _scaleFactor);

        // Przesuń wszystkie kształty
        foreach (var shape in _shapes)
        {
            shape.Move(offsetX, offsetY);
        }

        await RedrawCanvas();
    }

    private async Task RysOkna()
    {
        if (_selectedShapeIndex < 0 || _selectedShapeIndex >= _shapes.Count) return;

        var windowShape = _shapes[_selectedShapeIndex];
        var windowBox = windowShape.GetBoundingBox();

        // Znajdź wszystkie linie znajdujące się wewnątrz okna
        var linesInsideWindow = _shapes
            .Where((shape, index) => index != _selectedShapeIndex && shape is LineShape)
            .Cast<LineShape>()
            .Where(line => IsLineInsideWindow(line, windowBox))
            .ToList();

        // Skróć każdą linię
        foreach (var line in linesInsideWindow)
        {
            ShortenLineInsideWindow(line, windowBox);
        }

        await RedrawCanvas();
    }

    private bool IsLineInsideWindow(LineShape line, BoundingBoxX windowBox)
    {
        // Sprawdź czy oba punkty linii znajdują się wewnątrz okna
        return windowBox.Contains(line.X1, line.Y1) && windowBox.Contains(line.X2, line.Y2);
    }

    private void ShortenLineInsideWindow(LineShape line, BoundingBoxX windowBox)
    {
        // Oblicz wektor kierunkowy linii
        double dx = line.X2 - line.X1;
        double dy = line.Y2 - line.Y1;

        // Oblicz punkty przecięcia z wszystkimi krawędziami okna
        List<Point> intersections = new List<Point>();

        // Sprawdź przecięcia z każdą krawędzią okna
        CheckEdgeIntersection(windowBox.X, windowBox.Y, windowBox.X + windowBox.Width, windowBox.Y, line, ref intersections); // Górna krawędź
        CheckEdgeIntersection(windowBox.X + windowBox.Width, windowBox.Y, windowBox.X + windowBox.Width, windowBox.Y + windowBox.Height, line, ref intersections); // Prawa krawędź
        CheckEdgeIntersection(windowBox.X, windowBox.Y + windowBox.Height, windowBox.X + windowBox.Width, windowBox.Y + windowBox.Height, line, ref intersections); // Dolna krawędź
        CheckEdgeIntersection(windowBox.X, windowBox.Y, windowBox.X, windowBox.Y + windowBox.Height, line, ref intersections); // Lewa krawędź

        // Jeśli znaleziono dokładnie 2 punkty przecięcia, skróć linię
        if (intersections.Count == 2)
        {
            // Zachowaj oryginalny kierunek linii
            bool isFirstPointCloserToStart =
                Distance(line.X1, line.Y1, intersections[0].X, intersections[0].Y) <
                Distance(line.X1, line.Y1, intersections[1].X, intersections[1].Y);

            if (isFirstPointCloserToStart)
            {
                line.X1 = intersections[0].X;
                line.Y1 = intersections[0].Y;
                line.X2 = intersections[1].X;
                line.Y2 = intersections[1].Y;
            }
            else
            {
                line.X1 = intersections[1].X;
                line.Y1 = intersections[1].Y;
                line.X2 = intersections[0].X;
                line.Y2 = intersections[0].Y;
            }
        }
    }

    private void CheckEdgeIntersection(double edgeX1, double edgeY1, double edgeX2, double edgeY2,
                                     LineShape line, ref List<Point> intersections)
    {
        // Oblicz przecięcie linii z krawędzią okna
        if (FindIntersection(edgeX1, edgeY1, edgeX2, edgeY2,
                            line.X1, line.Y1, line.X2, line.Y2,
                            out double intersectX, out double intersectY))
        {
            // Sprawdź czy punkt przecięcia leży na obu odcinkach
            if (IsPointOnSegment(edgeX1, edgeY1, edgeX2, edgeY2, intersectX, intersectY) &&
                IsPointOnSegment(line.X1, line.Y1, line.X2, line.Y2, intersectX, intersectY))
            {
                intersections.Add(new Point(intersectX, intersectY));
            }
        }
    }

    private bool FindIntersection(double aX1, double aY1, double aX2, double aY2,
                                 double bX1, double bY1, double bX2, double bY2,
                                 out double x, out double y)
    {
        x = 0;
        y = 0;

        double d = (aX1 - aX2) * (bY1 - bY2) - (aY1 - aY2) * (bX1 - bX2);
        if (d == 0) return false; // Linie równoległe

        double t = ((aX1 - bX1) * (bY1 - bY2) - (aY1 - bY1) * (bX1 - bX2)) / d;
        double u = -((aX1 - aX2) * (aY1 - bY1) - (aY1 - aY2) * (aX1 - bX1)) / d;

        x = aX1 + t * (aX2 - aX1);
        y = aY1 + t * (aY2 - aY1);

        return true;
    }

    private bool IsPointOnSegment(double segX1, double segY1, double segX2, double segY2,
                                 double pointX, double pointY)
    {
        // Sprawdź czy punkt leży na odcinku
        double cross = (segY2 - segY1) * (pointX - segX1) - (segX2 - segX1) * (pointY - segY1);
        if (Math.Abs(cross) > 0.001) return false;

        double dot = (pointX - segX1) * (segX2 - segX1) + (pointY - segY1) * (segY2 - segY1);
        if (dot < 0) return false;

        double squaredLength = (segX2 - segX1) * (segX2 - segX1) + (segY2 - segY1) * (segY2 - segY1);
        if (dot > squaredLength) return false;

        return true;
    }

    private double Distance(double x1, double y1, double x2, double y2)
    {
        return Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));
    }

    private struct Point
    {
        public double X { get; set; }
        public double Y { get; set; }
        public Point(double x, double y) { X = x; Y = y; }
    }

    public struct BoundingBoxX
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }

        public BoundingBoxX(double x, double y, double width, double height)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
        }

        // Dodajemy metodę Contains
        public bool Contains(double pointX, double pointY)
        {
            return pointX >= X &&
                   pointX <= X + Width &&
                   pointY >= Y &&
                   pointY <= Y + Height;
        }

        // Dodatkowe przydatne metody
        public double Left => X;
        public double Right => X + Width;
        public double Top => Y;
        public double Bottom => Y + Height;
    }

}
