@page "/KonfiguratorPolaczenKwadratow"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@inject HttpClient Http
@using AntDesign
@inject IMessageService _message
@inject INotificationService _notice
@inject Utilities.ILocalStorage LocalStorage
@using System.Net
@using System.Xml
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject DxfService DxfService
@inject DxfToSvgConverter Converter
@inject NavigationManager NavigationManager

<style>
    .scaled-svg-container {
        width: 100%;
        height: 600px;
        overflow: auto;
        border: 1px solid #ddd;
        background-color: #f8f9fa;
        position: relative;
    }

    .scaled-svg {
        display: block;
        margin: auto;
        background-color: white;
        box-shadow: 0 0 8px rgba(0,0,0,0.1);
        width: 600px;
        height: 600px;
        box-sizing: border-box;
    }

    .controls-container {
        z-index: 100;
        position: relative;
        background: white;
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }

    .model-list {
        max-height: 600px;
        overflow-y: auto;
        border: 1px solid #eee;
        border-radius: 4px;
    }

    .side-checkboxes {
        display: flex;
        gap: 15px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .side-checkbox {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .model-table tr {
        cursor: pointer;
        transition: background-color 0.2s;
    }

        .model-table tr:hover {
            background-color: #f0f7ff;
        }

    .thumbnail-cell {
        width: 70px;
    }

    .status-message {
        padding: 8px;
        margin-bottom: 10px;
        border-radius: 4px;
        background: #e9f7fe;
        color: #1890ff;
    }

    .btn-move {
        width: 32px;
        height: 32px;
        padding: 0;
    }

    .scaled-svg {
        cursor: crosshair; /* Zmień kursor podczas pomiaru */
    }

    .measurement-line {
        stroke: red;
        stroke-width: 2;
        stroke-dasharray: 5,5;
    }

    .measurement-text {
        fill: red;
        font-size: 12px;
        font-family: Arial, sans-serif;
        user-select: none;
    }
</style>

<script>
    // 🧠 Inicjalizacja namespace i stanu zoomLevel
    let activScale = 1;
    window.svgHelper = window.svgHelper || {};
    window.svgHelper.zoomLevel = window.svgHelper.zoomLevel || 1;

    // 🔄 Centrowanie i dopasowanie SVG do kontenera
    window.svgHelper.centerAndFit = function() {
        const svg = document.querySelector(".scaled-svg");
        const container = document.querySelector(".scaled-svg-container");
        const svgContent = svg?.querySelector("#zoom-group");

        if (!svg || !container || !svgContent) return;

        // Reset transformacji do obliczenia bounding box
        const prevTransform = svgContent.getAttribute("transform") || "";
        svgContent.setAttribute("transform", "");

        const bbox = svgContent.getBBox();
        svgContent.setAttribute("transform", prevTransform);

        const svgWidth = svg.clientWidth;
        const svgHeight = svg.clientHeight;

        const scale = Math.min(
            svgWidth / (bbox.width + 50),
            svgHeight / (bbox.height + 50)
        ) * 0.95;

        const offsetX = (svgWidth - bbox.width * scale) / 2 - bbox.x * scale;
        const offsetY = (svgHeight - bbox.height * scale) / 2 - bbox.y * scale;

        activScale = scale;

        svgContent.setAttribute("transform",
            `translate(${offsetX}, ${offsetY}) scale(${scale})`);
        window.svgHelper.zoomLevel = scale;

        activScale = scale;
    };

    // 🔁 Obrót tylko drugiego modelu
    window.svgHelper.rotateSecondModel = function() {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";

        // Wyodrębnij aktualne przesunięcie
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        // Wyodrębnij aktualny kąt obrotu
        const rotateMatch = currentTransform.match(/rotate\(([-\d.]+)/);
        const currentAngle = rotateMatch ? parseFloat(rotateMatch[1]) : 0;
        const newAngle = (currentAngle + 90) % 360;

        // Oblicz środek modelu
        const bbox = model2.getBBox();
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;

        // Zastosuj nową transformację
        model2.setAttribute("transform", `${translate} rotate(${newAngle}, ${cx}, ${cy})`);
    };

    // 📌 Przesuń
        window.svgHelper.move = function(dx, dy) {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);

        let x = 0, y = 0;
        if (translateMatch) {
            [x, y] = translateMatch[1].split(',').map(Number);
        }

        // Aktualizuj pozycję z uwzględnieniem skali
        const scale = window.svgHelper.zoomLevel || 1;
        x += dx / scale;
        y += dy / scale;

        // Zachowaj obrót jeśli istnieje
        const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);
        const rotate = rotateMatch ? ` rotate(${rotateMatch[1]})` : "";

        model2.setAttribute("transform", `translate(${x}, ${y})${rotate}`);

        // Zwróć aktualną pozycję (opcjonalnie)
        return { x: x * scale, y: y * scale };
    };


    // 🔍 Powiększenie z centrowaniem
    window.svgHelper.zoomIn = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale * 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🔍 Pomniejszenie z centrowaniem
    window.svgHelper.zoomOut = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale / 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🛠️ Zastosowanie aktualnego zoomLevel do całego SVG
    window.svgHelper.applyZoom = function () {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const current = group.getAttribute("transform") || "";
        const translateMatch = current.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        group.setAttribute("transform", `${translate} scale(${window.svgHelper.zoomLevel})`);
    };

        // 📏 Inicjalizacja pomiaru
    window.svgHelper.initMeasurement = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        let startPoint = null;
        let measurementLine = null;
        let measurementText = null;

        // Tworzymy elementy do pomiaru
        const createMeasurementElements = () => {
            measurementLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            measurementLine.setAttribute("stroke", "red");
            measurementLine.setAttribute("stroke-width", "2");
            measurementLine.setAttribute("stroke-dasharray", "5,5");

            measurementText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            measurementText.setAttribute("fill", "red");
            measurementText.setAttribute("font-size", "22");

            svg.querySelector("svg").appendChild(measurementLine);
            svg.querySelector("svg").appendChild(measurementText);
        };

        // Usuwamy elementy pomiaru
        const removeMeasurementElements = () => {
            if (measurementLine && measurementLine.parentNode) {
                measurementLine.parentNode.removeChild(measurementLine);
            }
            if (measurementText && measurementText.parentNode) {
                measurementText.parentNode.removeChild(measurementText);
            }
        };

        // Obliczamy odległość między punktami
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        // Aktualizujemy linię i tekst pomiaru
        const updateMeasurement = (x1, y1, x2, y2) => {
            if (!measurementLine || !measurementText) return;

            const distance = calculateDistance(x1, y1, x2, y2) / activScale;
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;

            measurementLine.setAttribute("x1", x1);
            measurementLine.setAttribute("y1", y1);
            measurementLine.setAttribute("x2", x2);
            measurementLine.setAttribute("y2", y2);

            measurementText.setAttribute("x", midX);
            measurementText.setAttribute("y", midY);
            measurementText.textContent = distance.toFixed(2) + " mm";
        };

        // Obsługa kliknięć
        svg.addEventListener("click", (e) => {
            if (!startPoint) {
                // Pierwsze kliknięcie - punkt startowy
                startPoint = {
                    x: e.offsetX,
                    y: e.offsetY
                };
                createMeasurementElements();
            } else {
                // Drugie kliknięcie - punkt końcowy
                updateMeasurement(startPoint.x, startPoint.y, e.offsetX, e.offsetY);
                startPoint = null;

                // Automatyczne usunięcie po 5 sekundach
                setTimeout(() => {
                    removeMeasurementElements();
                }, 5000);
            }
        });
    };

    // 🔄 Wyczyść pomiary
    window.svgHelper.clearMeasurements = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        const lines = svg.querySelectorAll("line[stroke='red']");
        const texts = svg.querySelectorAll("text[fill='red']");

        lines.forEach(line => line.parentNode?.removeChild(line));
        texts.forEach(text => text.parentNode?.removeChild(text));
    };


    // 📐 Ulepszona funkcja pomiaru przesunięcia prowadnic
    // Wywołaj tę funkcję po załadowaniu SVG
    window.svgHelper.initGuideLines = function () {
        const svgEl = document.querySelector(".scaled-svg svg");
        if (!svgEl) {
            console.error("[initGuideLines] Nie znaleziono <svg>");
            return;
        }

        const models = ["#model1", "#model2"];
        models.forEach((modelId) => {
            const model = svgEl.querySelector(modelId);
            if (!model) {
                console.warn(`[initGuideLines] Nie znaleziono ${modelId}`);
                return;
            }

            const guides = model.querySelectorAll('[data-name^="guide-line-"]');
            console.log(`[initGuideLines] ${modelId} - znaleziono prowadnic: ${guides.length}`);

            guides.forEach(el => {
                const bbox = el.getBBox();
                const pt = svgEl.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;

                const ctm = el.getCTM();
                if (!ctm) {
                    console.warn(`[initGuideLines] Brak CTM dla`, el);
                    return;
                }

                const transformed = pt.matrixTransform(ctm);

                if (el.getAttribute('data-name')?.includes('horizontal')) {
                    el.setAttribute('data-original-y', transformed.y.toString());
                } else {
                    el.setAttribute('data-original-x', transformed.x.toString());
                }
            });
        });
    };

    window.svgHelper.measureGuideDisplacement = function () {
        try {
            const svg = document.querySelector(".scaled-svg > svg");
            if (!svg) {
                console.error("SVG container not found");
                return null;
            }

            const model1 = svg.querySelector("#model1");
            const model2 = svg.querySelector("#model2");

            if (!model1 || !model2) {
                console.error("Nie znaleziono obu modeli");
                return null;
            }

            const findGuide = (model, name) => {
                return model.querySelector(`[data-name="${name}"]`) ||
                       model.querySelector(`[name="${name}"]`);
            };

            const guideHorizontalModel1 = findGuide(model1, 'guide-line-horizontalMax');
            const guideVerticalModel1 = findGuide(model1, 'guide-line-vertical');
            const guideHorizontalModel2 = findGuide(model2, 'guide-line-horizontalMax');
            const guideVerticalModel2 = findGuide(model2, 'guide-line-vertical');

            if (!guideHorizontalModel1 || !guideVerticalModel1 ||
                !guideHorizontalModel2 || !guideVerticalModel2) {
                console.warn("Nie znaleziono wszystkich prowadnic");
                return null;
            }

            const getTransformedCenter = (el) => {
                const bbox = el.getBBox();
                const pt = svg.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;
                const ctm = el.getCTM();
                return pt.matrixTransform(ctm);
            };

            const centerH1 = getTransformedCenter(guideHorizontalModel1);
            const centerV1 = getTransformedCenter(guideVerticalModel1);
            const centerH2 = getTransformedCenter(guideHorizontalModel2);
            const centerV2 = getTransformedCenter(guideVerticalModel2);

            const displacementX = (centerV2.x - centerV1.x) / window.svgHelper.zoomLevel;
            const displacementY = (centerH2.y - centerH1.y) / window.svgHelper.zoomLevel;

            return {
                success: true,
                elementsFound: true,
                przesuniecieX: displacementX,
                przesuniecieY: displacementY,
                scale: window.svgHelper.zoomLevel
            };
        } catch (error) {
            console.error("Measurement error:", error);
            return {
                success: false,
                error: error.message
            };
        }
    };

    function sanitizeSvg(svgElement) {
        const numericAttributes = [
            "x", "y", "x1", "y1", "x2", "y2", "cx", "cy", "r", "rx", "ry",
            "width", "height", "stroke-width"
        ];

        const walk = (node) => {
            if (node.nodeType !== 1) return;

            // Normalizacja atrybutów liczbowych
            numericAttributes.forEach(attr => {
                if (node.hasAttribute(attr)) {
                    const val = node.getAttribute(attr);
                    const parsed = parseFloat(val);
                    if (!isNaN(parsed)) {
                        node.setAttribute(attr, parsed.toString());
                    }
                }
            });

            // Usuń niepotrzebne atrybuty
            ['data-name', 'data-original-x', 'data-original-y'].forEach(attr => {
                node.removeAttribute(attr);
            });

            // Rekurencyjnie przetwarzaj dzieci
            Array.from(node.children).forEach(walk);
        };

        walk(svgElement);
    }

    window.svgHelper.exportCleanedSvgAsPng = function() {
        return new Promise((resolve) => {
            try {
                console.log("Starting PNG export...");

                // 1. Pobierz elementy SVG
                const svgElement = document.querySelector(".scaled-svg");
                const svgContent = svgElement?.querySelector("#zoom-group");

                if (!svgElement || !svgContent) {
                    console.error("SVG elements not found");
                    resolve("");
                    return;
                }

                // 2. Utwórz głęboką kopię SVG
                const clone = svgElement.cloneNode(true);
                const cloneContent = clone.querySelector("#zoom-group");

                // 3. Usuń niepotrzebne elementy
                const elementsToRemove = [
                    '[data-name^="guide-line-"]',
                    '[id^="guide-line-"]',
                    '.measurement-line',
                    '.measurement-text'
                ].join(',');

                clone.querySelectorAll(elementsToRemove).forEach(el => el.remove());
                console.log("Removed guide elements");

                // 4. Pobierz aktualną transformację
                const currentTransform = svgContent.getAttribute("transform") || "";
                console.log("Current transform:", currentTransform);

                // 5. Przygotuj nowy SVG
                const newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                newSvg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                newSvg.setAttribute("width", "600");
                newSvg.setAttribute("height", "600");
                newSvg.setAttribute("viewBox", "0 0 600 600");

                // 6. Przenieś zawartość ZACHOWUJĄC ORYGINALNĄ TRANSFORMACJĘ
                const contentGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                contentGroup.setAttribute("transform", currentTransform);

                // Przenieś wszystkie dzieci zachowując ich właściwości
                while (cloneContent.firstChild) {
                    contentGroup.appendChild(cloneContent.firstChild);
                }

                newSvg.appendChild(contentGroup);
                console.log("SVG content prepared:", newSvg);

                // 7. Serializacja
                const svgString = new XMLSerializer().serializeToString(newSvg);
                console.log("SVG string length:", svgString.length);

                // 8. Konwersja do obrazka
                const img = new Image();
                img.onload = function() {
                    try {
                        console.log("Image loaded, creating PNG...");
                        const canvas = document.createElement("canvas");
                        canvas.width = 600;
                        canvas.height = 600;
                        const ctx = canvas.getContext("2d");

                        // Białe tło
                        ctx.fillStyle = "#ffffff";
                        ctx.fillRect(0, 0, 1200, 1200);

                        // Renderuj SVG (1:1 bez dodatkowego skalowania)
                        ctx.drawImage(img, 0, 0);

                        const pngData = canvas.toDataURL("image/png");
                        console.log("PNG created successfully");
                        resolve(pngData);
                    } catch (e) {
                        console.error("Canvas error:", e);
                        resolve("");
                    }
                };

                img.onerror = function(e) {
                    console.error("Image load error:", e);
                    console.log("Problematic SVG:", svgString.substring(0, 500));
                    resolve("");
                };

                img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
            } catch (e) {
                console.error("Export error:", e);
                resolve("");
            }
        });
    };

</script>


<div class="container-fluid mt-3">
    <div class="row mb-3">
        <div class="col">
            <div class="d-flex align-items-center gap-3">
                <Tooltip Placement="@Placement.TopRight" Title="Wróć do poprzedniej strony">
                    <Button class="btn btn-outline-secondary" Icon="@IconType.Fill.Backward" 
                            Style="width: 35px;" OnClick="GoBack" />
                </Tooltip>

                <div class="flex-grow-1">
                    <label class="form-label">Wybierz system:</label>
                    <select class="form-select" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                </div>
            </div>
        </div>
    </div>
    <Tabs>
        <TabPane Tab="Istniejące konfiguracje" >
            <h4>Lista zapisanych połączeń
                <Button Icon="@IconType.Outline.Read" OnClick="OdswiezDane"/>
            </h4>

            @if (listaPolaczen == null)
            {
                <p><em>Wybierz system i poczekaj na załadowanie danych...</em></p>
            }
            else if (!listaPolaczen.Any())
            {
                <p><strong>Brak zapisanych połączeń.</strong></p>
            }
            else
            {
                <table class="table table-bordered table-striped">
                    <thead class="table-light">
                        <tr>
                            <th>Rysunek</th>
                            <th>Uwagi</th>
                            <th>Strona</th>
                            <th>X [mm]</th>
                            <th>Y [mm]</th>
                            <th>Kąt [°]</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var polaczenie in listaPolaczen)
                        {
                            <tr>
                                <td>
                                    @if (polaczenie.RysunekPrzekroju?.Length > 0)
                                    {

                                        <a target="_blank" href="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)">
                                            <img src="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)"
                                                 style="width: 150px; height: auto; object-fit: contain; border: 1px solid #ccc;" />
                                        </a>
                                    }
                                    else
                                    {
                                        <span class="text-muted">Brak</span>
                                    }
                                </td>
                                <td>@polaczenie.Uwagi</td>
                                <td>@polaczenie.StronaPolaczenia</td>
                                <td>@polaczenie.PrzesuniecieX:F2</td>
                                <td>@polaczenie.PrzesuniecieY:F2</td>
                                <td>@polaczenie.ZapisanyKat</td>
                            </tr>
                        }
                    </tbody>
                </table>
            }
         </TabPane>
         <TabPane Tab="Konfigurator połączeń" >
            <div class="row">
            <div class="col-md-4">
                <div class="model-list">
                    @if (ListaModeli != null && ListaModeli.Any())
                    {
                        <div class="side-checkboxes">
                            <div class="side-checkbox">
                                <input type="checkbox" @bind="selDol" id="str_dol" />
                                <label for="str_dol">Dół</label>
                            </div>
                            <div class="side-checkbox">
                                <input type="checkbox" @bind="selGora" id="str_gora" />
                                <label for="str_gora">Góra</label>
                            </div>
                            <div class="side-checkbox">
                                <input type="checkbox" @bind="selLewa" id="str_lewa" />
                                <label for="str_lewa">Lewa</label>
                            </div>
                            <div class="side-checkbox">
                                <input type="checkbox" @bind="selPrawa" id="str_prawa" />
                                <label for="str_prawa">Prawa</label>
                            </div>
                        </div>

                        <table class="table model-table">
                            <thead>
                                <tr>
                                    <th>Nazwa</th>
                                    <th>Typ</th>
                                    <th class="thumbnail-cell">Miniaturka</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var model in ListaModeli)
                                {
                                    <tr @onclick="() => WybierzModel(model, selDol, selGora, selLewa, selPrawa)">
                                        <td>@model.NazwaKonfiguracji</td>
                                        <td>@model.Typ</td>
                                        <td>
                                            @if (model.Rysunek?.Length > 0)
                                            {
                                                <img src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)" 
                                                     width="60" height="60" />
                                            }
                                            else
                                            {
                                                <span class="text-muted">Brak</span>
                                            }
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    }
                    else
                    {
                        <div class="alert alert-info">Brak zapisanych modeli.</div>
                    }
                </div>
            </div>

            <div class="col-md-8">
                <div class="controls-container">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <Tooltip Title="Zapisz ustawienia">
                                <Button Icon="@IconType.Fill.Save" OnClick="SaveAllPosition" Class="btn btn-primary me-2">
                                    Zapisz
                                </Button>
                            </Tooltip>
                        </div>
                    
                        <div class="btn-group">
                            <Tooltip Title="Obróć drugi model">
                                <Button Icon="@IconType.Outline.Loading" OnClick="RotateObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Przesuń w lewo (1px)">
                                <Button Icon="@IconType.Outline.ArrowLeft" OnClick="MoveLeftObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Przesuń w prawo (1px)">
                                <Button Icon="@IconType.Outline.ArrowRight" OnClick="MoveRightObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Przesuń w górę (1px)">
                                <Button Icon="@IconType.Outline.ArrowUp" OnClick="MoveUpObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Przesuń w dół (1px)">
                                <Button Icon="@IconType.Outline.ArrowDown" OnClick="MoveDownObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Dopasuj widok">
                                <Button Icon="@IconType.Outline.Windows" OnClick="ZoomAllObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Powiększ">
                                <Button Icon="@IconType.Outline.ZoomIn" OnClick="ZoomInObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Pomniejsz">
                                <Button Icon="@IconType.Outline.ZoomOut" OnClick="ZoomOutObj" Class="btn-sm btn-move" />
                            </Tooltip>
                            <label class="ms-2">Precyzja przesuwania:</label>
                            <AntDesign.InputNumber @bind-Value="precyzjaPrzesuwania" Min="0" Max="20" Style="width: 60px;" />

                            <Tooltip Title="Pomiar odległości">
                                <Button Icon="@IconType.Outline.Scan" OnClick="StartMeasurement" Class="btn-sm btn-move" />
                            </Tooltip>
                            <Tooltip Title="Wyczyść pomiary">
                                <Button Icon="@IconType.Outline.Close" OnClick="ClearMeasurements" Class="btn-sm btn-move" />
                            </Tooltip>
                        </div>
                    </div>
                </div>

                <div class="mb-2 d-flex justify-content-between">
                    <h6>Podgląd połączenia</h6>
                    <div>
                        <Button Icon="@IconType.Outline.Fire" OnClick="RefreshSvg" Class="btn-sm me-2">
                            Odśwież
                        </Button>
                        <Button Icon="@IconType.Outline.Clear" OnClick="DelSvg" Class="btn-sm btn-danger">
                            Wyczyść
                        </Button>
                    </div>
                </div>

                @if (pierwszyModel != null || drugiModel != null)
                {
                    <div class="status-message">
                        @if (pierwszyModel != null && drugiModel == null)
                        {
                            <span>Pierwszy model wybrany: <strong>@pierwszyModel.Nazwa</strong></span>
                        }
                        else if (pierwszyModel != null && drugiModel != null)
                        {
                            <span>Połączono: <strong>@pierwszyModel.Nazwa</strong> z <strong>@drugiModel.Nazwa</strong></span>
                        }
                    </div>
                }

                <div class="scaled-svg-container">
                    @if (!string.IsNullOrEmpty(combinedSvg))
                    {
                        <div class="scaled-svg" @key="SvgKey">
                            @((MarkupString)combinedSvg)
                        </div>
                    }
                    else
                    {
                        <div class="d-flex flex-column justify-content-center align-items-center h-100">
                            <div class="alert alert-info mb-3">
                                Wybierz modele ramy, skrzydła lub poprzeczki
                            </div>
                            @if (!string.IsNullOrEmpty(BladKonfiguracji))
                            {
                                <div class="alert alert-warning">
                                    @BladKonfiguracji
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>
        </TabPane>
    </Tabs>
</div>

@code {
    [Inject] private AppState AppState { get; set; } = default!;

    // Dane i stan
    private string SvgKey { get; set; } = Guid.NewGuid().ToString();
    private List<SystemyOkienne> Systemy = new();
    private string? SelectedSystemId;
    private List<KonfModele>? ListaModeli;
    private List<KonfSystem>? KonfiguracjeSystemu;
    private float precyzjaPrzesuwania = 5;
    private string BladKonfiguracji = string.Empty;

    // Wybór stron
    private bool selDol = false;
    private bool selGora = false;
    private bool selLewa = false;
    private bool selPrawa = false;

    // Modele SVG
    private KonfSystem? pierwszyModel;
    private KonfSystem? drugiModel;
    private string combinedSvg = string.Empty;
    private double offsetX = 0;
    private double offsetY = 0;
    private double luzLewo = 50;  // Zwiększony luz
    private double luzPrawo = 50;
    private double luzGora = 50;
    private double luzDol = 50;

    private double przesuniecieX;
    private double przesuniecieY;
    private int katUstawienia = 0;

    private List<KonfPolaczenie>? listaPolaczen;

    // Inicjalizacja
    protected override async Task OnInitializedAsync()
    {
        await Laduj_Uprawnienia();
        Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne") ?? new();

    }

    // Obsługa wyboru systemu
    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value?.ToString();

        if (string.IsNullOrEmpty(SelectedSystemId)) return;

        Console.WriteLine($"Row ID wybranego systemu: {SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}") ?? new();
        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}") ?? new();

        try
        {
            var response = await Http.GetAsync($"api/KonfPolaczenie/row-id-system/{SelectedSystemId}");

            if (response.IsSuccessStatusCode)
            {
                listaPolaczen = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>() ?? new();
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                // 👇 Obsłuż błąd NotFound — nie ma rekordów, to nie błąd techniczny
                listaPolaczen = new();
                Console.WriteLine("Brak połączeń dla danego systemu.");
            }
            else
            {
                // 👇 Inne błędy — np. 500
                Console.Error.WriteLine($"Błąd HTTP {response.StatusCode}");
                listaPolaczen = new();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Błąd ładowania połączeń: {ex.Message}");
            listaPolaczen = new();
        }
    }

    private async Task OdswiezDane()
    {
        if(string.IsNullOrEmpty(SelectedSystemId))
        {
            Console.WriteLine("Nie wybrano systemu.");
            return;
        }

        try
        {
            var response = await Http.GetAsync($"api/KonfPolaczenie/row-id-system/{SelectedSystemId}");

            if (response.IsSuccessStatusCode)
            {
                listaPolaczen = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>() ?? new();
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                // 👇 Obsłuż błąd NotFound — nie ma rekordów, to nie błąd techniczny
                listaPolaczen = new();
                Console.WriteLine("Brak połączeń dla danego systemu.");
            }
            else
            {
                // 👇 Inne błędy — np. 500
                Console.Error.WriteLine($"Błąd HTTP {response.StatusCode}");
                listaPolaczen = new();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Błąd ładowania połączeń: {ex.Message}");
            listaPolaczen = new();
        }
    }

    // Wybór modelu
    private async Task WybierzModel(KonfModele model, bool stronaDol, bool stronaGora, bool stronaLewa, bool stronaPrawa)
    {

        if(!selDol && !selGora && !selLewa && !selPrawa)
        {
            BladKonfiguracji = "Wybierz co najmniej jedną stronę (Dół, Góra, Lewa, Prawa).";
            return;
        }

        BladKonfiguracji = "";

        try
        {
            var response = await Http.GetAsync($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{model.RowId}");
            if (!response.IsSuccessStatusCode)
            {
                BladKonfiguracji = $"Błąd: {response.StatusCode}";
                return;
            }

            var result = await response.Content.ReadFromJsonAsync<MVCKonfModele>();
            if (result?.KonfSystem == null || result.KonfSystem.Count == 0)
            {
                BladKonfiguracji = "Brak danych powiązanych";
                return;
            }

            var pasujacy = result.KonfSystem.FirstOrDefault(x =>
                (stronaDol && x.WystepujeDol) ||
                (stronaGora && x.WystepujeGora) ||
                (stronaLewa && x.WystepujeLewa) ||
                (stronaPrawa && x.WystepujePrawa));

            if (pasujacy == null)
            {
                BladKonfiguracji = "Nie znaleziono pasującego elementu. Zmień występowanie elementu.";
                return;
            }

            Console.WriteLine($"Wybór modelu: {model.NazwaKonfiguracji}, pasujący: {pasujacy.Nazwa} WystepujeDol: {pasujacy.WystepujeDol} = {stronaDol}");

            if (pierwszyModel == null)
            {
                pierwszyModel = pasujacy;
                offsetX = 0; // Resetuj offset
                offsetY = 0; // Resetuj offset

                AktualizujSvg();
            }
            else if (drugiModel == null)
            {
                drugiModel = pasujacy;

                AktualizujSvg();                          // 1. generuj combinedSvg
                await InvokeAsync(StateHasChanged);      // 2. wymuś render Blazora

                await Task.Delay(100);                    // 3. krótka pauza lub: await Task.Yield();
                await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");

            }

        }
        catch (Exception ex)
        {
            BladKonfiguracji = $"Błąd: {ex.Message}";
        }
    }

    // Generowanie SVG z większym obszarem roboczym
    private void AktualizujSvg()
    {
        if (pierwszyModel == null && drugiModel == null)
        {
            combinedSvg = "";
            return;
        }

        var svgParts = new List<string>();
        double centerX = 300; // Środek obszaru roboczego (600x600/2)
        double centerY = 300;

        // Obliczanie pozycji dla pierwszego modelu (zawsze na środku)
        if (pierwszyModel != null)
        {
            svgParts.Add($@"<g id=""model1"" transform=""translate({centerX}, {centerY})"">{ExtractInnerSvg(NormalizeSvg(pierwszyModel.SVG))}</g>");
        }

        // Obliczanie pozycji dla drugiego modelu (względem pierwszego z luzem)
        if (drugiModel != null)
        {
            double secondX = centerX + offsetX;
            double secondY = centerY + offsetY;
            svgParts.Add($@"<g id=""model2"" transform=""translate({secondX}, {secondY})"">{ExtractInnerSvg(NormalizeSvg(drugiModel.SVG))}</g>");
        }

        combinedSvg = $@"
        <svg xmlns=""http://www.w3.org/2000/svg"" width=""600"" height=""600"" viewBox=""0 0 600 600"" preserveAspectRatio=""xMidYMid meet"">
            <g id=""zoom-group"">
    {string.Join("", svgParts)}
            </g>
        </svg>";

        string NormalizeSvg(string combinedSvg) =>
        combinedSvg?
        .Replace("id=\"guide-line-horizontalMax\"", "data-name=\"guide-line-horizontalMax\"")
        .Replace("id=\"guide-line-vertical\"", "data-name=\"guide-line-vertical\"")
        .Trim('\uFEFF', '\u200B', '\u0000')
        .Replace("\r", "").Replace("\n", "").Trim() ?? "";


        SvgKey = Guid.NewGuid().ToString();

        // Console.WriteLine($"AktualizujSvg: wygenerowano SVG: {combinedSvg}");
    }

    // Pomocnicze metody do przetwarzania SVG
    private string NormalizeSvg(string svg) => svg?.Trim('\uFEFF', '\u200B', '\u0000').Replace("\r", "").Replace("\n", "").Trim() ?? "";

    private string ExtractInnerSvg(string svg)
    {
        if (string.IsNullOrWhiteSpace(svg)) return "";
        int start = svg.IndexOf('>') + 1;
        int end = svg.LastIndexOf("</svg>", StringComparison.OrdinalIgnoreCase);
        return (start > 0 && end > start) ? svg.Substring(start, end - start).Trim() : svg;
    }

    // Kontrola SVG
    private async Task RefreshSvg()
    {
        AktualizujSvg();
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
        await Task.Delay(100); // 💡 daj czas DOM-owi
        await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");
    }

    private async Task DelSvg()
    {
        pierwszyModel = null;
        drugiModel = null;
        offsetX = 0;
        offsetY = 0;
        BladKonfiguracji = "";
        AktualizujSvg();

        await Task.CompletedTask;   
    }

    // Manipulacja drugim modelem
    private async Task PrzesunDrugiModel(string kierunek)
    {
        if (drugiModel == null) return;

        switch (kierunek)
        {
            case "gora": offsetY -= 1; break;
            case "dol": offsetY += 1; break;
            case "lewo": offsetX -= 1; break;
            case "prawo": offsetX += 1; break;
        }

        AktualizujSvg();
        await Task.Delay(10);
    }

    private async Task MoveLeftObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", -precyzjaPrzesuwania, 0);
    private async Task MoveRightObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", precyzjaPrzesuwania, 0);
    private async Task MoveUpObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, -precyzjaPrzesuwania);
    private async Task MoveDownObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, precyzjaPrzesuwania);
    private async Task ZoomAllObj() => await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
    private async Task GoBack() => await JSRuntime.InvokeVoidAsync("history.back");

    private async Task ZoomInObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomIn");
    private async Task ZoomOutObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomOut");

    private async Task RotateObj()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.rotateSecondModel");

        katUstawienia = (katUstawienia + 90) % 360;
    }

    private async Task StartMeasurement()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
        await JSRuntime.InvokeVoidAsync("svgHelper.initMeasurement");
    }

    private async Task ClearMeasurements()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
    }

    private async Task SaveAllPosition()
    {
        var result = await JSRuntime.InvokeAsync<GuideDisplacementResult>("svgHelper.measureGuideDisplacement");

        if (result?.success != true || !result.elementsFound)
        {
            await _message.Warning(result?.error ?? "❗ Nie można znaleźć prowadnic w rysunku SVG");
            return;
        }

        przesuniecieX = result.przesuniecieX;
        przesuniecieY = result.przesuniecieY;

        if (pierwszyModel == null || drugiModel == null)
        {
            await _message.Warning("❗ Nie wybrano obu modeli do połączenia");
            return;
        }

        var strony = WyliczStronyPolaczenia(); // ⬅️ lista stringów np. ["lewa", "prawa"]
        var png = await GenerujPngBezProwadnic();

        foreach (var strona in strony)
        {
            var polaczenie = new KonfPolaczenie
            {
                ElementZewnetrznyId = pierwszyModel.RowId,
                ElementWewnetrznyId = drugiModel.RowId,
                StronaPolaczenia = strona,
                PrzesuniecieX = przesuniecieX,
                PrzesuniecieY = przesuniecieY,
                ZapisanyKat = katUstawienia,
                RysunekPrzekroju = png,
                RowIdSystem = Guid.Parse(SelectedSystemId), // 👈 jawna konwersja
                Uwagi = $"Połączono: {pierwszyModel.Nazwa ?? "Model 1 ?"} z {drugiModel.Nazwa ?? "Model 2 ?"}"
            };

            // 🔎 Sprawdź czy istnieje połączenie DLA TEJ STRONY
            KonfPolaczenie? existing = null;
            try
            {
                var responseS = await Http.GetAsync(
                    $"api/KonfPolaczenie/find-by-elements/{polaczenie.ElementZewnetrznyId}/{polaczenie.ElementWewnetrznyId}/{strona}");

                if (responseS.IsSuccessStatusCode)
                {
                    existing = await responseS.Content.ReadFromJsonAsync<KonfPolaczenie>();
                }
                else if (responseS.StatusCode != HttpStatusCode.NotFound)
                {
                    await _message.Error($"❌ Błąd sprawdzania strony: {strona}");
                    continue;
                }
            }
            catch (Exception ex)
            {
                await _message.Error($"❌ Błąd komunikacji z API dla strony {strona}: {ex.Message}");
                continue;
            }

            HttpResponseMessage response;
            if (existing is not null)
            {
                polaczenie.RowId = existing.RowId;
                polaczenie.Id = existing.Id;
                polaczenie.RowIdSystem = Guid.Parse(SelectedSystemId);
                polaczenie.PrzesuniecieX = przesuniecieX;
                polaczenie.PrzesuniecieY = przesuniecieY;
                polaczenie.RysunekPrzekroju = png;

                response = await Http.PutAsJsonAsync("api/KonfPolaczenie", polaczenie);
            }
            else
            {
                response = await Http.PostAsJsonAsync("api/KonfPolaczenie", polaczenie);
            }

            if (response.IsSuccessStatusCode)
            {
                await _message.Success($"✅ Zapisano stronę {strona}: X={przesuniecieX:F2} mm, Y={przesuniecieY:F2} mm (skala: {result.scale:F2}), Kąt: {katUstawienia}°" , 0.7);
            }
            else
            {
                await _message.Error($"❌ Błąd zapisu strony {strona}");
            }
        }
    }

    private async Task<byte[]> GenerujPngBezProwadnic()
    {
        try
        {
            // 1. Wymuś aktualizację UI
            StateHasChanged();
            await Task.Delay(100); // Czekaj na renderowanie

            // 2. Wygeneruj PNG
            var base64 = await JSRuntime.InvokeAsync<string>("svgHelper.exportCleanedSvgAsPng");

            if (string.IsNullOrEmpty(base64) || base64.Length < 100)
            {
                Console.WriteLine("Invalid PNG data received");
                return Array.Empty<byte>();
            }

            // 3. Konwersja do byte[]
            var pureBase64 = base64.StartsWith("data:image/png;base64,")
                ? base64["data:image/png;base64,".Length..]
                : base64;

            var imageData = Convert.FromBase64String(pureBase64);

            // 4. Walidacja rozmiaru
            if (imageData.Length < 1000) // Minimalny oczekiwany rozmiar
            {
                Console.WriteLine("PNG file too small");
                return Array.Empty<byte>();
            }

            return imageData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating PNG: {ex.Message}");
            return Array.Empty<byte>();
        }
    }
   
    private List<string> WyliczStronyPolaczenia()
    {
        var strony = new List<string>();
        if (selLewa) strony.Add("lewa");
        if (selPrawa) strony.Add("prawa");
        if (selGora) strony.Add("góra");
        if (selDol) strony.Add("dół");
        Console.WriteLine($"WyliczStronyPolaczenia: {string.Join(", ", strony)}");
        return strony;
    }



    // Uprawnienia
    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");
        if (string.IsNullOrEmpty(user)) return;

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/KonfPolaczenie");
            if (uprawnienia?.Count > 0)
            {
                var szuk = uprawnienia.FirstOrDefault(x => x.TableName == "KonfPolaczenie");
                if (szuk != null)
                {
                    boolOdczyt = szuk.Odczyt;
                    boolZmiana = szuk.Zmiana;
                    boolUsuniecia = szuk.Usuniecie;
                    boolAdmin = szuk.Administrator;
                    boolNowy = szuk.Zapis;
                    RowIdPracownika = szuk.RowId;
                }
            }
        }
        catch (Exception ex)
        {
            await _message.Error($"Błąd ładowania uprawnień: {ex.Message}");
        }
    }

    public class GuideDisplacementResult
    {
        public bool success { get; set; }
        public bool elementsFound { get; set; }
        public double przesuniecieX { get; set; }
        public double przesuniecieY { get; set; }
        public double scale { get; set; }
        public string? error { get; set; } // opcjonalnie
    }

    // public class GuideDisplacementResult
    // {
    //     public bool success { get; set; }
    //     public bool elementsFound { get; set; }
    //     public double horizontalDisplacement { get; set; }
    //     public double verticalDisplacement { get; set; }
    //     public double scale { get; set; }
    //     public string? error { get; set; }
    //     public string? horizontalElement { get; set; }
    //     public string? verticalElement { get; set; }
    // }
}