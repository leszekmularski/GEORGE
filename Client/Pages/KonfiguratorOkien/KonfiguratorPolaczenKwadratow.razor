@page "/KonfiguratorPolaczenKwadratow"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@inject HttpClient Http
@using AntDesign
@inject IMessageService _message
@inject INotificationService _notice
@inject Utilities.ILocalStorage LocalStorage
@using System.Net
@using System.Xml
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject DxfService DxfService
@inject DxfToSvgConverter Converter
@inject NavigationManager NavigationManager

<style>
    .scaled-svg-container {
        width: 100%;
        height: 600px;
        overflow: auto;
        border: 1px solid #ddd;
        background-color: #f8f9fa;
        position: relative;
    }

    .scaled-svg {
        display: block;
        margin: auto;
        background-color: white;
        box-shadow: 0 0 8px rgba(0,0,0,0.1);
        width: 600px;
        height: 600px;
        box-sizing: border-box;
    }

    .controls-container {
        z-index: 100;
        position: relative;
        background: white;
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }

    .model-list {
        max-height: 600px;
        overflow-y: auto;
        border: 1px solid #eee;
        border-radius: 4px;
    }

    .side-checkboxes {
        display: flex;
        gap: 15px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .side-checkbox {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .model-table tr {
        cursor: pointer;
        transition: background-color 0.2s;
    }

        .model-table tr:hover {
            background-color: #f0f7ff;
        }

    .thumbnail-cell {
        width: 70px;
    }

    .status-message {
        padding: 8px;
        margin-bottom: 10px;
        border-radius: 4px;
        background: #e9f7fe;
        color: #1890ff;
    }

    .btn-move {
        width: 32px;
        height: 32px;
        padding: 0;
    }

    .scaled-svg {
        cursor: crosshair; /* Zmień kursor podczas pomiaru */
    }

    .measurement-line {
        stroke: red;
        stroke-width: 2;
        stroke-dasharray: 5,5;
    }

    .measurement-text {
        fill: red;
        font-size: 12px;
        font-family: Arial, sans-serif;
        user-select: none;
    }
</style>

<script>
    // 🧠 Inicjalizacja namespace i stanu zoomLevel
    let activScale = 1;
    window.svgHelper = window.svgHelper || {};
    window.svgHelper.zoomLevel = window.svgHelper.zoomLevel || 1;

    // 🔄 Centrowanie i dopasowanie SVG do kontenera
    window.svgHelper.centerAndFit = function() {
        const svg = document.querySelector(".scaled-svg");
        const container = document.querySelector(".scaled-svg-container");
        const svgContent = svg?.querySelector("#zoom-group");

        if (!svg || !container || !svgContent) return;

        // Reset transformacji do obliczenia bounding box
        const prevTransform = svgContent.getAttribute("transform") || "";
        svgContent.setAttribute("transform", "");

        const bbox = svgContent.getBBox();
        svgContent.setAttribute("transform", prevTransform);

        const svgWidth = svg.clientWidth;
        const svgHeight = svg.clientHeight;

        const scale = Math.min(
            svgWidth / (bbox.width + 50),
            svgHeight / (bbox.height + 50)
        ) * 0.95;

        const offsetX = (svgWidth - bbox.width * scale) / 2 - bbox.x * scale;
        const offsetY = (svgHeight - bbox.height * scale) / 2 - bbox.y * scale;

        activScale = scale;

        svgContent.setAttribute("transform",
            `translate(${offsetX}, ${offsetY}) scale(${scale})`);
        window.svgHelper.zoomLevel = scale;

        activScale = scale;
    };

    // 🔁 Obrót tylko drugiego modelu
    window.svgHelper.rotateSecondModel = function() {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";

        // Wyodrębnij aktualne przesunięcie
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        // Wyodrębnij aktualny kąt obrotu
        const rotateMatch = currentTransform.match(/rotate\(([-\d.]+)/);
        const currentAngle = rotateMatch ? parseFloat(rotateMatch[1]) : 0;
        const newAngle = (currentAngle + 90) % 360;

        // Oblicz środek modelu
        const bbox = model2.getBBox();
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;

        // Zastosuj nową transformację
        model2.setAttribute("transform", `${translate} rotate(${newAngle}, ${cx}, ${cy})`);
    };

    // 📌 Przesuń
        window.svgHelper.move = function(dx, dy) {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);

        let x = 0, y = 0;
        if (translateMatch) {
            [x, y] = translateMatch[1].split(',').map(Number);
        }

        // Aktualizuj pozycję z uwzględnieniem skali
        const scale = window.svgHelper.zoomLevel || 1;
        x += dx / scale;
        y += dy / scale;

        // Zachowaj obrót jeśli istnieje
        const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);
        const rotate = rotateMatch ? ` rotate(${rotateMatch[1]})` : "";

        model2.setAttribute("transform", `translate(${x}, ${y})${rotate}`);

        // Zwróć aktualną pozycję (opcjonalnie)
        return { x: x * scale, y: y * scale };
    };


    // 🔍 Powiększenie z centrowaniem
    window.svgHelper.zoomIn = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale * 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🔍 Pomniejszenie z centrowaniem
    window.svgHelper.zoomOut = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale / 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🛠️ Zastosowanie aktualnego zoomLevel do całego SVG
    window.svgHelper.applyZoom = function () {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const current = group.getAttribute("transform") || "";
        const translateMatch = current.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        group.setAttribute("transform", `${translate} scale(${window.svgHelper.zoomLevel})`);
    };

        // 📏 Inicjalizacja pomiaru
    window.svgHelper.initMeasurement = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        let startPoint = null;
        let measurementLine = null;
        let measurementText = null;

        // Tworzymy elementy do pomiaru
        const createMeasurementElements = () => {
            measurementLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            measurementLine.setAttribute("stroke", "red");
            measurementLine.setAttribute("stroke-width", "2");
            measurementLine.setAttribute("stroke-dasharray", "5,5");

            measurementText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            measurementText.setAttribute("fill", "red");
            measurementText.setAttribute("font-size", "22");

            svg.querySelector("svg").appendChild(measurementLine);
            svg.querySelector("svg").appendChild(measurementText);
        };

        // Usuwamy elementy pomiaru
        const removeMeasurementElements = () => {
            if (measurementLine && measurementLine.parentNode) {
                measurementLine.parentNode.removeChild(measurementLine);
            }
            if (measurementText && measurementText.parentNode) {
                measurementText.parentNode.removeChild(measurementText);
            }
        };

        // Obliczamy odległość między punktami
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        // Aktualizujemy linię i tekst pomiaru
        const updateMeasurement = (x1, y1, x2, y2) => {
            if (!measurementLine || !measurementText) return;

            const distance = calculateDistance(x1, y1, x2, y2) / activScale;
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;

            measurementLine.setAttribute("x1", x1);
            measurementLine.setAttribute("y1", y1);
            measurementLine.setAttribute("x2", x2);
            measurementLine.setAttribute("y2", y2);

            measurementText.setAttribute("x", midX);
            measurementText.setAttribute("y", midY);
            measurementText.textContent = distance.toFixed(2) + " mm";
        };

        // Obsługa kliknięć
        svg.addEventListener("click", (e) => {
            if (!startPoint) {
                // Pierwsze kliknięcie - punkt startowy
                startPoint = {
                    x: e.offsetX,
                    y: e.offsetY
                };
                createMeasurementElements();
            } else {
                // Drugie kliknięcie - punkt końcowy
                updateMeasurement(startPoint.x, startPoint.y, e.offsetX, e.offsetY);
                startPoint = null;

                // Automatyczne usunięcie po 5 sekundach
                setTimeout(() => {
                    removeMeasurementElements();
                }, 5000);
            }
        });
    };

    // 🔄 Wyczyść pomiary
    window.svgHelper.clearMeasurements = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        const lines = svg.querySelectorAll("line[stroke='red']");
        const texts = svg.querySelectorAll("text[fill='red']");

        lines.forEach(line => line.parentNode?.removeChild(line));
        texts.forEach(text => text.parentNode?.removeChild(text));
    };


    // 📐 Ulepszona funkcja pomiaru przesunięcia prowadnic
    // Wywołaj tę funkcję po załadowaniu SVG
    window.svgHelper.initGuideLines = function () {
        const svgEl = document.querySelector(".scaled-svg svg");
        if (!svgEl) {
            console.error("[initGuideLines] Nie znaleziono <svg>");
            return;
        }

        const models = ["#model1", "#model2"];
        models.forEach((modelId) => {
            const model = svgEl.querySelector(modelId);
            if (!model) {
                console.warn(`[initGuideLines] Nie znaleziono ${modelId}`);
                return;
            }

            const guides = model.querySelectorAll('[data-name^="guide-line-"]');
            console.log(`[initGuideLines] ${modelId} - znaleziono prowadnic: ${guides.length}`);

            guides.forEach(el => {
                const bbox = el.getBBox();
                const pt = svgEl.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;

                const ctm = el.getCTM();
                if (!ctm) {
                    console.warn(`[initGuideLines] Brak CTM dla`, el);
                    return;
                }

                const transformed = pt.matrixTransform(ctm);

                if (el.getAttribute('data-name')?.includes('horizontal')) {
                    el.setAttribute('data-original-y', transformed.y.toString());
                } else {
                    el.setAttribute('data-original-x', transformed.x.toString());
                }
            });
        });
    };

    window.svgHelper.measureGuideDisplacement = function () {
        try {
            const svg = document.querySelector(".scaled-svg > svg");
            if (!svg) {
                console.error("SVG container not found");
                return null;
            }

            const model1 = svg.querySelector("#model1");
            const model2 = svg.querySelector("#model2");

            if (!model1 || !model2) {
                console.error("Nie znaleziono obu modeli");
                return null;
            }

            const findGuide = (model, name) => {
                return model.querySelector(`[data-name="${name}"]`) ||
                       model.querySelector(`[name="${name}"]`);
            };

            const guideHorizontalModel1 = findGuide(model1, 'guide-line-horizontalMax');
            const guideVerticalModel1 = findGuide(model1, 'guide-line-vertical');
            const guideHorizontalModel2 = findGuide(model2, 'guide-line-horizontalMax');
            const guideVerticalModel2 = findGuide(model2, 'guide-line-vertical');

            if (!guideHorizontalModel1 || !guideVerticalModel1 ||
                !guideHorizontalModel2 || !guideVerticalModel2) {
                console.warn("Nie znaleziono wszystkich prowadnic");
                return null;
            }

            const getTransformedCenter = (el) => {
                const bbox = el.getBBox();
                const pt = svg.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;
                const ctm = el.getCTM();
                return pt.matrixTransform(ctm);
            };

            const centerH1 = getTransformedCenter(guideHorizontalModel1);
            const centerV1 = getTransformedCenter(guideVerticalModel1);
            const centerH2 = getTransformedCenter(guideHorizontalModel2);
            const centerV2 = getTransformedCenter(guideVerticalModel2);

            const displacementX = (centerV2.x - centerV1.x) / window.svgHelper.zoomLevel;
            const displacementY = (centerH2.y - centerH1.y) / window.svgHelper.zoomLevel;

            return {
                success: true,
                elementsFound: true,
                przesuniecieX: displacementX,
                przesuniecieY: displacementY,
                scale: window.svgHelper.zoomLevel
            };
        } catch (error) {
            console.error("Measurement error:", error);
            return {
                success: false,
                error: error.message
            };
        }
    };

        window.svgHelper.exportCleanedSvgAsPng = function () {
        return new Promise((resolve) => {
            const svgElement = document.querySelector(".scaled-svg svg");
            if (!svgElement) {
                console.warn("Brak SVG do eksportu");
                resolve("");
                return;
            }

            const clone = svgElement.cloneNode(true);

            // Usuń prowadnice
            clone.querySelectorAll('[data-name^="guide-line-"]').forEach(el => el.remove());

            // Serializacja SVG
            const svgString = new XMLSerializer().serializeToString(clone);
            const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function () {
                const canvas = document.createElement("canvas");
                canvas.width = 600;
                canvas.height = 600;
                const ctx = canvas.getContext("2d");
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                const pngData = canvas.toDataURL("image/png");
                resolve(pngData);
            };
            img.onerror = () => resolve("");
            img.src = url;
        });
    };

</script>


<div class="container-fluid mt-3">
    <div class="row mb-3">
        <div class="col">
            <div class="d-flex align-items-center gap-3">
                <Tooltip Placement="@Placement.TopRight" Title="Wróć do poprzedniej strony">
                    <Button class="btn btn-outline-secondary" Icon="@IconType.Fill.Backward" 
                            Style="width: 35px;" OnClick="GoBack" />
                </Tooltip>

                <div class="flex-grow-1">
                    <label class="form-label">Wybierz system:</label>
                    <select class="form-select" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-4">
            <div class="model-list">
                @if (ListaModeli != null && ListaModeli.Any())
                {
                    <div class="side-checkboxes">
                        <div class="side-checkbox">
                            <input type="checkbox" @bind="selDol" id="str_dol" />
                            <label for="str_dol">Dół</label>
                        </div>
                        <div class="side-checkbox">
                            <input type="checkbox" @bind="selGora" id="str_gora" />
                            <label for="str_gora">Góra</label>
                        </div>
                        <div class="side-checkbox">
                            <input type="checkbox" @bind="selLewa" id="str_lewa" />
                            <label for="str_lewa">Lewa</label>
                        </div>
                        <div class="side-checkbox">
                            <input type="checkbox" @bind="selPrawa" id="str_prawa" />
                            <label for="str_prawa">Prawa</label>
                        </div>
                    </div>

                    <table class="table model-table">
                        <thead>
                            <tr>
                                <th>Nazwa</th>
                                <th>Typ</th>
                                <th class="thumbnail-cell">Miniaturka</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var model in ListaModeli)
                            {
                                <tr @onclick="() => WybierzModel(model, selDol, selGora, selLewa, selPrawa)">
                                    <td>@model.NazwaKonfiguracji</td>
                                    <td>@model.Typ</td>
                                    <td>
                                        @if (model.Rysunek?.Length > 0)
                                        {
                                            <img src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)" 
                                                 width="60" height="60" />
                                        }
                                        else
                                        {
                                            <span class="text-muted">Brak</span>
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
                else
                {
                    <div class="alert alert-info">Brak zapisanych modeli.</div>
                }
            </div>
        </div>

        <div class="col-md-8">
            <div class="controls-container">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <Tooltip Title="Zapisz ustawienia">
                            <Button Icon="@IconType.Fill.Save" OnClick="SaveAllPosition" Class="btn btn-primary me-2">
                                Zapisz
                            </Button>
                        </Tooltip>
                    </div>
                    
                    <div class="btn-group">
                        <Tooltip Title="Obróć drugi model">
                            <Button Icon="@IconType.Outline.Loading" OnClick="RotateObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Przesuń w lewo (1px)">
                            <Button Icon="@IconType.Outline.ArrowLeft" OnClick="MoveLeftObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Przesuń w prawo (1px)">
                            <Button Icon="@IconType.Outline.ArrowRight" OnClick="MoveRightObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Przesuń w górę (1px)">
                            <Button Icon="@IconType.Outline.ArrowUp" OnClick="MoveUpObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Przesuń w dół (1px)">
                            <Button Icon="@IconType.Outline.ArrowDown" OnClick="MoveDownObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Dopasuj widok">
                            <Button Icon="@IconType.Outline.Windows" OnClick="ZoomAllObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Powiększ">
                            <Button Icon="@IconType.Outline.ZoomIn" OnClick="ZoomInObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Pomniejsz">
                            <Button Icon="@IconType.Outline.ZoomOut" OnClick="ZoomOutObj" Class="btn-sm btn-move" />
                        </Tooltip>
                        <label class="ms-2">Precyzja przesuwania:</label>
                        <AntDesign.InputNumber @bind-Value="precyzjaPrzesuwania" Min="0" Max="20" Style="width: 60px;" />

                        <Tooltip Title="Pomiar odległości">
                            <Button Icon="@IconType.Outline.Scan" OnClick="StartMeasurement" Class="btn-sm btn-move" />
                        </Tooltip>
                        <Tooltip Title="Wyczyść pomiary">
                            <Button Icon="@IconType.Outline.Close" OnClick="ClearMeasurements" Class="btn-sm btn-move" />
                        </Tooltip>
                    </div>
                </div>
            </div>

            <div class="mb-2 d-flex justify-content-between">
                <h6>Podgląd połączenia</h6>
                <div>
                    <Button Icon="@IconType.Outline.Fire" OnClick="RefreshSvg" Class="btn-sm me-2">
                        Odśwież
                    </Button>
                    <Button Icon="@IconType.Outline.Clear" OnClick="DelSvg" Class="btn-sm btn-danger">
                        Wyczyść
                    </Button>
                </div>
            </div>

            @if (pierwszyModel != null || drugiModel != null)
            {
                <div class="status-message">
                    @if (pierwszyModel != null && drugiModel == null)
                    {
                        <span>Pierwszy model wybrany: <strong>@pierwszyModel.Nazwa</strong></span>
                    }
                    else if (pierwszyModel != null && drugiModel != null)
                    {
                        <span>Połączono: <strong>@pierwszyModel.Nazwa</strong> z <strong>@drugiModel.Nazwa</strong></span>
                    }
                </div>
            }

            <div class="scaled-svg-container">
                @if (!string.IsNullOrEmpty(combinedSvg))
                {
                    <div class="scaled-svg" @key="SvgKey">
                        @((MarkupString)combinedSvg)
                    </div>
                }
                else
                {
                    <div class="d-flex flex-column justify-content-center align-items-center h-100">
                        <div class="alert alert-info mb-3">
                            Wybierz modele ramy, skrzydła lub poprzeczki
                        </div>
                        @if (!string.IsNullOrEmpty(BladKonfiguracji))
                        {
                            <div class="alert alert-warning">
                                @BladKonfiguracji
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    [Inject] private AppState AppState { get; set; } = default!;

    // Dane i stan
    private string SvgKey { get; set; } = Guid.NewGuid().ToString();
    private List<SystemyOkienne> Systemy = new();
    private string? SelectedSystemId;
    private List<KonfModele>? ListaModeli;
    private List<KonfSystem>? KonfiguracjeSystemu;
    private float precyzjaPrzesuwania = 5;
    private string BladKonfiguracji = string.Empty;

    // Wybór stron
    private bool selDol = false;
    private bool selGora = false;
    private bool selLewa = false;
    private bool selPrawa = false;

    // Modele SVG
    private KonfSystem? pierwszyModel;
    private KonfSystem? drugiModel;
    private string combinedSvg = string.Empty;
    private double offsetX = 0;
    private double offsetY = 0;
    private double luzLewo = 50;  // Zwiększony luz
    private double luzPrawo = 50;
    private double luzGora = 50;
    private double luzDol = 50;

    private double przesuniecieX;
    private double przesuniecieY;
    private int katUstawienia = 0;
    // Inicjalizacja
    protected override async Task OnInitializedAsync()
    {
        await Laduj_Uprawnienia();
        Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne") ?? new();
    }

    // Obsługa wyboru systemu
    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value?.ToString();
        if (string.IsNullOrEmpty(SelectedSystemId)) return;

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}") ?? new();
        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}") ?? new();
    }

    // Wybór modelu
    private async Task WybierzModel(KonfModele model, bool stronaDol, bool stronaGora, bool stronaLewa, bool stronaPrawa)
    {

        if(!selDol && !selGora && !selLewa && !selPrawa)
        {
            BladKonfiguracji = "Wybierz co najmniej jedną stronę (Dół, Góra, Lewa, Prawa).";
            return;
        }

        BladKonfiguracji = "";

        try
        {
            var response = await Http.GetAsync($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{model.RowId}");
            if (!response.IsSuccessStatusCode)
            {
                BladKonfiguracji = $"Błąd: {response.StatusCode}";
                return;
            }

            var result = await response.Content.ReadFromJsonAsync<MVCKonfModele>();
            if (result?.KonfSystem == null || result.KonfSystem.Count == 0)
            {
                BladKonfiguracji = "Brak danych powiązanych";
                return;
            }

            var pasujacy = result.KonfSystem.FirstOrDefault(x =>
                (x.WystepujeDol == stronaDol) ||
                (x.WystepujeGora == stronaGora) ||
                (x.WystepujeLewa == stronaLewa) ||
                (x.WystepujePrawa == stronaPrawa));

            if (pasujacy == null)
            {
                BladKonfiguracji = "Nie znaleziono pasującego elementu. Zmień występowanie elementu.";
                return;
            }

            if (pierwszyModel == null)
            {
                pierwszyModel = pasujacy;
                offsetX = 0; // Resetuj offset
                offsetY = 0; // Resetuj offset

                AktualizujSvg();
            }
            else if (drugiModel == null)
            {
                drugiModel = pasujacy;

                AktualizujSvg();                          // 1. generuj combinedSvg
                await InvokeAsync(StateHasChanged);      // 2. wymuś render Blazora

                await Task.Delay(100);                    // 3. krótka pauza lub: await Task.Yield();
                await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");

            }

            //  AktualizujSvg();

            // Automatyczne dopasowanie po załadowaniu modelu
            //await Task.Delay(100); // daj czas Blazorowi na wyrenderowanie SVG
            //await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");

        }
        catch (Exception ex)
        {
            BladKonfiguracji = $"Błąd: {ex.Message}";
        }
    }

    // Generowanie SVG z większym obszarem roboczym
    private void AktualizujSvg()
    {
        if (pierwszyModel == null && drugiModel == null)
        {
            combinedSvg = "";
            return;
        }

        var svgParts = new List<string>();
        double centerX = 300; // Środek obszaru roboczego (600x600/2)
        double centerY = 300;

        // Obliczanie pozycji dla pierwszego modelu (zawsze na środku)
        if (pierwszyModel != null)
        {
            svgParts.Add($@"<g id=""model1"" transform=""translate({centerX}, {centerY})"">{ExtractInnerSvg(NormalizeSvg(pierwszyModel.SVG))}</g>");
        }

        // Obliczanie pozycji dla drugiego modelu (względem pierwszego z luzem)
        if (drugiModel != null)
        {
            double secondX = centerX + offsetX;
            double secondY = centerY + offsetY;
            svgParts.Add($@"<g id=""model2"" transform=""translate({secondX}, {secondY})"">{ExtractInnerSvg(NormalizeSvg(drugiModel.SVG))}</g>");
        }

        combinedSvg = $@"
        <svg xmlns=""http://www.w3.org/2000/svg"" width=""600"" height=""600"" viewBox=""0 0 600 600"" preserveAspectRatio=""xMidYMid meet"">
            <g id=""zoom-group"">
    {string.Join("", svgParts)}
            </g>
        </svg>";

        string NormalizeSvg(string combinedSvg) =>
        combinedSvg?
        .Replace("id=\"guide-line-horizontalMax\"", "data-name=\"guide-line-horizontalMax\"")
        .Replace("id=\"guide-line-vertical\"", "data-name=\"guide-line-vertical\"")
        .Trim('\uFEFF', '\u200B', '\u0000')
        .Replace("\r", "").Replace("\n", "").Trim() ?? "";


        SvgKey = Guid.NewGuid().ToString();

        // Console.WriteLine($"AktualizujSvg: wygenerowano SVG: {combinedSvg}");
    }

    // Pomocnicze metody do przetwarzania SVG
    private string NormalizeSvg(string svg) => svg?.Trim('\uFEFF', '\u200B', '\u0000').Replace("\r", "").Replace("\n", "").Trim() ?? "";

    private string ExtractInnerSvg(string svg)
    {
        if (string.IsNullOrWhiteSpace(svg)) return "";
        int start = svg.IndexOf('>') + 1;
        int end = svg.LastIndexOf("</svg>", StringComparison.OrdinalIgnoreCase);
        return (start > 0 && end > start) ? svg.Substring(start, end - start).Trim() : svg;
    }

    // Kontrola SVG
    private async Task RefreshSvg()
    {
        AktualizujSvg();
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
        await Task.Delay(100); // 💡 daj czas DOM-owi
        await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");
    }

    private async Task DelSvg()
    {
        pierwszyModel = null;
        drugiModel = null;
        offsetX = 0;
        offsetY = 0;
        BladKonfiguracji = "";
        AktualizujSvg();

        await Task.CompletedTask;   
    }

    // Manipulacja drugim modelem
    private async Task PrzesunDrugiModel(string kierunek)
    {
        if (drugiModel == null) return;

        switch (kierunek)
        {
            case "gora": offsetY -= 1; break;
            case "dol": offsetY += 1; break;
            case "lewo": offsetX -= 1; break;
            case "prawo": offsetX += 1; break;
        }

        AktualizujSvg();
        await Task.Delay(10);
    }

    private async Task MoveLeftObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", -precyzjaPrzesuwania, 0);
    private async Task MoveRightObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", precyzjaPrzesuwania, 0);
    private async Task MoveUpObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, -precyzjaPrzesuwania);
    private async Task MoveDownObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, precyzjaPrzesuwania);
    private async Task ZoomAllObj() => await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
    private async Task GoBack() => await JSRuntime.InvokeVoidAsync("history.back");

    private async Task ZoomInObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomIn");
    private async Task ZoomOutObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomOut");

    private async Task RotateObj()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.rotateSecondModel");

        katUstawienia = (katUstawienia + 90) % 360;
    }

    private async Task StartMeasurement()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
        await JSRuntime.InvokeVoidAsync("svgHelper.initMeasurement");
    }

    private async Task ClearMeasurements()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
    }

    private async Task SaveAllPosition()
    {
        var result = await JSRuntime.InvokeAsync<GuideDisplacementResult>("svgHelper.measureGuideDisplacement");

        if (result?.success == true && result.elementsFound)
        {
            przesuniecieX = result.przesuniecieX;
            przesuniecieY = result.przesuniecieY;

            // Dane do zapisu
            var polaczenie = new KonfPolaczenie
            {
                ElementZewnetrznyId = pierwszyModel?.RowId ?? Guid.Empty,
                ElementWewnetrznyId = drugiModel?.RowId ?? Guid.Empty,
                StronaPolaczenia = WyliczStronePolaczenia(),
                PrzesuniecieX = przesuniecieX,
                PrzesuniecieY = przesuniecieY,
                ZapisanyKat = katUstawienia,
                RysunekPrzekroju = await GenerujPngBezProwadnic()
            };

            // Szukaj rekordu w bazie
            var existing = await Http.GetFromJsonAsync<KonfPolaczenie?>(
                $"api/konfpolaczenie/find-by-elements/{polaczenie.ElementZewnetrznyId}/{polaczenie.ElementWewnetrznyId}");

            HttpResponseMessage response;

            if (existing is not null)
            {
                // Aktualizacja
                polaczenie.RowId = existing.RowId;
                polaczenie.Id = existing.Id;

                response = await Http.PutAsJsonAsync("api/konfpolaczenie", polaczenie);
            }
            else
            {
                // Nowy wpis
                response = await Http.PostAsJsonAsync("api/konfpolaczenie", polaczenie);
            }

            if (response.IsSuccessStatusCode)
            {
                await _message.Success($"✅ Zapisano pozycję: X={przesuniecieX:F2} mm, Y={przesuniecieY:F2} mm (skala: {result.scale:F2}), Kąt: {katUstawienia}°");
            }
            else
            {
                await _message.Error("❌ Błąd zapisu konfiguracji połączenia");
            }
        }
        else
        {
            await _message.Warning(result?.error ?? "❗ Nie można znaleźć prowadnic w rysunku SVG");
        }
    }

    private async Task<byte[]> GenerujPngBezProwadnic()
    {
        // Poproś JS o wygenerowanie PNG bez prowadnic
        string base64 = await JSRuntime.InvokeAsync<string>("svgHelper.exportCleanedSvgAsPng");

        if (string.IsNullOrWhiteSpace(base64))
            return Array.Empty<byte>();

        return Convert.FromBase64String(base64.Replace("data:image/png;base64,", ""));
    }

    private string WyliczStronePolaczenia()
    {
        var strony = new List<string>();
        if (selLewa) strony.Add("lewa");
        if (selPrawa) strony.Add("prawa");
        if (selGora) strony.Add("góra");
        if (selDol) strony.Add("dół");

        return string.Join(", ", strony);
    }


    // Uprawnienia
    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");
        if (string.IsNullOrEmpty(user)) return;

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/KonfPolaczenie");
            if (uprawnienia?.Count > 0)
            {
                var szuk = uprawnienia.FirstOrDefault(x => x.TableName == "KonfPolaczenie");
                if (szuk != null)
                {
                    boolOdczyt = szuk.Odczyt;
                    boolZmiana = szuk.Zmiana;
                    boolUsuniecia = szuk.Usuniecie;
                    boolAdmin = szuk.Administrator;
                    boolNowy = szuk.Zapis;
                    RowIdPracownika = szuk.RowId;
                }
            }
        }
        catch (Exception ex)
        {
            await _message.Error($"Błąd ładowania uprawnień: {ex.Message}");
        }
    }

    public class GuideDisplacementResult
    {
        public bool success { get; set; }
        public bool elementsFound { get; set; }
        public double przesuniecieX { get; set; }
        public double przesuniecieY { get; set; }
        public double scale { get; set; }
        public string? error { get; set; } // opcjonalnie
    }

    // public class GuideDisplacementResult
    // {
    //     public bool success { get; set; }
    //     public bool elementsFound { get; set; }
    //     public double horizontalDisplacement { get; set; }
    //     public double verticalDisplacement { get; set; }
    //     public double scale { get; set; }
    //     public string? error { get; set; }
    //     public string? horizontalElement { get; set; }
    //     public string? verticalElement { get; set; }
    // }
}