@page "/KonfiguratorPolaczenKwadratow"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@inject HttpClient Http
@using AntDesign
@inject IMessageService _message
@inject INotificationService _notice
@inject Utilities.ILocalStorage LocalStorage
@using System.Net
@using System.Xml
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject DxfService DxfService
@inject DxfToSvgConverter Converter
@inject NavigationManager NavigationManager

<style>
    .scaled-svg-container {
        width: 100%;
        height: 600px;
        overflow: auto;
        border: 1px solid #ddd;
        background-color: #f8f9fa;
        position: relative;
    }

    .scaled-svg {
        display: block;
        margin: auto;
        background-color: white;
        box-shadow: 0 0 8px rgba(0,0,0,0.1);
        width: 600px;
        height: 600px;
        box-sizing: border-box;
    }

    .controls-container {
        z-index: 100;
        position: relative;
        background: white;
        padding: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 15px;
    }

    .model-list {
        max-height: 600px;
        overflow-y: auto;
        border: 1px solid #eee;
        border-radius: 4px;
    }

    .side-checkboxes {
        display: flex;
        gap: 15px;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .side-checkbox {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .model-table tr {
        cursor: pointer;
        transition: background-color 0.2s;
    }

        .model-table tr:hover {
            background-color: #f0f7ff;
        }

    .thumbnail-cell {
        width: 70px;
    }

    .status-message {
        padding: 8px;
        margin-bottom: 10px;
        border-radius: 4px;
        background: #e9f7fe;
        color: #1890ff;
    }

    .btn-move {
        width: 32px;
        height: 32px;
        padding: 0;
    }

    .scaled-svg {
        cursor: crosshair; /* Zmień kursor podczas pomiaru */
    }

    .measurement-line {
        stroke: red;
        stroke-width: 2;
        stroke-dasharray: 5,5;
    }

    .measurement-text {
        fill: red;
        font-size: 12px;
        font-family: Arial, sans-serif;
        user-select: none;
    }
</style>

<script>
    // 🧠 Inicjalizacja namespace i stanu zoomLevel
    let activScale = 1;
    window.svgHelper = window.svgHelper || {};
    window.svgHelper.zoomLevel = window.svgHelper.zoomLevel || 1;

    // 🔄 Centrowanie i dopasowanie SVG do kontenera
    window.svgHelper.centerAndFit = function() {
        const svg = document.querySelector(".scaled-svg");
        const container = document.querySelector(".scaled-svg-container");
        const svgContent = svg?.querySelector("#zoom-group");

        if (!svg || !container || !svgContent) return;

        // Reset transformacji do obliczenia bounding box
        const prevTransform = svgContent.getAttribute("transform") || "";
        svgContent.setAttribute("transform", "");

        const bbox = svgContent.getBBox();
        svgContent.setAttribute("transform", prevTransform);

        const svgWidth = svg.clientWidth;
        const svgHeight = svg.clientHeight;

        const scale = Math.min(
            svgWidth / (bbox.width + 50),
            svgHeight / (bbox.height + 50)
        ) * 0.95;

        const offsetX = (svgWidth - bbox.width * scale) / 2 - bbox.x * scale;
        const offsetY = (svgHeight - bbox.height * scale) / 2 - bbox.y * scale;

        activScale = scale;

        svgContent.setAttribute("transform",
            `translate(${offsetX}, ${offsetY}) scale(${scale})`);
        window.svgHelper.zoomLevel = scale;

        activScale = scale;
    };

    // 🔁 Obrót tylko drugiego modelu
    window.svgHelper.rotateSecondModel = function() {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";

        // Wyodrębnij aktualne przesunięcie
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        // Wyodrębnij aktualny kąt obrotu
        const rotateMatch = currentTransform.match(/rotate\(([-\d.]+)/);
        const currentAngle = rotateMatch ? parseFloat(rotateMatch[1]) : 0;
        const newAngle = (currentAngle + 90) % 360;

        // Oblicz środek modelu
        const bbox = model2.getBBox();
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;

        // Zastosuj nową transformację
        model2.setAttribute("transform", `${translate} rotate(${newAngle}, ${cx}, ${cy})`);
    };

    // ✅ Bezpieczne tworzenie #models-group (naprawia błąd 'ancestor' i znika rysunek)
    window.svgHelper.ensureModelsGroup = function() {
        try {
            const zoomGroup = document.querySelector(".scaled-svg svg #zoom-group") ||
                              document.querySelector(".scaled-svg #zoom-group");
            if (!zoomGroup) {
                console.warn("[ensureModelsGroup] Brak #zoom-group");
                return null;
            }

            // 1) Zbierz kandydatów PRZED utworzeniem grupy (TYLKO elementy z id "model" + cyfra)
            //    -> regex /^model\d+/ zabezpiecza przed 'models-group'
            const candidates = Array.from(zoomGroup.children)
                .filter(el => el.id && /^model\d+/.test(el.id));

            // 2) Jeśli grupa już jest, zwróć ją
            let group = zoomGroup.querySelector("#models-group");
            if (!group) {
                // 3) Stwórz grupę i wstaw ją (teraz, po zebraniu kandydatów)
                group = document.createElementNS("http://www.w3.org/2000/svg", "g");
                group.setAttribute("id", "models-group");
                zoomGroup.insertBefore(group, zoomGroup.firstChild);
            }

            // 4) Przenieś zebrane elementy do grupy (nie będzie tu już 'models-group' w candidates)
            candidates.forEach(m => group.appendChild(m));

            console.log("[ensureModelsGroup] Przeniesiono do #models-group:", candidates.map(m => m.id));
            return group;
        } catch (e) {
            console.error("[ensureModelsGroup] błąd:", e);
            return null;
        }
    };

    // 🔁 Bezpieczny obrót całej grupy modeli o 90°
    window.svgHelper.rotateAllModel = function () {
        try {
            const group = window.svgHelper.ensureModelsGroup();
            if (!group) {
                console.warn("[rotateAllModel] Nie można uzyskać #models-group");
                return;
            }

            const currentTransform = group.getAttribute("transform") || "";

            // zachowaj translate (jeśli jest)
            const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
            const translate = translateMatch ? `translate(${translateMatch[1]})` : "";

            // odczytaj aktualny kąt (jeśli jest)
            const rotateMatch = currentTransform.match(/rotate\(([-\d.]+)/);
            const currentAngle = rotateMatch ? parseFloat(rotateMatch[1]) : 0;
            const newAngle = (currentAngle + 90) % 360;

            // środek grupy (bbox)
            const bbox = group.getBBox();
            const cx = bbox.x + bbox.width / 2;
            const cy = bbox.y + bbox.height / 2;

            group.setAttribute("transform", `${translate} rotate(${newAngle}, ${cx}, ${cy})`);
            console.log(`[rotateAllModel] Obrócono grupę do ${newAngle}° wokół (${cx.toFixed(1)}, ${cy.toFixed(1)})`);
        } catch (e) {
            console.error("[rotateAllModel] błąd:", e);
        }
    };

    // 🔁 Lustrzane odbicie wszystkich modeli w poziomie względem środka SVG
    window.svgHelper.flipAllModelsHorizontally = function () {
        try {
            const group = window.svgHelper.ensureModelsGroup();
            if (!group) {
                console.warn("[flipAllModelsHorizontally] Nie można uzyskać #models-group");
                return;
            }

            // Pobierz rozmiar SVG
            const svg = document.querySelector(".scaled-svg svg");
            if (!svg) {
                console.warn("[flipAllModelsHorizontally] Nie znaleziono <svg>");
                return;
            }

            const viewBox = svg.viewBox.baseVal;
            const centerY = viewBox.y + viewBox.height / 2;

            // Pobierz aktualny transform
            const currentTransform = group.getAttribute("transform") || "";

            // Odbicie względem osi poziomej (środek SVG w osi Y)
            const flipTransform = `translate(0, ${2 * centerY}) scale(1, -1)`;

            // Zastosuj
            group.setAttribute("transform", `${currentTransform} ${flipTransform}`);

            console.log(`[flipAllModelsHorizontally] Odbito względem poziomej osi SVG przy y=${centerY}`);
        } catch (e) {
            console.error("[flipAllModelsHorizontally] błąd:", e);
        }
    };


    // 📌 Przesuń
        window.svgHelper.move = function(dx, dy) {
        const model2 = document.querySelector("#model2");
        if (!model2) return;

        const currentTransform = model2.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);

        let x = 0, y = 0;
        if (translateMatch) {
            [x, y] = translateMatch[1].split(',').map(Number);
        }

        // Aktualizuj pozycję z uwzględnieniem skali
        const scale = window.svgHelper.zoomLevel || 1;
        x += dx / scale;
        y += dy / scale;

        // Zachowaj obrót jeśli istnieje
        const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);
        const rotate = rotateMatch ? ` rotate(${rotateMatch[1]})` : "";

        model2.setAttribute("transform", `translate(${x}, ${y})${rotate}`);

        // Zwróć aktualną pozycję (opcjonalnie)
        return { x: x * scale, y: y * scale };
    };


    // 🔍 Powiększenie z centrowaniem
    window.svgHelper.zoomIn = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale * 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🔍 Pomniejszenie z centrowaniem
    window.svgHelper.zoomOut = function() {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const currentTransform = group.getAttribute("transform") || "";
        const translateMatch = currentTransform.match(/translate\(([^)]+)\)/);
        const scaleMatch = currentTransform.match(/scale\(([^)]+)\)/);

        let [translateX, translateY] = translateMatch ?
            translateMatch[1].split(',').map(Number) : [0, 0];
        const currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

        const newScale = currentScale / 1.1;
        const scaleRatio = newScale / currentScale;

        // Skoryguj przesunięcie, aby zachować centrowanie
        const svg = document.querySelector(".scaled-svg");
        if (svg) {
            const centerX = svg.clientWidth / 2;
            const centerY = svg.clientHeight / 2;
            translateX = centerX - (centerX - translateX) * scaleRatio;
            translateY = centerY - (centerY - translateY) * scaleRatio;
        }

        group.setAttribute("transform",
            `translate(${translateX}, ${translateY}) scale(${newScale})`);
        window.svgHelper.zoomLevel = newScale;

        activScale = newScale;
    };

    // 🛠️ Zastosowanie aktualnego zoomLevel do całego SVG
    window.svgHelper.applyZoom = function () {
        const group = document.querySelector("#zoom-group");
        if (!group) return;

        const current = group.getAttribute("transform") || "";
        const translateMatch = current.match(/translate\(([^)]+)\)/);
        const translate = translateMatch ? translateMatch[0] : "translate(0, 0)";

        group.setAttribute("transform", `${translate} scale(${window.svgHelper.zoomLevel})`);
    };

        // 📏 Inicjalizacja pomiaru
    window.svgHelper.initMeasurement = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        let startPoint = null;
        let measurementLine = null;
        let measurementText = null;

        // Tworzymy elementy do pomiaru
        const createMeasurementElements = () => {
            measurementLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            measurementLine.setAttribute("stroke", "red");
            measurementLine.setAttribute("stroke-width", "2");
            measurementLine.setAttribute("stroke-dasharray", "5,5");

            measurementText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            measurementText.setAttribute("fill", "red");
            measurementText.setAttribute("font-size", "22");

            svg.querySelector("svg").appendChild(measurementLine);
            svg.querySelector("svg").appendChild(measurementText);
        };

        // Usuwamy elementy pomiaru
        const removeMeasurementElements = () => {
            if (measurementLine && measurementLine.parentNode) {
                measurementLine.parentNode.removeChild(measurementLine);
            }
            if (measurementText && measurementText.parentNode) {
                measurementText.parentNode.removeChild(measurementText);
            }
        };

        // Obliczamy odległość między punktami
        const calculateDistance = (x1, y1, x2, y2) => {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };

        // Aktualizujemy linię i tekst pomiaru
        const updateMeasurement = (x1, y1, x2, y2) => {
            if (!measurementLine || !measurementText) return;

            const distance = calculateDistance(x1, y1, x2, y2) / activScale;
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;

            measurementLine.setAttribute("x1", x1);
            measurementLine.setAttribute("y1", y1);
            measurementLine.setAttribute("x2", x2);
            measurementLine.setAttribute("y2", y2);

            measurementText.setAttribute("x", midX);
            measurementText.setAttribute("y", midY);
            measurementText.textContent = distance.toFixed(2) + " mm";
        };

        // Obsługa kliknięć
        svg.addEventListener("click", (e) => {
            if (!startPoint) {
                // Pierwsze kliknięcie - punkt startowy
                startPoint = {
                    x: e.offsetX,
                    y: e.offsetY
                };
                createMeasurementElements();
            } else {
                // Drugie kliknięcie - punkt końcowy
                updateMeasurement(startPoint.x, startPoint.y, e.offsetX, e.offsetY);
                startPoint = null;

                // Automatyczne usunięcie po 5 sekundach
                setTimeout(() => {
                    removeMeasurementElements();
                }, 5000);
            }
        });
    };

    // 🔄 Wyczyść pomiary
    window.svgHelper.clearMeasurements = function() {
        const svg = document.querySelector(".scaled-svg");
        if (!svg) return;

        const lines = svg.querySelectorAll("line[stroke='red']");
        const texts = svg.querySelectorAll("text[fill='red']");

        lines.forEach(line => line.parentNode?.removeChild(line));
        texts.forEach(text => text.parentNode?.removeChild(text));
    };


    // 📐 Ulepszona funkcja pomiaru przesunięcia prowadnic
    // Wywołaj tę funkcję po załadowaniu SVG
    window.svgHelper.initGuideLines = function () {
        const svgEl = document.querySelector(".scaled-svg svg");
        if (!svgEl) {
            console.error("[initGuideLines] Nie znaleziono <svg>");
            return;
        }

        const models = ["#model1", "#model2"];
        models.forEach((modelId) => {
            const model = svgEl.querySelector(modelId);
            if (!model) {
                console.warn(`[initGuideLines] Nie znaleziono ${modelId}`);
                return;
            }

            const guides = model.querySelectorAll('[data-name^="guide-line-"]');
            console.log(`[initGuideLines] ${modelId} - znaleziono prowadnic: ${guides.length}`);

            guides.forEach(el => {
                const bbox = el.getBBox();
                const pt = svgEl.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;

                const ctm = el.getCTM();
                if (!ctm) {
                    console.warn(`[initGuideLines] Brak CTM dla`, el);
                    return;
                }

                const transformed = pt.matrixTransform(ctm);

                if (el.getAttribute('data-name')?.includes('horizontal')) {
                    el.setAttribute('data-original-y', transformed.y.toString());
                } else {
                    el.setAttribute('data-original-x', transformed.x.toString());
                }
            });
        });
    };

    window.svgHelper.measureGuideDisplacement = function () {
        try {
            const svg = document.querySelector(".scaled-svg > svg");
            if (!svg) {
                console.error("SVG container not found");
                return null;
            }

            const model1 = svg.querySelector("#model1");
            const model2 = svg.querySelector("#model2");

            if (!model1 || !model2) {
                console.error("Nie znaleziono obu modeli");
                return null;
            }

            const findGuide = (model, name) => {
                return model.querySelector(`[data-name="${name}"]`) ||
                       model.querySelector(`[name="${name}"]`);
            };

            const guideHorizontalModel1 = findGuide(model1, 'guide-line-horizontalMax');
            const guideVerticalModel1 = findGuide(model1, 'guide-line-vertical');
            const guideHorizontalModel2 = findGuide(model2, 'guide-line-horizontalMax');
            const guideVerticalModel2 = findGuide(model2, 'guide-line-vertical');

            if (!guideHorizontalModel1 || !guideVerticalModel1 ||
                !guideHorizontalModel2 || !guideVerticalModel2) {
                console.warn("Nie znaleziono wszystkich prowadnic");
                return null;
            }

            const getTransformedCenter = (el) => {
                const bbox = el.getBBox();
                const pt = svg.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;
                const ctm = el.getCTM();
                return pt.matrixTransform(ctm);
            };

            const centerH1 = getTransformedCenter(guideHorizontalModel1);
            const centerV1 = getTransformedCenter(guideVerticalModel1);
            const centerH2 = getTransformedCenter(guideHorizontalModel2);
            const centerV2 = getTransformedCenter(guideVerticalModel2);

            const scale = window.svgHelper.zoomLevel || 1;

            const displacementX = ((centerV2.x - centerV1.x) / scale);
            const displacementY = ((centerH2.y - centerH1.y) / scale);

            const round2 = (val) => Math.round(val * 100) / 100;

            return {
                success: true,
                elementsFound: true,
                przesuniecieX: round2(displacementX),
                przesuniecieY: round2(displacementY),
                scale: scale
            };
        } catch (error) {
            console.error("Measurement error:", error);
            return {
                success: false,
                error: error.message
            };
        }
    };

    function sanitizeSvg(svgElement) {
        const numericAttributes = [
            "x", "y", "x1", "y1", "x2", "y2", "cx", "cy", "r", "rx", "ry",
            "width", "height", "stroke-width"
        ];

        const walk = (node) => {
            if (node.nodeType !== 1) return;

            // Normalizacja atrybutów liczbowych
            numericAttributes.forEach(attr => {
                if (node.hasAttribute(attr)) {
                    const val = node.getAttribute(attr);
                    const parsed = parseFloat(val);
                    if (!isNaN(parsed)) {
                        node.setAttribute(attr, parsed.toString());
                    }
                }
            });

            // Usuń niepotrzebne atrybuty
            ['data-name', 'data-original-x', 'data-original-y'].forEach(attr => {
                node.removeAttribute(attr);
            });

            // Rekurencyjnie przetwarzaj dzieci
            Array.from(node.children).forEach(walk);
        };

        walk(svgElement);
    }

    window.svgHelper.exportCleanedSvgAsPng = function() {
        return new Promise((resolve) => {
            try {
                console.log("Starting PNG export...");

                // 1. Pobierz elementy SVG
                const svgElement = document.querySelector(".scaled-svg");
                const svgContent = svgElement?.querySelector("#zoom-group");

                if (!svgElement || !svgContent) {
                    console.error("SVG elements not found");
                    resolve("");
                    return;
                }

                // 2. Utwórz głęboką kopię SVG
                const clone = svgElement.cloneNode(true);
                const cloneContent = clone.querySelector("#zoom-group");

                // 3. Usuń niepotrzebne elementy
                const elementsToRemove = [
                    '[data-name^="guide-line-"]',
                    '[id^="guide-line-"]',
                    '.measurement-line',
                    '.measurement-text'
                ].join(',');

                clone.querySelectorAll(elementsToRemove).forEach(el => el.remove());
                console.log("Removed guide elements");

                // 4. Pobierz aktualną transformację
                const currentTransform = svgContent.getAttribute("transform") || "";
                console.log("Current transform:", currentTransform);

                // 5. Przygotuj nowy SVG
                const newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                newSvg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                newSvg.setAttribute("width", "600");
                newSvg.setAttribute("height", "600");
                newSvg.setAttribute("viewBox", "0 0 600 600");

                // 6. Przenieś zawartość ZACHOWUJĄC ORYGINALNĄ TRANSFORMACJĘ
                const contentGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                contentGroup.setAttribute("transform", currentTransform);

                // Przenieś wszystkie dzieci zachowując ich właściwości
                while (cloneContent.firstChild) {
                    contentGroup.appendChild(cloneContent.firstChild);
                }

                newSvg.appendChild(contentGroup);
                console.log("SVG content prepared:", newSvg);

                // 7. Serializacja
                const svgString = new XMLSerializer().serializeToString(newSvg);
                console.log("SVG string length:", svgString.length);

                // 8. Konwersja do obrazka
                const img = new Image();
                img.onload = function() {
                    try {
                        console.log("Image loaded, creating PNG...");
                        const canvas = document.createElement("canvas");
                        canvas.width = 600;
                        canvas.height = 600;
                        const ctx = canvas.getContext("2d");

                        // Białe tło
                        ctx.fillStyle = "#ffffff";
                        ctx.fillRect(0, 0, 1200, 1200);

                        // Renderuj SVG (1:1 bez dodatkowego skalowania)
                        ctx.drawImage(img, 0, 0);

                        const pngData = canvas.toDataURL("image/png");
                        console.log("PNG created successfully");
                        resolve(pngData);
                    } catch (e) {
                        console.error("Canvas error:", e);
                        resolve("");
                    }
                };

                img.onerror = function(e) {
                    console.error("Image load error:", e);
                    console.log("Problematic SVG:", svgString.substring(0, 500));
                    resolve("");
                };

                img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
            } catch (e) {
                console.error("Export error:", e);
                resolve("");
            }
        });
    };

    window.svgHelper.resetModel2Position = function() {
    const svg = document.querySelector(".scaled-svg > svg");
    const model2 = svg?.querySelector("#model2");
    if (model2) model2.setAttribute("transform", "translate(0,0)");
    };

    window.svgHelper.getModel2Displacement = function () {
        try {
            const svg = document.querySelector(".scaled-svg > svg");
            if (!svg) {
                console.error("getModel2Displacement: SVG not found");
                return { success: false, przesuniecieX: 0, przesuniecieY: 0 };
            }

            const model1 = svg.querySelector("#model1");
            const model2 = svg.querySelector("#model2");

            if (!model1 || !model2) {
                console.error("getModel2Displacement: one or both models not found");
                return { success: false, przesuniecieX: 0, przesuniecieY: 0 };
            }

            const rect1 = model1.querySelector("rect") || model1.getBBox?.() ? model1 : null;
            const rect2 = model2.querySelector("rect") || model2.getBBox?.() ? model2 : null;

            if (!rect1 || !rect2) {
                console.error("getModel2Displacement: rect elements not found");
                return { success: false, przesuniecieX: 0, przesuniecieY: 0 };
            }

            const getTransformedCenter = (el) => {
                const bbox = el.getBBox();
                const pt = svg.createSVGPoint();
                pt.x = bbox.x + bbox.width / 2;
                pt.y = bbox.y + bbox.height / 2;
                const ctm = el.getCTM();
                return pt.matrixTransform(ctm);
            };

            const c1 = getTransformedCenter(model1);
            const c2 = getTransformedCenter(model2);

            const scale = window.svgHelper.zoomLevel || 1;

            const dx = (c2.x - c1.x) / scale;
            const dy = (c2.y - c1.y) / scale;

            console.log(`📏 Displacement względem model1: X=${dx.toFixed(2)}, Y=${dy.toFixed(2)}`);

            return {
                success: true,
                przesuniecieX: dx,
                przesuniecieY: dy
            };
        } catch (e) {
            console.error("getModel2Displacement error:", e);
            return { success: false, przesuniecieX: 0, przesuniecieY: 0, error: e.message };
        }
    };




</script>

<div class="container-fluid mt-3">
    <div class="row mb-3">
        <div class="col">
            <div class="d-flex align-items-center gap-3">

                <div class="flex-grow-1">
                    <label class="form-label">Wybierz system:</label>
                    <select class="form-select" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                </div>

                <Tooltip Placement="@Placement.TopRight" Title="Wróć do poprzedniej strony">
                    <Button class="btn btn-outline-secondary" Icon="@IconType.Fill.Backward"
                            Style="width: 35px;" OnClick="GoBack" />
                </Tooltip>
            </div>
        </div>
    </div>
    <Tabs OnChange="OnTabChange">
        <TabPane Key="0" Tab="Istniejące konfiguracje">
            <h4>
                Lista zapisanych połączeń (@(listaPolaczen?.Count() ?? 0))
                <Button Icon="@IconType.Outline.Read" OnClick="OdswiezDane" />
            </h4>

            @if (listaPolaczen == null)
            {
                <p><em>Wybierz system i poczekaj na załadowanie danych...</em></p>
            }
            else if (!listaPolaczen.Any())
            {
                <p><strong>Brak zapisanych połączeń.</strong></p>
            }
            else
            {
                <table class="table table-bordered table-striped">
                    <thead class="table-light">
                        <tr>
                            <th>Rysunek</th>
                            <th>Opis</th>
                            <th>Strona</th>
                            <th>X [mm]</th>
                            <th>Y [mm]</th>
                            <th>Kąt [°]</th>
                            <th>Akcja</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var polaczenie in listaPolaczen)
                        {
                            <tr>
                                <td>
                                    @if (polaczenie.RysunekPrzekroju?.Length > 20 && polaczenie.RysunekPrzekrojuStyczny?.Length > 20)
                                    {

                                        <a target="_blank" href="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)">
                                            <img title="zew:@polaczenie.ElementZewnetrznyId wew:@polaczenie.ElementWewnetrznyId" src="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)"
                                                     style="width: 150px; height: auto; object-fit: contain; border: 1px solid #ccc;" />

                                        </a>
                                        <a target="_blank" href="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekrojuStyczny)">
                                            <img title="Połączenie styczne zew:@polaczenie.ElementZewnetrznyId wew:@polaczenie.ElementWewnetrznyId" src="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekrojuStyczny)"
                                                 style="width: 150px; height: auto; object-fit: contain; border: 1px solid #ccc;" />

                                        </a>
                                    }
                                    else if(polaczenie.RysunekPrzekroju?.Length > 20 && polaczenie.RysunekPrzekrojuStyczny?.Length < 20)
                                    {
                                        <a target="_blank" href="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)">
                                            <img title="zew:@polaczenie.ElementZewnetrznyId wew:@polaczenie.ElementWewnetrznyId" src="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekroju)"
                                                 style="width: 150px; height: auto; object-fit: contain; border: 1px solid #ccc;" />

                                        </a>
                                    }
                                    else if (polaczenie.RysunekPrzekroju?.Length < 20 && polaczenie.RysunekPrzekrojuStyczny?.Length > 20)
                                    {
                                        <a target="_blank" href="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekrojuStyczny)">
                                            <img title="Połączenie styczne zew:@polaczenie.ElementZewnetrznyId wew:@polaczenie.ElementWewnetrznyId" src="data:image/png;base64,@Convert.ToBase64String(polaczenie.RysunekPrzekrojuStyczny)"
                                                 style="width: 150px; height: auto; object-fit: contain; border: 1px solid #ccc;" />

                                        </a>
                                    }
                                    else
                                    {
                                        <span class="text-muted">Brak</span>
                                    }
                                </td>
                                <td>@(polaczenie.OpisPolaczenia ?? "")</td>
                                <td>@polaczenie.StronaPolaczenia</td>
                                <td>@polaczenie.PrzesuniecieX / @polaczenie.PrzesuniecieXStycznej</td>
                                <td>@polaczenie.PrzesuniecieY / @polaczenie.PrzesuniecieYStycznej</td>
                                <td>@polaczenie.ZapisanyKat</td>
                                      <Popconfirm Title="Czy chcesz usunąć użytkownika?"
                                            OnConfirm="()=> deleteRow(polaczenie.RowId.ToString())"
                                            OkText="Tak"
                                            CancelText="Nie">
                                    <a style="color:red">Usuń</a>
                                </Popconfirm>
                            </tr>
                        }
                    </tbody>
                </table>
            }
        </TabPane>
        <TabPane Key="1" Tab="Konfigurator połączeń - przekroje">

            <div class="row">
                <div class="col-md-4">
                    <div class="model-list">
                        @if (ListaModeli != null && ListaModeli.Any())
                        {
                            <div class="side-checkboxes">
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selDol" id="str_dol" onclick="@DelSvg" />
                                    <label for="str_dol">Dół</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selGora" id="str_gora" onclick="@DelSvg" />
                                    <label for="str_gora">Góra</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selLewa" id="str_lewa" onclick="@DelSvg" />
                                    <label for="str_lewa">Lewa</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selPrawa" id="str_prawa" onclick="@DelSvg" />
                                    <label for="str_prawa">Prawa</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selSlRuchomy" id="str_sl_ruch" onclick="@DelSvg" />
                                    <label for="str_prawa">Słupek ruchomu</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selSlStaly" id="str_sl_staly" onclick="@DelSvg" />
                                    <label for="str_prawa">Słupek stały</label>
                                </div>
                            </div>

                            <table class="table model-table">
                                <thead>
                                    <tr>
                                        <th>Nazwa</th>
                                        <th>Typ</th>
                                        <th class="thumbnail-cell">Miniaturka</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var model in ListaModeli)
                                    {
                                        <tr @onclick="() => WybierzModel(model, selDol, selGora, selLewa, selPrawa, false)">
                                            <td>@model.NazwaKonfiguracji</td>
                                            <td>@model.Typ</td>
                                            <td>
                                                @if (model.Rysunek?.Length > 0)
                                                {
                                                    <img src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                                         width="60" height="60" />
                                                }
                                                else
                                                {
                                                    <span class="text-muted">Brak</span>
                                                }
                                            </td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        }
                        else
                        {
                            <div class="alert alert-info">Brak zapisanych modeli.</div>
                        }
                    </div>
                </div>

                <div class="col-md-8">
                    <div class="controls-container">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <Tooltip Title="Zapisz ustawienia">
                                    <Button Icon="@IconType.Fill.Save" OnClick="SaveAllPosition" Class="btn btn-primary me-2">
                                        Zapisz
                                    </Button>
                                </Tooltip>
                            </div>

                            <div class="btn-group">
                                <Tooltip Title="Lustro elementów. Odbicie w poziome">
                                    <Button Icon="@IconType.Outline.Swap" OnClick="MirrorObjAll" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Obróć wszystko">
                                    <Button Icon="@IconType.Outline.Undo" OnClick="RotateObjAll" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Obróć drugi model">
                                    <Button Icon="@IconType.Outline.Redo" OnClick="RotateObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w lewo (1px)">
                                    <Button Icon="@IconType.Outline.ArrowLeft" OnClick="MoveLeftObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w prawo (1px)">
                                    <Button Icon="@IconType.Outline.ArrowRight" OnClick="MoveRightObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w górę (1px)">
                                    <Button Icon="@IconType.Outline.ArrowUp" OnClick="MoveUpObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w dół (1px)">
                                    <Button Icon="@IconType.Outline.ArrowDown" OnClick="MoveDownObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Dopasuj widok">
                                    <Button Icon="@IconType.Outline.Drag" OnClick="ZoomAllObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Powiększ">
                                    <Button Icon="@IconType.Outline.ZoomIn" OnClick="ZoomInObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Pomniejsz">
                                    <Button Icon="@IconType.Outline.ZoomOut" OnClick="ZoomOutObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <label class="ms-2">Precyzja przesuwania:</label>
                                <AntDesign.InputNumber @bind-Value="precyzjaPrzesuwania" Min="0" Max="50" Style="width: 60px;" />

                                <Tooltip Title="Pomiar odległości">
                                    <Button Icon="@IconType.Outline.Scan" OnClick="StartMeasurement" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Wyczyść pomiary">
                                    <Button Icon="@IconType.Outline.Close" OnClick="ClearMeasurements" Class="btn-sm btn-move" />
                                </Tooltip>
                            </div>
                        </div>
                    </div>

                    <div class="mb-2 d-flex justify-content-between">
                        <h6>Podgląd połączenia</h6>
                        <div>
                            <Button Icon="@IconType.Outline.Fire" OnClick="@(() => RefreshSvg())" Class="btn-sm me-2">
                                Odśwież
                            </Button>
                            <Button Icon="@IconType.Outline.Clear" OnClick="@(() => DelSvg())" Class="btn-sm btn-danger">
                                Wyczyść
                            </Button>
                        </div>
                    </div>

                    @if (pierwszyModel != null || drugiModel != null)
                    {
                        <div class="status-message">
                            @if (pierwszyModel != null && drugiModel == null)
                            {
                                <span>Pierwszy model wybrany: <strong>@pierwszyModel.Nazwa</strong></span>
                            }
                            else if (pierwszyModel != null && drugiModel != null)
                            {
                                <span>Połączono: <strong>@pierwszyModel.Nazwa</strong> z <strong>@drugiModel.Nazwa</strong></span>
                            }
                        </div>
                    }

                    <div class="scaled-svg-container">
                        @if (!string.IsNullOrEmpty(combinedSvg))
                        {
                            <div class="scaled-svg" @key="SvgKey">
                                @((MarkupString)combinedSvg)
                            </div>
                        }
                        else
                        {
                            <div class="d-flex flex-column justify-content-center align-items-center h-100">
                                <div class="alert alert-info mb-3">
                                    Wybierz modele ramy, skrzydła lub poprzeczki
                                </div>
                                @if (!string.IsNullOrEmpty(BladKonfiguracji))
                                {
                                    <div class="alert alert-warning">
                                        @BladKonfiguracji
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>
       
        </TabPane>
        
        <TabPane Key="2" Tab="Konfigurator połączeń - styczne">

            <div class="row">
                <div class="col-md-4">
                    <div class="model-list">
                        @if (ListaModeli != null && ListaModeli.Any())
                        {
                            <div class="side-checkboxes">
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selDolStyczne" id="str_dol_st" onclick="@DelSvg" />
                                    <label for="str_dol">Dół</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selGoraStyczne" id="str_gora_st" onclick="@DelSvg" />
                                    <label for="str_gora">Góra</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selLewaStyczne" id="str_lewa_st" onclick="@DelSvg" />
                                    <label for="str_lewa">Lewa</label>
                                </div>
                                <div class="side-checkbox">
                                    <input type="checkbox" @bind="selPrawaStyczne" id="str_prawa_st" onclick="@DelSvg" />
                                    <label for="str_prawa">Prawa</label>
                                </div>
                            </div>

                            <table class="table model-table">
                                <thead>
                                    <tr>
                                        <th>Nazwa</th>
                                        <th>Typ</th>
                                        <th class="thumbnail-cell">Miniaturka</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var model in ListaModeli)
                                    {
                                        @if (pierwszyModel == null)
                                        {
                                            <tr @onclick="() => WybierzModel(model, selDolStyczne, selGoraStyczne, selLewaStyczne, selPrawaStyczne, true)">
                                                <td>@model.NazwaKonfiguracji</td>
                                                <td>@model.Typ</td>
                                                <td>
                                                    @if (model.Rysunek?.Length > 0)
                                                    {
                                                        <img src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                                             width="60" height="60" />
                                                    }
                                                    else
                                                    {
                                                        <span class="text-muted">Brak</span>
                                                    }
                                                </td>
                                            </tr>
                                        }
                                        else if (pierwszyModel != null && model.Typ.Contains("Słupek"))
                                        {
                                            <tr @onclick="() => WybierzModel(model, selDolStyczne, selGoraStyczne, selLewaStyczne, selPrawaStyczne, true)">
                                                <td>@model.NazwaKonfiguracji</td>
                                                <td>@model.Typ</td>
                                                <td>
                                                    @if (model.Rysunek?.Length > 0)
                                                    {
                                                        <img src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                                             width="60" height="60" />
                                                    }
                                                    else
                                                    {
                                                        <span class="text-muted">Brak</span>
                                                    }
                                                </td>
                                            </tr>
                                        }
                                    }
                                </tbody>
                            </table>
                        }
                        else
                        {
                            <div class="alert alert-info">Brak zapisanych modeli.</div>
                        }
                    </div>
                </div>

                <div class="col-md-8">
                    <div class="controls-container">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <Tooltip Title="Zapisz ustawienia">
                                    <Button Icon="@IconType.Fill.Save" OnClick="SaveAllPosition" Class="btn btn-primary me-2">
                                        Zapisz
                                    </Button>
                                </Tooltip>
                            </div>

                            <div class="btn-group">
                                <Tooltip Title="Lustro elementów. Odbicie w poziome">
                                    <Button Icon="@IconType.Outline.Swap" OnClick="MirrorObjAll" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Obróć wszystko">
                                    <Button Icon="@IconType.Outline.Undo" OnClick="RotateObjAll" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Obróć drugi model">
                                    <Button Icon="@IconType.Outline.Redo" OnClick="RotateObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w lewo (1px)">
                                    <Button Icon="@IconType.Outline.ArrowLeft" OnClick="MoveLeftObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w prawo (1px)">
                                    <Button Icon="@IconType.Outline.ArrowRight" OnClick="MoveRightObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w górę (1px)">
                                    <Button Icon="@IconType.Outline.ArrowUp" OnClick="MoveUpObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Przesuń w dół (1px)">
                                    <Button Icon="@IconType.Outline.ArrowDown" OnClick="MoveDownObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Dopasuj widok">
                                    <Button Icon="@IconType.Outline.Drag" OnClick="ZoomAllObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Powiększ">
                                    <Button Icon="@IconType.Outline.ZoomIn" OnClick="ZoomInObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Pomniejsz">
                                    <Button Icon="@IconType.Outline.ZoomOut" OnClick="ZoomOutObj" Class="btn-sm btn-move" />
                                </Tooltip>
                                <label class="ms-2">Precyzja przesuwania:</label>
                                <AntDesign.InputNumber @bind-Value="precyzjaPrzesuwania" Min="0" Max="50" Style="width: 60px;" />

                                <Tooltip Title="Pomiar odległości">
                                    <Button Icon="@IconType.Outline.Scan" OnClick="StartMeasurement" Class="btn-sm btn-move" />
                                </Tooltip>
                                <Tooltip Title="Wyczyść pomiary">
                                    <Button Icon="@IconType.Outline.Close" OnClick="ClearMeasurements" Class="btn-sm btn-move" />
                                </Tooltip>
                            </div>
                        </div>
                    </div>

                    <div class="mb-2 d-flex justify-content-between">
                        <h6>Podgląd połączenia</h6>
                        <div>
                            <Button Icon="@IconType.Outline.Fire" OnClick="@(() => RefreshSvg())" Class="btn-sm me-2">
                                Odśwież
                            </Button>
                            <Button Icon="@IconType.Outline.Clear" OnClick="@(() => DelSvg())" Class="btn-sm btn-danger">
                                Wyczyść
                            </Button>
                        </div>
                    </div>

                    @if (pierwszyModel != null || drugiModel != null)
                    {
                        <div class="status-message">
                            @if (pierwszyModel != null && drugiModel == null)
                            {
                                <span>Pierwszy model wybrany: <strong>@pierwszyModel.Nazwa</strong></span>
                            }
                            else if (pierwszyModel != null && drugiModel != null)
                            {
                                <span>Połączono: <strong>@pierwszyModel.Nazwa</strong> z <strong>@drugiModel.Nazwa</strong></span>
                            }
                        </div>
                    }

                    <div class="scaled-svg-container">
                        @if (!string.IsNullOrEmpty(combinedSvgStyczne))
                        {
                            <div class="scaled-svg" @key="SvgKeyStyczne">
                                @((MarkupString)combinedSvgStyczne)
                            </div>
                        }
                        else
                        {
                            <div class="d-flex flex-column justify-content-center align-items-center h-100">
                                <div class="alert alert-info mb-3">
                                    Wybierz modele ramy, skrzydła lub poprzeczki
                                </div>
                                @if (!string.IsNullOrEmpty(BladKonfiguracji))
                                {
                                    <div class="alert alert-warning">
                                        @BladKonfiguracji
                                    </div>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>

        </TabPane>

    </Tabs>
</div>

@code {
    [Inject] private AppState AppState { get; set; } = default!;

    // Dane i stan
    private string SvgKey { get; set; } = Guid.NewGuid().ToString();
    private string SvgKeyStyczne { get; set; } = Guid.NewGuid().ToString();
    private List<SystemyOkienne> Systemy = new();
    private string? SelectedSystemId;
    private string? SelectedModelId;
    private List<KonfModele>? ListaModeli;
    private List<KonfSystem>? KonfiguracjeSystemu;
    private float precyzjaPrzesuwania = 5;
    private string BladKonfiguracji = string.Empty;
    private string BladKonfiguracjiStyczne = string.Empty;

    // Wybór stron
    private bool selDol = false;
    private bool selGora = false;
    private bool selLewa = false;
    private bool selPrawa = false;

    // Wybór stron
    private bool selDolStyczne = false;
    private bool selGoraStyczne = false;
    private bool selLewaStyczne = false;
    private bool selPrawaStyczne = false;

    private bool selSlRuchomy = false;
    private bool selSlStaly = false;

    // Modele SVG
    private KonfSystem? pierwszyModel;
    private KonfSystem? drugiModel;
    private string combinedSvg = string.Empty;
    private string combinedSvgStyczne = string.Empty;
    private double offsetX = 0;
    private double offsetY = 0;
    private double luzLewo = 25;  // Zwiększony luz
    private double luzPrawo = 25;
    private double luzGora = 25;
    private double luzDol = 25;

    private double przesuniecieX;
    private double przesuniecieY;
    private int katUstawienia = 0;

    private List<KonfPolaczenie>? listaPolaczen;

    private bool boolStyczny = false;

    // Inicjalizacja
    protected override async Task OnInitializedAsync()
    {
        await Laduj_Uprawnienia();
        Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne") ?? new();

    }

    // Obsługa wyboru systemu
    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value?.ToString();

        if (string.IsNullOrEmpty(SelectedSystemId)) return;

        Console.WriteLine($"Row ID wybranego systemu: {SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}") ?? new();
        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}") ?? new();

        try
        {
            var response = await Http.GetAsync($"api/KonfPolaczenie/row-id-system/{SelectedSystemId}");

            if (response.IsSuccessStatusCode)
            {
                listaPolaczen = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>() ?? new();
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                // 👇 Obsłuż błąd NotFound — nie ma rekordów, to nie błąd techniczny
                listaPolaczen = new();
                Console.WriteLine("Brak połączeń dla danego systemu.");
            }
            else
            {
                // 👇 Inne błędy — np. 500
                Console.Error.WriteLine($"Błąd HTTP {response.StatusCode}");
                listaPolaczen = new();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Błąd ładowania połączeń: {ex.Message}");
            listaPolaczen = new();
        }
    }

    private async Task OdswiezDane()
    {
        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            Console.WriteLine("Nie wybrano systemu.");
            return;
        }

        try
        {
            var response = await Http.GetAsync($"api/KonfPolaczenie/row-id-system/{SelectedSystemId}");

            if (response.IsSuccessStatusCode)
            {
                listaPolaczen = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>() ?? new();
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound)
            {
                // 👇 Obsłuż błąd NotFound — nie ma rekordów, to nie błąd techniczny
                listaPolaczen = new();
                Console.WriteLine("Brak połączeń dla danego systemu.");
            }
            else
            {
                // 👇 Inne błędy — np. 500
                Console.Error.WriteLine($"Błąd HTTP {response.StatusCode}");
                listaPolaczen = new();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Błąd ładowania połączeń: {ex.Message}");
            listaPolaczen = new();
        }
    }


    public async Task deleteRow(string rowId)
    {
        if (listaPolaczen == null) return;

        try
        {
            var response = await Http.DeleteAsync($"api/KonfPolaczenie/{rowId}");

            if (response.IsSuccessStatusCode)
            {
                // Usunięcie rekordu z listy po pomyślnym usunięciu z serwera
                await OdswiezDane();

                Console.WriteLine("Rekord został pomyślnie usunięty.");
            }
            else
            {
                Console.WriteLine($"Błąd podczas usuwania rekordu: {response.ReasonPhrase}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"******* Błąd {ex.Message}");
        }
    }

    private async Task OnTabChange(string key)
    {
        selDol = false;
        selGora = false;
        selLewa = false;
        selPrawa = false;
        selDolStyczne = false;
        selGoraStyczne = false;
        selLewaStyczne = false;
        selPrawaStyczne = false;

        pierwszyModel =null;
        drugiModel = null;

        combinedSvgStyczne = string.Empty;
        combinedSvg = string.Empty;

        await JSRuntime.InvokeVoidAsync("svgHelper.resetModel2Position");

        if( key == "1")
        {
            boolStyczny = false;
        }
        else if (key == "2")
        {
            boolStyczny = true;

        }
    }

    // Wybór modelu
    private async Task WybierzModel(KonfModele model, bool stronaDol, bool stronaGora, bool stronaLewa, bool stronaPrawa, bool boolStyczny)
    {
        Console.WriteLine($"WybierzModel - START - stronaDol: {stronaDol}, stronaGora: {stronaGora}, stronaLewa: {stronaLewa}, stronaPrawa: {stronaPrawa}, boolStyczny: {boolStyczny}");

        if (!selDol && !selGora && !selLewa && !selPrawa && !selDolStyczne && !selGoraStyczne && !selLewaStyczne && !selPrawaStyczne)
        {
            BladKonfiguracji = "Wybierz co najmniej jedną stronę (Dół, Góra, Lewa, Prawa).";
            return;
        }

        BladKonfiguracji = "";

        SelectedModelId = "";

        Console.WriteLine("WybierzModel - START");

        try
        {
            var response = await Http.GetAsync($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{model.RowId}");
            if (!response.IsSuccessStatusCode)
            {
                BladKonfiguracji = $"Błąd odczytu powiązania: {response.StatusCode}";
                Console.WriteLine(BladKonfiguracji);
                return;
            }

            var result = await response.Content.ReadFromJsonAsync<MVCKonfModele>();
            if (result?.KonfSystem == null || result.KonfSystem.Count == 0)
            {
                BladKonfiguracji = "Brak danych powiązanych";
                Console.WriteLine(BladKonfiguracji);
                return;
            }

            SelectedModelId = model.RowId.ToString();

            var warunki = new List<Func<KonfSystem, bool>>();

            if (stronaDol) warunki.Add(x => x.WystepujeDol);
            if (stronaGora) warunki.Add(x => x.WystepujeGora);
            if (stronaLewa) warunki.Add(x => x.WystepujeLewa);
            if (stronaPrawa) warunki.Add(x => x.WystepujePrawa);

            if (selSlRuchomy) warunki.Add(x => x.Typ == "Słupek ruchomy");
            if (selSlStaly) warunki.Add(x => x.Typ == "Słupek stały");

            if (model.Typ.Contains("Słupek") && boolStyczny)
            {
                warunki.Clear();
                warunki.Add(x => x.WystepujeLewa);

            }

            // Filtrujemy rekordy spełniające WSZYSTKIE warunki
            var pasujaceSystemy = result.KonfSystem.Where(x => warunki.All(w => w(x))).ToList();

            // Jeśli nie ma dokładnie jednego pasującego rekordu → błąd
            if (pasujaceSystemy.Count != 1)
            {
                BladKonfiguracji = pasujaceSystemy.Count == 0
                    ? "Nie znaleziono pasującego systemu konfiguracyjnego. Zmień występowanie elementu. Np. zaznacz tylko lewy/górny/prawy!"
                    : $"Znaleziono {pasujaceSystemy.Count} pasujących systemów. Wymagane jest dokładnie jedno dopasowanie.";
                await _message.Info(BladKonfiguracji);
                Console.WriteLine(BladKonfiguracji);
                return;
            }

            // Pobieramy JEDYNY pasujący rekord
            var pasujacy = pasujaceSystemy.First();

            // Sprawdzamy, czy wszystkie pasujące rekordy mają ten sam Indeks
            if (pasujaceSystemy.Select(x => x.Indeks).Distinct().Count() > 1)
            {
                BladKonfiguracji = $"Model jest zbudowany z więcej niż jednego typu elementów. Prawdopodobnie element dolny może być różny od pozostałych. Pomiń jedną ze stron i sprawdź! [Znalezione indeksy: {string.Join(", ", pasujaceSystemy.Select(x => x.Indeks).Distinct())}]";
                await _message.Info(BladKonfiguracji);
                Console.WriteLine(BladKonfiguracji);
                return;
            }

            // var pasujacy = result.KonfSystem.FirstOrDefault(x =>
            //     (stronaDol && x.WystepujeDol) ||
            //     (stronaGora && x.WystepujeGora) ||
            //     (stronaLewa && x.WystepujeLewa) ||
            //     (stronaPrawa && x.WystepujePrawa));

            if (pasujacy == null)
            {
                BladKonfiguracji = "Nie znaleziono pasującego elementu. Zmień występowanie elementu. Np. zaznacz tylko lewy/górny/prawy!";
                await _message.Info(BladKonfiguracji);
                Console.WriteLine(BladKonfiguracji);
                return;
            }

            Console.WriteLine($"Wybór modelu: {model.NazwaKonfiguracji}, pasujący: {pasujacy.Nazwa} WystepujeDol: {pasujacy.WystepujeDol} = {stronaDol}");

            if (pierwszyModel == null)
            {
                pierwszyModel = pasujacy;
                offsetX = 0; // Resetuj offset
                offsetY = 0; // Resetuj offset

                AktualizujSvg();
            }
            else if (drugiModel == null)
            {
                drugiModel = pasujacy;

                AktualizujSvg();                          // 1. generuj combinedSvg

                await InvokeAsync(StateHasChanged);      // 2. wymuś render Blazora

                await Task.Delay(100);                    // 3. krótka pauza lub: await Task.Yield();
                await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");

            }

            await InvokeAsync(StateHasChanged);

            Console.WriteLine($"Wybór modelu: KONIEC");

        }
        catch (Exception ex)
        {
            BladKonfiguracji = $"Błąd: {ex.Message}";
            Console.WriteLine(BladKonfiguracji);
        }
    }

    // Generowanie SVG z większym obszarem roboczym
    private void AktualizujSvg()
    {

        if (pierwszyModel == null && drugiModel == null && !boolStyczny)
        {
            combinedSvg = "";
            return;
        }

        var svgParts = new List<string>();
        double centerX = 300; // Środek obszaru roboczego (600x600/2)
        double centerY = 300;

        // 🔹 1️⃣ Pierwszy model - zawsze na środku
        if (pierwszyModel != null)
        {
            svgParts.Add($@"
            <g id=""model1"" transform=""translate({centerX}, {centerY})"">
            {ExtractInnerSvg(NormalizeSvg(pierwszyModel.SVG))}
            </g>");
        }

        // 🔹 2️⃣ Drugi model lub prostokąt zastępczy
        if (drugiModel != null && boolStyczny)
        {
            double secondX = centerX + offsetX;
            double secondY = centerY + offsetY;

            var pasujacyWymiar = drugiModel.PoziomGora - drugiModel.PoziomDol ?? 0;
            double rectWidth = Math.Abs(pasujacyWymiar);
            double rectHeight = 100; // Domyślny rozmiar prostokąta tylko do wizualizacji
            double rectX = 0;//centerX + offsetX - rectWidth;
            double rectY = 0;//centerY + offsetY - rectHeight;

            svgParts.Add($@"
            <g id=""model2"" transform=""translate({secondX}, {secondY})"">
                <rect x=""{rectX}"" y=""{rectY}"" width=""{rectWidth}"" height=""{rectHeight}""
                      fill=""#e0e0e0"" fill-opacity=""0.5"" stroke=""#000"" stroke-width=""1"" />
            </g>");

        }
        else if (drugiModel != null && !boolStyczny)
        {
            double secondX = centerX + offsetX;
            double secondY = centerY + offsetY;

            svgParts.Add($@"
            <g id=""model2"" transform=""translate({secondX}, {secondY})"">
            {ExtractInnerSvg(NormalizeSvg(drugiModel.SVG))}
            </g>");
        }

        // 🔹 3️⃣ Złożenie końcowego SVG
        var _combinedSvg = $@"
        <svg xmlns=""http://www.w3.org/2000/svg"" width=""600"" height=""600""
             viewBox=""0 0 600 600"" preserveAspectRatio=""xMidYMid meet"">
            <g id=""zoom-group"">
            {string.Join("", svgParts)}
            </g>
        </svg>";

        if (boolStyczny)
        {
            combinedSvgStyczne = _combinedSvg;
            SvgKeyStyczne = Guid.NewGuid().ToString();
        }
        else
        {
            combinedSvg = _combinedSvg;
            SvgKey = Guid.NewGuid().ToString();
        }

        string NormalizeSvg(string svg) =>
            svg?
            .Replace("id=\"guide-line-horizontalMax\"", "data-name=\"guide-line-horizontalMax\"")
            .Replace("id=\"guide-line-vertical\"", "data-name=\"guide-line-vertical\"")
            .Trim('\uFEFF', '\u200B', '\u0000')
            .Replace("\r", "").Replace("\n", "").Trim() ?? "";

    }


    // Pomocnicze metody do przetwarzania SVG
    private string NormalizeSvg(string svg) => svg?.Trim('\uFEFF', '\u200B', '\u0000').Replace("\r", "").Replace("\n", "").Trim() ?? "";

    private string ExtractInnerSvg(string svg)
    {
        if (string.IsNullOrWhiteSpace(svg)) return "";
        int start = svg.IndexOf('>') + 1;
        int end = svg.LastIndexOf("</svg>", StringComparison.OrdinalIgnoreCase);
        return (start > 0 && end > start) ? svg.Substring(start, end - start).Trim() : svg;
    }

    // Kontrola SVG
    private async Task RefreshSvg()
    {
        AktualizujSvg();
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
        await Task.Delay(100); // 💡 daj czas DOM-owi
        await JSRuntime.InvokeVoidAsync("svgHelper.initGuideLines");
    }

    private async Task DelSvg()
    {
        pierwszyModel = null;
        drugiModel = null;
        offsetX = 0;
        offsetY = 0;
        BladKonfiguracji = "";
        AktualizujSvg();

        await Task.CompletedTask;
    }

    // Manipulacja drugim modelem
    private async Task PrzesunDrugiModel(string kierunek)
    {
        if (drugiModel == null) return;

        switch (kierunek)
        {
            case "gora": offsetY -= 1; break;
            case "dol": offsetY += 1; break;
            case "lewo": offsetX -= 1; break;
            case "prawo": offsetX += 1; break;
        }

        AktualizujSvg();
        await Task.Delay(10);
    }

    private async Task MoveLeftObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", -precyzjaPrzesuwania, 0);
    private async Task MoveRightObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", precyzjaPrzesuwania, 0);
    private async Task MoveUpObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, -precyzjaPrzesuwania);
    private async Task MoveDownObj() => await JSRuntime.InvokeVoidAsync("svgHelper.move", 0, precyzjaPrzesuwania);
    private async Task ZoomAllObj() => await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
    private async Task GoBack() => await JSRuntime.InvokeVoidAsync("history.back");

    private async Task ZoomInObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomIn");
    private async Task ZoomOutObj() => await JSRuntime.InvokeVoidAsync("svgHelper.zoomOut");

    private async Task RotateObj()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.rotateSecondModel");

        katUstawienia = (katUstawienia + 90) % 360;
    }

    private async Task MirrorObjAll()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.flipAllModelsHorizontally");
    }

    private async Task RotateObjAll()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.rotateAllModel");

        katUstawienia = (katUstawienia + 90) % 360;
    }

    private async Task StartMeasurement()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
        await JSRuntime.InvokeVoidAsync("svgHelper.initMeasurement");
    }

    private async Task ClearMeasurements()
    {
        await JSRuntime.InvokeVoidAsync("svgHelper.clearMeasurements");
    }

    private async Task SaveAllPosition()
    {

        await JSRuntime.InvokeVoidAsync("svgHelper.centerAndFit");
        await Task.Delay(200);

        GuideDisplacementResult result;

        if (boolStyczny)
        {
            // 🔹 Tryb STYCZNY (bez prowadnic, prostokąt)
            var offset = await JSRuntime.InvokeAsync<GuideDisplacementResult>("svgHelper.getModel2Displacement");

            if (offset == null || !offset.success)
            {
                await _message.Warning("❗ Nie udało się odczytać przesunięcia modelu 2 (tryb styczny)");
                return;
            }

            result = new GuideDisplacementResult
            {
                success = true,
                elementsFound = false,
                przesuniecieX = Math.Round(offset.przesuniecieX, 2),
                przesuniecieY = Math.Round(offset.przesuniecieY, 2),
                scale = 1
            };
        }
        else
        {
            // 🔹 Tryb NORMALNY (z prowadnicami)
            result = await JSRuntime.InvokeAsync<GuideDisplacementResult>("svgHelper.measureGuideDisplacement");

            if (result?.success != true || !result.elementsFound)
            {
                await _message.Warning(result?.error ?? "❗ Nie można znaleźć prowadnic w rysunku SVG");
                return;
            }
        }

        double przesuniecieX = Math.Round(result.przesuniecieX, 2);
        double przesuniecieY = Math.Round(result.przesuniecieY, 2);

        if (pierwszyModel == null || drugiModel == null || string.IsNullOrEmpty(SelectedModelId))
        {
            await _message.Warning("❗ Nie wybrano obu modeli do połączenia. Błąd konfiguracji modelu :(");
            return;
        }

        // 🔹 Rysunek aktualnej zakładki
        var png = await GenerujPngBezProwadnic();

        // 🔹 Lista stron do zapisania (lewa/prawa/góra/dół)
        var strony = WyliczStronyPolaczenia();

        Console.WriteLine($"Rozpoczynam pętle foreach (var strona in strony) Strony: {strony.Count()}");

        foreach (var strona in strony)
        {
            var polaczenie = new KonfPolaczenie
            {
                ElementZewnetrznyId = pierwszyModel.RowId,
                ElementWewnetrznyId = drugiModel.RowId,
                StronaPolaczenia = strona,
                RowIdSystem = Guid.Parse(SelectedSystemId),
                RowIdModelu = Guid.Parse(SelectedModelId),
                ZapisanyKat = katUstawienia,
                OpisPolaczenia = $"Połączono: {pierwszyModel.Nazwa ?? "Model 1 ?"} z {drugiModel.Nazwa ?? "Model 2 ?"}",
                Uwagi = $"Ostatnia zmiana: {DateTime.Now} - [{user}]"
            };

            // 🔍 Sprawdź, czy istnieje już połączenie
            KonfPolaczenie? existing = null;
            try
            {
                var responseS = await Http.GetAsync(
                    $"api/KonfPolaczenie/find-by-elements/{polaczenie.ElementZewnetrznyId}/{polaczenie.ElementWewnetrznyId}/{strona}");

                if (responseS.IsSuccessStatusCode)
                {
                    existing = await responseS.Content.ReadFromJsonAsync<KonfPolaczenie>();
                }
                else if (responseS.StatusCode != HttpStatusCode.NotFound)
                {
                    await _message.Error($"❌ Błąd sprawdzania strony: {strona}");
                    continue;
                }
            }
            catch (Exception ex)
            {
                await _message.Error($"❌ Błąd komunikacji z API dla strony {strona}: {ex.Message}");
                continue;
            }

            // 🔸 Uzupełnij dane zależnie od zakładki
            if (boolStyczny)
            {
                // --- DANE DLA ZAKŁADKI "STYCZNE" ---
                polaczenie.PrzesuniecieXStycznej = przesuniecieX;
                polaczenie.PrzesuniecieYStycznej = przesuniecieY + 100;//100 awatar modelu
                polaczenie.RysunekPrzekrojuStyczny = png;

                if (existing != null)
                {
                    // zachowaj dane przekrojów, nadpisz tylko styczne
                    polaczenie.Id = existing.Id;
                    polaczenie.RowId = existing.RowId;
                    polaczenie.PrzesuniecieX = existing.PrzesuniecieX;
                    polaczenie.PrzesuniecieY = existing.PrzesuniecieY;
                    polaczenie.RysunekPrzekroju = existing.RysunekPrzekroju;
                }
            }
            else
            {
                // --- DANE DLA ZAKŁADKI "PRZEKROJE" ---
                polaczenie.PrzesuniecieX = przesuniecieX;
                polaczenie.PrzesuniecieY = przesuniecieY;
                polaczenie.RysunekPrzekroju = png;

                if (existing != null)
                {
                    // zachowaj dane styczne, nadpisz tylko przekroje
                    polaczenie.Id = existing.Id;
                    polaczenie.RowId = existing.RowId;
                    polaczenie.PrzesuniecieXStycznej = existing.PrzesuniecieXStycznej;
                    polaczenie.PrzesuniecieYStycznej = existing.PrzesuniecieYStycznej + 100;//100 awatar modelu
                    polaczenie.RysunekPrzekrojuStyczny = existing.RysunekPrzekrojuStyczny;
                }
            }

            Console.WriteLine($"Zapis połączenia: boolStyczny:{boolStyczny} -> {polaczenie.ElementZewnetrznyId} + {polaczenie.ElementWewnetrznyId} Strona: {strona} X={przesuniecieX} Y={przesuniecieY} Kat={katUstawienia}");

            // 🔹 Zapisz lub aktualizuj w bazie
            HttpResponseMessage response;

            if (existing != null)
            {
                response = await Http.PutAsJsonAsync("api/KonfPolaczenie", polaczenie);
                Console.WriteLine($"Aktualizacja połączenia: {response.StatusCode}");
            }
            else
            {
                response = await Http.PostAsJsonAsync("api/KonfPolaczenie", polaczenie);
                Console.WriteLine($"Nowe połączenie: {response.StatusCode}");
            }

            // 🔸 Feedback użytkownikowi
            if (response.IsSuccessStatusCode)
            {
                var zakladka = boolStyczny ? "styczna" : "przekrój";
                await _message.Success($"✅ Zapisano stronę {strona} ({zakladka}): X={przesuniecieX:F2} mm, Y={przesuniecieY:F2} mm, kąt: {katUstawienia}°", 0.8);
            }
            else
            {
                await _message.Error($"❌ Błąd zapisu strony {strona}");
            }
        }
    }

    private async Task<byte[]> GenerujPngBezProwadnic()
    {
        try
        {
            // 1. Wymuś aktualizację UI
            StateHasChanged();
            await Task.Delay(100); // Czekaj na renderowanie

            // 2. Wygeneruj PNG
            var base64 = await JSRuntime.InvokeAsync<string>("svgHelper.exportCleanedSvgAsPng");

            if (string.IsNullOrEmpty(base64) || base64.Length < 100)
            {
                Console.WriteLine("Invalid PNG data received");
                return Array.Empty<byte>();
            }

            // 3. Konwersja do byte[]
            var pureBase64 = base64.StartsWith("data:image/png;base64,")
                ? base64["data:image/png;base64,".Length..]
                : base64;

            var imageData = Convert.FromBase64String(pureBase64);

            // 4. Walidacja rozmiaru
            if (imageData.Length < 1000) // Minimalny oczekiwany rozmiar
            {
                Console.WriteLine("PNG file too small");
                return Array.Empty<byte>();
            }

            return imageData;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating PNG: {ex.Message}");
            return Array.Empty<byte>();
        }
    }

    private List<string> WyliczStronyPolaczenia()
    {
        var strony = new List<string>();
        if (selLewa || selLewaStyczne) strony.Add("lewa");
        if (selPrawa || selPrawaStyczne) strony.Add("prawa");
        if (selGora || selGoraStyczne) strony.Add("góra");
        if (selDol || selDolStyczne) strony.Add("dół");
        Console.WriteLine($"WyliczStronyPolaczenia: {string.Join(", ", strony)}");
        return strony;
    }



    // Uprawnienia
    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");
        if (string.IsNullOrEmpty(user)) return;

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/KonfPolaczenie");
            if (uprawnienia?.Count > 0)
            {
                var szuk = uprawnienia.FirstOrDefault(x => x.TableName == "KonfPolaczenie");
                if (szuk != null)
                {
                    boolOdczyt = szuk.Odczyt;
                    boolZmiana = szuk.Zmiana;
                    boolUsuniecia = szuk.Usuniecie;
                    boolAdmin = szuk.Administrator;
                    boolNowy = szuk.Zapis;
                    RowIdPracownika = szuk.RowId;
                }
            }
        }
        catch (Exception ex)
        {
            await _message.Error($"Błąd ładowania uprawnień: {ex.Message}");
        }
    }

    public class GuideDisplacementResult
    {
        public bool success { get; set; }
        public bool elementsFound { get; set; }
        public double przesuniecieX { get; set; }
        public double przesuniecieY { get; set; }
        public double scale { get; set; }
        public string? error { get; set; } // opcjonalnie
    }

}