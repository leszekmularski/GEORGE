@page "/Modele-okienne"
@using AntDesign
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@using GEORGE.Shared.ViewModels;
@using GEORGE.Client.Pages.Utils
@using GEORGE.Client.Pages.Models
@using GEORGE.Client.Pages.Okna

@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@using System.Globalization
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation
@inject NavigationManager NavigationManager
@inject ShapeTransferService ShapeService

@using System.IO;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.Formats.Png;

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D

@inject GeneratorStateContainer StateContainer

@implements IDisposable
@implements IAsyncDisposable

<style>
    /* Globalne ustawienia */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
    }

    /* Specjalna klasa dla resetu */
    .cursor-reset * {
        cursor: default !important;
        pointer-events: auto !important;
    }

    /* Kontener główny */
    .window-model-container {
        display: flex;
        height: 70vh;
        background-color: #fff;
        padding: 10px;
        box-sizing: border-box;
    }

    /* Panel boczny z modelami */
    .wing-model-container {
        flex: 0 0 250px; /* Szerokość panelu bocznego */
        height: 100%;
        overflow-y: auto;
        border-right: 2px solid #ddd;
        padding: 10px;
        background: #f8f9fa;
    }

        /* Tabela modeli */
        .wing-model-container table {
            font-size: 13px;
            width: 100%;
            border-collapse: collapse;
        }

        .wing-model-container th, .wing-model-container td {
            padding: 6px;
            text-align: center;
        }

        .wing-model-container th {
            background-color: #007bff;
            color: white;
        }

        .wing-model-container tr:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        /* Miniatury modeli */
        .wing-model-container img {
            width: 45px;
            height: 45px;
            object-fit: contain;
            cursor: -webkit-grab; /* Obsługa w Safari */
            cursor: grab;
            transition: transform 0.2s ease-in-out;
        }

            .wing-model-container img:hover {
                transform: scale(1.1);
            }

    /* Główne okno wyświetlania */
    .display-window {
        flex-grow: 1;
        height: 100%;
        min-height: 400px; /* Zapewnienie minimalnej wysokości */
        border: 2px solid #ddd;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        position: relative;
        overflow: hidden;
        cursor: crosshair;
    }

    .container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .canvas-container {
        width: 100% !important; /* ✅ Zawsze 100% szerokości */
        height: 100% !important; /* ✅ Zawsze 100% wysokości */
        pointer-events: none; /* Wyłącz interakcje z canvasem */
        max-width: 100%;
        max-height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ukrywa przewijanie */
        position: relative;
    }

    /* ===== CANVAS ELEMENT ===== */
    canvas {
        display: block; /* ✅ Ważne: display block */
        width: 100% !important; /* ✅ Zawsze 100% szerokości */
        height: 100% !important; /* ✅ Zawsze 100% wysokości */
        background-color: white !important;
        /* Zapobiega artefaktom */
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        transform: translateZ(0); /* ✅ Reset transformacji */
    }

    .interactive-layer {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2; /* Warstwa NAD canvasem */
        pointer-events: auto; /* Włącz interakcje */
    }
    /* Paski przewijania */
    .wing-model-container::-webkit-scrollbar {
        width: 8px;
    }

    .wing-model-container::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 5px;
    }

        .wing-model-container::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }

    /* 🔹 Toolbar z przyciskami */
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        justify-content: center;
        padding: 10px;
        background: #fff;
    }

        /* Styl dla przycisków */
        .toolbar .btn {
            flex: 1;
            min-width: 90px;
            font-size: 13px;
            padding: 6px 8px;
            transition: all 0.2s ease-in-out;
        }

            .toolbar .btn:hover {
                transform: scale(1.05);
            }

    .zoom-controls {
        position: absolute;
        top: 170px; /* Ustawienie 10px od góry */
        right: 10px; /* Ustawienie 10px od prawej */
        display: flex;
        gap: 10px; /* Odstęp między przyciskami */
        z-index: 1000; /* Upewnia się, że są na wierzchu */
    }

    .btn-zoom {
        width: 40px;
        height: 40px;
        font-size: 20px;
        border-radius: 50%; /* Okrągłe przyciski */
        border: none;
        background-color: #007bff; /* Niebieski, możesz zmienić */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Delikatny cień */
        transition: background-color 0.3s ease;
    }

        .btn-zoom:hover {
            background-color: #0056b3; /* Ciemniejszy niebieski przy najechaniu */
        }

    /* Panel zajmuje pełną szerokość */
    .scrollable-panel {
        width: 100%;
        max-height: 400px; /* Możesz zmienić na więcej, np. 600px */
        overflow-y: auto; /* Włącza przewijanie w pionie */
    }

    /* Sider zajmuje całą szerokość */
    .info-panel {
        background-color: #222;
        color: #ffeb99;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
        width: 500px; /* Pełna szerokość */
        max-width: 1000px;
    }

    /* Lista informacji */
    .info-list {
        list-style: none;
        padding: 0;
        width: 760px;
    }

    /* Każdy element ma własne miejsce */
    .info-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 760px;
    }

        /* Tekst jasnożółty */
        .info-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .info-item strong {
            color: #ffcc00;
        }

    /* Obsługa braku danych */
    .no-data {
        color: red;
        text-align: center;
        font-style: italic;
    }

    /* Lista materiałów */
    .materials-list {
        list-style: none;
        padding: 0;
        width: 100%;
    }

    /* Pojedynczy materiał */
    .material-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
    }

        /* Kolor jasny dla tekstu */
        .material-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .material-item strong {
            color: #ffcc00;
        }
</style>

<script>
    window.modalDragState = {
        posX: 0,
        posY: 0,
        mouseX: 0,
        mouseY: 0
    };

    window.enableModalDrag = function (modalElement) {
        let modal = modalElement;
        let posX = 0, posY = 0, mouseX = 0, mouseY = 0;

        const header = modal.querySelector('.modal-header');
        if (!header) return;

        header.style.cursor = "move";
        header.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e.preventDefault();

            // Usuwamy transform żeby nie powodował skoków
            modal.style.transform = "none";

            // Pobieramy faktyczną pozycję na ekranie
            const rect = modal.getBoundingClientRect();
            modal.style.top = rect.top + "px";
            modal.style.left = rect.left + "px";

            mouseX = e.clientX;
            mouseY = e.clientY;

            document.onmouseup = closeDrag;
            document.onmousemove = drag;
        }

        function drag(e) {
            e.preventDefault();

            posX = mouseX - e.clientX;
            posY = mouseY - e.clientY;
            mouseX = e.clientX;
            mouseY = e.clientY;

            modal.style.top = (modal.offsetTop - posY) + "px";
            modal.style.left = (modal.offsetLeft - posX) + "px";
        }

        function closeDrag() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    };

    window.prepareModalForDrag = function(modalElement) {
        modalElement.style.transform = "none";
    };

    // Funkcja do pobierania rozmiaru kontenera .display-window
    window.getDisplayWindowSize = function() {
        const displayWindow = document.querySelector('.display-window');
        if (displayWindow) {
            const rect = displayWindow.getBoundingClientRect();
            // Zwracamy [szerokość, wysokość] - z zaokrągleniem
            return [Math.floor(rect.width), Math.floor(rect.height)];
        }
        console.warn('Element .display-window nie został znaleziony');
        return null;
    };

    // Funkcja do pobierania rozmiaru z marginesami
    window.getDisplayWindowInnerSize = function() {
        const displayWindow = document.querySelector('.display-window');
        if (!displayWindow) return null;

        const style = window.getComputedStyle(displayWindow);
        const width = displayWindow.clientWidth
                    - parseFloat(style.paddingLeft || 0)
                    - parseFloat(style.paddingRight || 0);
        const height = displayWindow.clientHeight
                     - parseFloat(style.paddingTop || 0)
                     - parseFloat(style.paddingBottom || 0);

        return [Math.floor(Math.max(0, width)), Math.floor(Math.max(0, height))];
    };

    // Funkcja do obserwacji zmiany rozmiaru
    window.observeDisplayWindowResize = function(dotNetHelper) {
        const displayWindow = document.querySelector('.display-window');
        if (!displayWindow) {
            console.error('Element .display-window nie znaleziony');
            return null;
        }

        let isProcessing = false;
        let resizeTimeout;

        const resizeObserver = new ResizeObserver(entries => {
            if (isProcessing) return;

            isProcessing = true;

            // Debounce - czekamy 50ms na zakończenie zmiany rozmiaru
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                try {
                    for (let entry of entries) {
                        const { width, height } = entry.contentRect;
                        if (width > 0 && height > 0) {
                            dotNetHelper.invokeMethodAsync('HandleResize', width, height);
                        }
                    }
                } catch (error) {
                    console.error('Błąd podczas obsługi zmiany rozmiaru:', error);
                } finally {
                    isProcessing = false;
                }
            }, 50);
        });

        resizeObserver.observe(displayWindow);

        // Obserwuj również zmiany w canvas-container
        const canvasContainer = document.querySelector('.canvas-container');
        if (canvasContainer) {
            resizeObserver.observe(canvasContainer);
        }

        return {
            disconnect: () => {
                clearTimeout(resizeTimeout);
                resizeObserver.disconnect();
            }
        };
    };

</script>

<!-- Nagłówek Skypty są zapisane w pliku \JS\canvasHelpers.js i podpięte w index.html wyłączone!!!-->

<div class="d-flex justify-content-between align-items-center mt-2 mb-2">
    <h3 class="mb-0">Modele Okienne &nbsp;</h3>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoCAD">
        OKN-CAD
    </Button>
    &nbsp;&nbsp;
    <button class="btn btn-primary" @onclick="GoBack">
        <i class="fas fa-arrow-left"></i> Wróć do poprzedniej strony
    </button>

</div>

<Collapse Animation>

    <Panel Header="Informacja o wyrobie restrykcje" Key="2" class="scrollable-panel">
        <Sider class="info-panel">
            <h4 style="color:aquamarine;">🛠️ Informacja o wyrobie:</h4>

            @if (infoObiekt != null && infoObiekt.Any())
            {
                <p class="entries-count"> 📌 Liczba wpisów: <strong>@infoObiekt.Count()</strong></p>
                <ul class="info-list">
                    @foreach (var wymiar in infoObiekt)
                    {
                        <li class="info-item">
                            <span><strong>📏 Szerokość:</strong> @wymiar.Szerokosc mm</span>
                            <span><strong>📐 Wysokość:</strong> @wymiar.Wysokosc mm</span>
                            <span><strong>🏗️ Wyrób:</strong> @wymiar.RodzajObiektu</span>
                            <span><strong>⚠️ Restrykcje:</strong> @wymiar.Restrykcja</span>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p class="no-data">❌ Brak danych o wyrobie.</p>
            }
        </Sider>
    </Panel>
    <Panel Header="Materiały" Key="3" class="scrollable-panel">
        @if (infoBoom != null && infoBoom.Any())
        {
            <p class="entries-count">📌 Liczba materiałów: <strong>@infoBoom.Count()</strong></p>
            <ul class="materials-list">
                @foreach (var material in infoBoom)
                {
                    <li class="material-item">
                        <span><strong>📏 Długość:</strong> @material.Dlugosc mm</span>
                        <span><strong>🏷️ Nazwa:</strong> @material.Nazwa</span>
                        <span><strong title="@material.RowIdIndeksu">🔢 Indeks:</strong> @material.IndeksElementu</span>
                        <span><strong>📦 Ilość sztuk:</strong> @material.IloscSztuk</span>
                        <span><strong>⚠️ Restrykcje:</strong> @material.Restrykcja</span>
                    </li>
                }
            </ul>
        }
        else
        {
            <p class="no-data">❌ Brak użytych materiałów.</p>
        }
    </Panel>

</Collapse>

<!-- Kontener na modele i canvas -->
<div class="window-model-container">
    <!-- Kontener na przyciski -->
    <div class="zoom-controls">
        <label>@mousePosition skala: @((int)(_aktywnaSkala * 100))</label>
        <button @onclick="PokazWlasciwosciOkna" class="btn-zoom" title="Wymiary okien zmień">📖</button>
        <button @onclick="UsunOstatniObiekt" class="btn-zoom" title="Usuń ostatni obiekt">🗑️</button>
        <button @onclick="ZoomIn" class="btn-zoom">➕</button>
        <button @onclick="ZoomOut" class="btn-zoom">➖</button>
        <button @onclick="PokazModal" class="btn-zoom">💎</button>
        <button class="btn btn-zoom" @onclick="OtworzPrzeglad" title="Właściwości">🔍</button>
    </div>
    <!-- Panel boczny z modelami -->
    <div class="wing-model-container">
        <!-- 🔹 Wybór systemu -->
        <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
            <div class="d-flex">
                @if (Systemy != null && Systemy.Any())
                {
                    <select class="form-select me-2" style="width:100%" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                }
            </div>
        </Tooltip>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Typ</th>
                    <th>Wymiary</th>
                    <th>Miniaturka</th>
                </tr>
            </thead>
            <tbody>
                @if (ListaModeli != null)
                {
                    @foreach (var model in ListaModeli)
                    {
                        <tr>
                            <td>@model.Typ</td>
                            <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                            <td>
                                @if (model.Rysunek != null && model.Ikona32x32.Length > 0)
                                {
                                    <img id="@($"wing-{model.Typ}")"
                                         src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                         @onclick='@(() => WybierzModel(model))'
                                         @ondragstart='@(e => JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId))'
                                         @onmouseout='@(e => JS.InvokeVoidAsync("ResetCursor"))'
                                         draggable="true"
                                         style="cursor: grab;
                                                                                                                 width: auto;
                                                                                                                 height: auto;
                                                                                                                 max-width: 50px;
                                                                                                                 max-height: 50px;
                                                                                                                 border: @(model == WybranyModel ? "4px solid #007bff" : "none")" />

                                }
                                else
                                {
                                    <span class="text-muted">Brak</span>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <!-- Główne okno wyświetlania -->

    <div class="display-window" @onmouseup="OnMouseUp" @onmousemove="OnMouseMove"
         style="position: relative; /* Wymagane dla warstw */
                overflow: visible; /* Zapobiega przycinaniu kursora */
                cursor: inherit; /* Dziedziczy kursor z JS */">

        <!-- Tutaj elementy reagujące na kursor (np. przyciski) -->
        @if (hasCanvasError)
        {
            <p style="color: red; position: relative; z-index: 100;">❌ Błąd: Nie udało się załadować canvasu!</p>
        }
        else
        {
            <!-- Canvas -->
            <div class="canvas-container" style="padding:0px;background-color: transparent;border: 0px; will-change: transform; transform: translateZ(0)">
                <BECanvas @ref="CanvasRef" Width="@CanvasWidth" Height="@CanvasHeight" />
            </div>

        }
    </div>

</div>

<div class="modal fade @classShowTWZ"
     tabindex="-1"
     @ref="modalRef"
     style="display:@displayTWZ; position:absolute; top:20vh; left:50%; width:80%;">
    <div class="modal-dialog modal-lg">
        <div class="modal-content"
             style="background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(6px); border-radius: 10px;">

            <div class="modal-header">
                <h5 class="modal-title">Punkty elementów okien</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal"></button>
            </div>

            <div class="modal-body" style="max-height: 70vh; overflow-y: auto; font-size: 0.85rem; font-family: Consolas, monospace;">
                @if (ksztalty is not null && ksztalty.Any())
                {
                    @foreach (var ksztalt in ksztalty)
                    {
                        <div class="card my-2 shadow-sm"
                             style="background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(4px);">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>Typ:</strong> @ksztalt.TypKsztaltu &nbsp;|&nbsp;
                                    <strong>Grupa:</strong> @ksztalt.Grupa &nbsp;|&nbsp;
                                    <strong>ZIndex:</strong> @ksztalt.ZIndex &nbsp;|&nbsp;<br />
                                    <strong>RowIdElementu [Indeks]:</strong> @ksztalt.RowIdElementu &nbsp; [@ksztalt.IndeksElementu] <br />
                                    <strong>Kąt:</strong> @ksztalt.Kat [@ksztalt.Strona]
                                    <strong>Offesty:</strong> L:@ksztalt.OffsetLewa G:@ksztalt.OffsetGora P:@ksztalt.OffsetPrawa D:@ksztalt.OffsetDol
                                    <br />
                                    <strong>IdRegion:</strong> @ksztalt.IdRegion
                                </div>
                                <button class="btn btn-sm btn-primary" @onclick="@(() => EdytujKsztalt(ksztalt.Id))">Edytuj</button>
                                &nbsp;
                                <button class="btn btn-sm btn-danger" @onclick="@(() => UsunKsztalt(ksztalt.Id))">Usuń</button>
                            </div>
                            <div class="card-body">
                                @if (edytowanyId == ksztalt.Id)
                                {
                                    <div class="mb-2">
                                        <label>Typ kształtu</label>
                                        <input class="form-control" @bind="ksztalt.TypKsztaltu" />
                                    </div>
                                    <!-- Pozostałe inputy jak wcześniej... -->

                                    <div class="mb-2">
                                        <label><strong>Wierzchołki (X, Y):</strong></label>
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var punkt = ksztalt.Wierzcholki[i];
                                            var lokalnyIndex = i;  // 👈 to jest klucz

                                            <div class="d-flex align-items-center mb-1" @key="punkt">
                                                <span class="me-2">[@lokalnyIndex]</span>
                                                <AntDesign.InputNumber TValue="double"
                                                                       Value="punkt.X"
                                                                       ValueChanged="@(x => ZmienX(ksztalt, lokalnyIndex, x))"
                                                                       Step="0.01"
                                                                       Precision="3"
                                                                       Style="width:100px"
                                                                       Placeholder="X" />

                                                <AntDesign.InputNumber TValue="double"
                                                                       Value="punkt.Y"
                                                                       ValueChanged="@(y => ZmienY(ksztalt, lokalnyIndex, y))"
                                                                       Step="0.01"
                                                                       Precision="3"
                                                                       Style="width:100px"
                                                                       Placeholder="Y" />

                                            </div>
                                        }
                                    </div>

                                    <button class="btn btn-success btn-sm" @onclick="@ZapiszKsztalt">Zapisz</button>
                                    <button class="btn btn-secondary btn-sm ms-2" @onclick="@AnulujEdycje">Anuluj</button>
                                }
                                else
                                {
                                    <p><strong>Wypełnienie wewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieWewnetrzne">@ksztalt.WypelnienieWewnetrzne</span></p>
                                    <p><strong>Wypełnienie zewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieZewnetrzne">@ksztalt.WypelnienieZewnetrzne</span></p>
                                    <p><strong>Grubość obramowania:</strong> @ksztalt.GruboscObramowania px</p>
                                    <p><strong>Czy zawiera otwór:</strong> @(ksztalt.CzyZawieraOtwor ? "Tak" : "Nie")</p>
                                    <p><strong>Widoczny:</strong> @(ksztalt.Widoczny ? "Tak" : "Nie")</p>
                                    <p><strong>Długość: @ksztalt.DlogoscElementu</strong></p>
                                    <p><strong>Kąt: @ksztalt.Kat</strong></p>
                                    <p><strong>Wierzchołki:</strong></p>

                                    <ul class="list-group list-group-flush">
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var index = i + 1;
                                            <li class="list-group-item">
                                                [@index] X: @(Math.Round(ksztalt.Wierzcholki[i].X, 3)), Y: @(Math.Round(ksztalt.Wierzcholki[i].Y, 3))
                                            </li>
                                        }
                                    </ul>
                                }
                            </div>
                        </div>
                    }

                    <hr>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @constWlasciwosciOkna.Szerokosc x @constWlasciwosciOkna.Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu / Rama:</strong> @region.TypLiniiDzielacej / @region.Rama</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="i">
                                                    <span class="me-2">[@index]</span>
                                                    X:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].X"
                                                                           ValueChanged="@(x => SetX(region, i, x))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />

                                                    Y:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].Y"
                                                                           ValueChanged="@(y => SetY(region, i, y))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                                {
                                                    var index = i + 1;

                                                    <li class="list-group-item">
                                                        [@index] X: @(Math.Round(region.Wierzcholki[i].X, 3)), Y: @(Math.Round(region.Wierzcholki[i].Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu / Rama:</strong> @region.TypLiniiDzielacej / @region.Rama</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="i">
                                                    <span class="me-2">[@index]</span>
                                                    X:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].X"
                                                                           ValueChanged="@(x => SetX(region, i, x))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />

                                                    Y:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].Y"
                                                                           ValueChanged="@(y => SetY(region, i, y))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Region szkic">
                            @if (ShapeService.Shapes.Count > 0)
                            {
                                <div class="property-panel">
                                    <h3>Właściwości kształtu</h3>

                                    @if (_selectedShapeIndex >= 0)
                                    {
                                        @foreach (var prop in ShapeService.Shapes[_selectedShapeIndex].GetEditableProperties())
                                        {
                                            <div class="property-row">
                                                <span class="property-label">[@prop.NazwaObiektu] - @prop.Label</span>
                                                @if (!prop.IsReadOnly)
                                                {
                                                    <input class="property-input" type="number"
                                                           @bind="prop.Value"
                                                           @bind:event="onchange"
                                                           @bind:after="async () => await ApplyChange()" />
                                                }
                                                else
                                                {
                                                    <span class="property-value">@prop.Value</span>
                                                }
                                            </div>
                                        }
                                    }

                                    <button @onclick="SelectPreviousShape">Poprzedni obiekt</button>
                                    <button @onclick="SelectNextShape">Następny obiekt</button>

                                </div>

                            }
                            else
                            {
                                <p class="text-muted">Brak kształtów do wyświetlenia.</p>
                            }
                        </TabPane>
                    </Tabs>

                }
                else
                {
                    <p class="text-muted">Brak danych do wyświetlenia 😔 nie wygenerowano okien</p>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @constWlasciwosciOkna.Szerokosc x @constWlasciwosciOkna.Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu / Rama:</strong> @region.TypLiniiDzielacej / @region.Rama</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="i">
                                                    <span class="me-2">[@index]</span>
                                                    X:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].X"
                                                                           ValueChanged="@(x => SetX(region, i, x))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />

                                                    Y:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].Y"
                                                                           ValueChanged="@(y => SetY(region, i, y))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                                {
                                                    var index = i + 1;

                                                    <li class="list-group-item">
                                                        [@index] X: @(Math.Round(region.Wierzcholki[i].X, 3)), Y: @(Math.Round(region.Wierzcholki[i].Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3" style="color:red;"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="i">
                                                    <span class="me-2">[@index]</span>
                                                    X:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].X"
                                                                           ValueChanged="@(x => SetX(region, i, x))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />

                                                    Y:
                                                    <AntDesign.InputNumber Value="region.Wierzcholki[i].Y"
                                                                           ValueChanged="@(y => SetY(region, i, y))"
                                                                           Step="0.001"
                                                                           Precision="3"
                                                                           TValue="double"
                                                                           Style="width:150px" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                                {
                                                    var index = i + 1;

                                                    <li class="list-group-item">
                                                        [@index] X: @(Math.Round(region.Wierzcholki[i].X, 3)), Y: @(Math.Round(region.Wierzcholki[i].Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Region szkic">
                            @if (ShapeService.Shapes.Count > 0)
                            {
                                <div class="property-panel">
                                    <h3>Właściwości kształtu</h3>

                                    @if (_selectedShapeIndex >= 0)
                                    {
                                        @foreach (var prop in ShapeService.Shapes[_selectedShapeIndex].GetEditableProperties())
                                        {
                                            <div class="property-row">
                                                <span class="property-label">[@prop.NazwaObiektu] - @prop.Label</span>
                                                @if (!prop.IsReadOnly)
                                                {
                                                    <input class="property-input" type="number"
                                                           @bind="prop.Value"
                                                           @bind:event="onchange"
                                                           @bind:after="async () => await ApplyChange()" />
                                                }
                                                else
                                                {
                                                    <span class="property-value">@prop.Value</span>
                                                }
                                            </div>
                                        }
                                    }

                                    <button @onclick="SelectPreviousShape">Poprzedni obiekt</button>
                                    <button @onclick="SelectNextShape">Następny obiekt</button>

                                </div>

                            }
                            else
                            {
                                <p class="text-muted">Brak kształtów do wyświetlenia.</p>
                            }
                        </TabPane>
                    </Tabs>
                }
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal" title="Zamknij okno"></button>
            </div>
        </div>
    </div>
</div>

<Modal Title="Podgląd danych wygenerowanych "
       Visible="@_generatorState"
       OnOk="@HandleCancel"
       OnCancel="@HandleCancel"
       Maximizable="@true"
       Centered="@true"
       DefaultMaximized="@true">
    <Generator_state_viewer StateContainer="StateContainer"></Generator_state_viewer>
</Modal>

<Modal Title="Właściwości okna"
       Visible="@_constWlasciwosciOkna"
       OnOk="@HandleZapis"
       OnCancel="@HandleWOCancel"
       Width="@("50%")"
       Centered="true"
       Maximizable="true">

    <ZmienWymiaryOkna Model="constWlasciwosciOkna" BlokujWysokosc="_constWlasciwosciOknaBlokujWys"
                      OnSave="PrzyjmijZmiany">
    </ZmienWymiaryOkna>

</Modal>

@code {

    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private KonfModele? WybranyModel { get; set; }

    private string WybranyKsztalt = "prostokat";

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef; // Referencja do komponentu BECanvas
    private Canvas2DContext? _context;
    private DotNetObjectReference<Modele_okienne>? _dotNetHelper;

    // Dodaj nowe pola w sekcji @code
    private string? SelectedModelType { get; set; }
    private string? SelectedRowIdType { get; set; }
    // private double DropX { get; set; }
    // private double DropY { get; set; }
    private ElementReference canvasElement;

    private double _aktywnaSkala = 1.0;
    // //private const double ScaleFactor = 1.1;
    // private double _panX = 0;
    // private double _panY = 0;

    private long CanvasWidth { get; set; } = 900;
    private long CanvasHeight { get; set; } = 600;

    // private double _zoomCenterX = 450; // Środek canvasu
    // private double _zoomCenterY = 300;

    private List<WyrobWymiaryOpis>? infoObiekt;

    private List<WygenerowaneMaterialy> infoBoom = new List<WygenerowaneMaterialy>();

    // private List<IShapeDC> _shapes = new List<IShapeDC>();

    private List<ShapeRegion> _regionsDualRama = new();
    private List<ShapeRegion> _regionsSkrzydlo = new();

    private double _offsetX = 0;
    private double _offsetY = 0;

    private string woodPatternName = "sosna.jpg"; // Nazwa pliku do wzoru drewna meranti.jpg wood.jpg

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private string classShowTWZ = "";
    private string displayTWZ = "none";
    private string edytowanyId = "";

    private string classShowWO = "";
    private string displayWO = "none";

    private string edytowanyIdshape = "";

    private string mousePosition = "X: 0, Y: 0";

    private string? edytowanyRegionId;

    private Dictionary<string, List<KsztaltElementu>> _ksztaltyNaRegion = new();
    private List<KsztaltElementu> ksztalty = new();

    private Dictionary<string, GeneratorState> _generatorStates = new();
    //   private readonly Dictionary<string, Generator> _generatory = new();

    private ConstWlasciwosciOkna? constWlasciwosciOkna = new ConstWlasciwosciOkna();
    private ZmienWymiaryOkna? zmienWymiaryOknaRef = new ZmienWymiaryOkna();

    private bool _generatorState = false;
    private bool _constWlasciwosciOkna = false;
    private bool _constWlasciwosciOknaBlokujWys = false;

    private int _selectedShapeIndex = 0; // Przechowuje indeks aktualnie edytowanego kształtu

    private ElementReference modalRef;

    private bool _disposed = false;
    private IJSObjectReference? _resizeObserver;
    private bool _isInitialized = false;

    private bool _czekajNaZmianeRozmiaru = false;

    protected override async Task OnInitializedAsync()
    {

        Console.WriteLine($"🔥🔥🔥🔥🔥🔥🔥 Modele-okienne OnInitializedAsync 🔥🔥🔥🔥🔥🔥🔥🔥");

        try
        {

            Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

            // Sprawdź, czy skrypt JS został poprawnie załadowany

            var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
            if (!isScriptLoaded)
            {
                throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas inicjalizacji: {ex.Message}");
        }

        await Laduj_Uprawnienia();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && CanvasRef != null && !_disposed)
        {
            try
            {
                Console.WriteLine("🔄 Inicjalizacja canvasu...");

                // Inicjalizacja modal drag
                await JS.InvokeVoidAsync("prepareModalForDrag", modalRef);
                await JS.InvokeVoidAsync("enableModalDrag", modalRef);

                // Kontekst canvas
                if (_context == null)
                {
                    _context = await CanvasRef.CreateCanvas2DAsync();
                }

                // Rozmiar canvas
                await UpdateCanvasSizeFromDisplayWindow();

                // DotNetHelper
                if (_dotNetHelper == null)
                {
                    _dotNetHelper = DotNetObjectReference.Create(this);
                    await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
                }

                // Obserwacja resize
                await StartResizeObserver();

                // Teraz rysujemy tylko jeśli dane są gotowe
                if (ShapeService != null && ShapeService.Shapes.Any())
                {

                    await GenerujObrysPozZmianieWymiarow(true); // obrys i regiony
                    //
                    await ZmienWymiaryOkna(); // dopasowanie do okna i wygenerowanie obrysu

                    await FitShapesToDisplayWindow();           // dopasowanie do canvas
                    // await RenderShapesIfReady(); // <--- dodaj to
                }

                _isInitialized = true;

                Console.WriteLine("✅ Canvas zainicjalizowany!");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"🔥 Błąd inicjalizacji canvasu: {ex.Message}");
                hasCanvasError = true;
                StateHasChanged();
            }
        }
    }

    // Metoda do pobierania i aktualizacji rozmiaru z .display-window
    private async Task UpdateCanvasSizeFromDisplayWindow()
    {
        try
        {
            Console.WriteLine("⚠️ UpdateCanvasSizeFromDisplayWindow - START");

            var displayWindowSize = await JS.InvokeAsync<double[]>("getDisplayWindowSize");
            if (displayWindowSize != null && displayWindowSize.Length == 2)
            {
                var newWidth = (long)displayWindowSize[0];
                var newHeight = (long)displayWindowSize[1];

                // Sprawdź czy rozmiar się zmienił
                if (newWidth != CanvasWidth || newHeight != CanvasHeight)
                {
                    CanvasWidth = newWidth;
                    CanvasHeight = newHeight;



                    // Console.WriteLine($"📐 Rozmiar .display-window: {CanvasWidth}x{CanvasHeight}");

                    // // Aktualizuj środek zoomu
                    // _zoomCenterX = CanvasWidth / 2.0;
                    // _zoomCenterY = CanvasHeight / 2.0;

                    // StateHasChanged();
                }
            }
            else
            {
                Console.WriteLine("⚠️ Nie udało się pobrać rozmiaru .display-window");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Błąd pobierania rozmiaru: {ex.Message}");
        }
    }

    // Rozpocznij obserwację zmiany rozmiaru
    private async Task StartResizeObserver()
    {
        Console.WriteLine("⚠️ StartResizeObserver - START");

        try
        {
            _resizeObserver = await JS.InvokeAsync<IJSObjectReference>(
                "observeDisplayWindowResize",
                DotNetObjectReference.Create(this)
            );
            Console.WriteLine("👀 Rozpoczęto obserwację zmiany rozmiaru");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Nie udało się uruchomić obserwacji rozmiaru: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task HandleResize(double width, double height)
    {


        try
        {
            if (_context == null || !_isInitialized || _constWlasciwosciOkna || _czekajNaZmianeRozmiaru)
                return; // ignorujemy resize podczas inicjalizacji

            Console.WriteLine("⚠️ HandleResize - START 🔄 Zmiana rozmiaru na: {width}x{height}");

            CanvasWidth = (long)width * 5;
            CanvasHeight = (long)height * 5;

            if (ShapeService != null && ShapeService.Shapes.Any())
            {
                await ApplyZoom();
                await Task.Delay(20); // Małe opóźnienie dla stabilności
                //await FitShapesToDisplayWindow();
            }
            // // else
            // // {
            // //     await ApplyZoom();
            // // }

            // // StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Błąd obsługi zmiany rozmiaru: {ex.Message}");
        }
    }

    private async Task FitShapesToDisplayWindow()
    {

        Console.WriteLine("⚠️ FitShapesToDisplayWindow - START");

        if (ShapeService == null || !ShapeService.Shapes.Any())
            return;

        try
        {

            Console.WriteLine($"📏 Dostosowywanie kształtów do okna: {CanvasWidth}x{CanvasHeight}");

            // 6. Przesuń kształty (zapisz offset dla późniejszych obliczeń)
            _offsetX = 0; //ShapeService.Shapes.Min(s => s.GetBoundingBox().X);
            _offsetY = 0;//ShapeService.Shapes.Min(s => s.GetBoundingBox().Y);

            Console.WriteLine($"🎯 Offset: X={_offsetX:F0}, Y={_offsetY:F0}");

            // 7. Zapisz region i odśwież
            // await ZapiszRegion();
            //await Task.Delay(50); // Małe opóźnienie dla stabilności
            await ApplyZoom();

            // StateHasChanged();

            Console.WriteLine($"✅ Kształty dopasowane. Skala: {_aktywnaSkala:F3}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Błąd skalowania kształtów: {ex.Message}");
        }

    }

    public async ValueTask DisposeAsync()
    {
        if (_resizeObserver != null)
        {
            try
            {
                await _resizeObserver.InvokeVoidAsync("disconnect");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"⚠️ Błąd zatrzymania obserwacji: {ex.Message}");
            }
        }

        _dotNetHelper?.Dispose();
        _disposed = true;
    }

    //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    private async Task GenerujObrysPozZmianieWymiarow(bool generujRegionyZPodzialu)
    {
        if (ShapeService == null || !ShapeService.Shapes.Any())
        {
            Console.WriteLine("⚠ GenerujObrysPozZmianieWymiarow: Brak kształtów");
            return;
        }

        try
        {

            // 🔹 1️⃣ Wydłuż linie do granic kształtów
            LineUtils.ExtendLinesToShapes(ShapeService.Shapes, 1);

            // 🔹 2️⃣ Rozmieść linie
            LineUtils.DistributeLines(ShapeService.Shapes);

            // 🔹 3️⃣ Przytnij linie
            LineUtils.ShortenLinesInsideShapes(ShapeService.Shapes, 1);

            // 🔹 4️⃣ Ponownie wydłuż linie do granic i przytnij (jeśli potrzebne)
            LineUtils.ExtendLinesToShapes(ShapeService.Shapes, 1);
            LineUtils.ShortenLinesInsideShapes(ShapeService.Shapes, 1);

            // 🔹 5️⃣ Generowanie regionów jeśli trzeba
            if (generujRegionyZPodzialu && constWlasciwosciOkna != null)
            {
                _regionsDualRama = await GeometryUtils.GenerujRegionyZPodzialu(
                    ShapeService.Shapes,
                    (int)constWlasciwosciOkna.Szerokosc,
                    (int)constWlasciwosciOkna.Wysokosc,
                    true
                );

                _regionsSkrzydlo = await GeometryUtils.GenerujRegionyZPodzialu(
                    ShapeService.Shapes,
                    (int)constWlasciwosciOkna.Szerokosc,
                    (int)constWlasciwosciOkna.Wysokosc,
                    false
                );

            // 🔹 5️⃣ **Dopiero teraz przesuwamy wszystko do dodatniej ćwiartki**
           // LineUtils.ShiftAllShapesToPositiveQuadrant(ShapeService.Shapes);

                Console.WriteLine($"🗺️ Wygenerowano regiony: {_regionsDualRama.Count} rama, {_regionsSkrzydlo.Count} skrzydło");
            }

            Console.WriteLine("✅ Generowanie obrysu zakończone");

            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd generowania obrysu: {ex.Message}");
        }
    }

    private bool TryGetVerticalSpanInTriangle(
    double x,
    XTriangleShape t,
    out double yMin,
    out double yMax)
    {
        yMin = yMax = 0;

        var bb = t.GetBoundingBox();

        double apexX = bb.X + bb.Width / 2.0;
        double apexY = bb.Y;

        double baseLeftX = bb.X;
        double baseRightX = bb.X + bb.Width;
        double baseY = bb.Y + bb.Height;

        if (x < baseLeftX || x > baseRightX)
            return false;

        double slope = bb.Height / (bb.Width / 2.0);

        double yTop;
        if (x <= apexX)
            yTop = apexY + slope * (apexX - x);
        else
            yTop = apexY + slope * (x - apexX);

        yMin = yTop;
        yMax = baseY;

        return yMin < yMax;
    }


    public static void ShortenVerticalLineToTriangle(
    XLineShape line,
    XTriangleShape triangle,
    double epsilon = 0.0001)
    {
        // Bezpiecznik – tylko linia pionowa
        if (Math.Abs(line.X1 - line.X2) > epsilon)
            return;

        double x = line.X1;

        var vertices = triangle.GetVertices();

        var intersections = new List<double>();

        // Iterujemy po bokach trójkąta
        for (int i = 0; i < vertices.Count; i++)
        {
            var p1 = vertices[i];
            var p2 = vertices[(i + 1) % vertices.Count];

            // Pomijamy krawędzie pionowe – nie dadzą przecięcia w Y
            if (Math.Abs(p1.X - p2.X) < epsilon)
                continue;

            // Sprawdź czy pionowa linia przecina zakres X krawędzi
            if (x < Math.Min(p1.X, p2.X) - epsilon ||
                x > Math.Max(p1.X, p2.X) + epsilon)
                continue;

            // Równanie parametryczne krawędzi
            double t = (x - p1.X) / (p2.X - p1.X);

            if (t < -epsilon || t > 1 + epsilon)
                continue;

            double y = p1.Y + t * (p2.Y - p1.Y);

            intersections.Add(y);
        }

        // Trójkąt musi dać dokładnie 2 przecięcia
        if (intersections.Count < 2)
            return;

        intersections.Sort();

        line.Y1 = intersections.First();
        line.Y2 = intersections.Last();
    }


    private void SelectNextShape()
    {
        if (ShapeService.Shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex + 1) % ShapeService.Shapes.Count;
    }

    private void SelectPreviousShape()
    {
        if (ShapeService.Shapes.Count == 0) return;
        _selectedShapeIndex = (_selectedShapeIndex - 1 + ShapeService.Shapes.Count) % ShapeService.Shapes.Count;
    }

    private void WybierzModel(KonfModele model)
    {
        WybranyModel = model;
        // Dodatkowe akcje przy wyborze modelu
        JS.InvokeVoidAsync("SetCustomCursor", Convert.ToBase64String(model.Ikona32x32));
        JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId);
    }

    void ZmienX(KsztaltElementu ksztalt, int index, double newX)
    {
        var punkt = ksztalt.Wierzcholki[index];
        punkt.X = newX;
        ksztalt.Wierzcholki[index] = punkt;
        Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newX}");
    }


    void ZmienY(KsztaltElementu ksztalt, int index, double newY)
    {
        var punkt = ksztalt.Wierzcholki[index];
        punkt.Y = newY;
        ksztalt.Wierzcholki[index] = punkt;
        Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newY}");
    }

    private async Task EdytujKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null && !_disposed)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        edytowanyId = id;
        Console.WriteLine($"edytowanyId: {edytowanyId}");
    }
    private async Task UsunKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null && !_disposed)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        ksztalty.RemoveAll(k => k.Id == id);

        // ---------------------------------------------------------
        // 6) Dopasowanie widoku
        // ---------------------------------------------------------
        //  await FitToScreen();
        await FitShapesToDisplayWindow();

        Console.WriteLine($"Usunołem dla id: {id}");
    }

    private async Task ZapiszKsztalt()
    {
        // Nie zmieniaj listy ksztalty – dane są już w niej zaktualizowane przez binding
        edytowanyId = "";
        await RenderFrame(false);
    }


    private void AnulujEdycje()
    {
        edytowanyId = "";
    }

    private void ZmienXShape(IShapeDC shape, int index, double value)
    {
        if (shape?.Points == null)
            return;

        if (index < 0 || index >= shape.Points.Count)
            return;

        var p = shape.Points[index];
        p.X = (float)value;
        shape.Points[index] = p;

    }

    private void ZmienYShape(IShapeDC shape, int index, double value)
    {
        if (shape?.Points == null)
            return;

        if (index < 0 || index >= shape.Points.Count)
            return;

        var p = shape.Points[index];
        p.Y = (float)value;
        shape.Points[index] = p;

    }

    void SetX(ShapeRegion region, int index, double x)
    {
        var p = region.Wierzcholki[index]; // kopia
        p.X = x;
        region.Wierzcholki[index] = p;     // nadpisanie
    }

    void SetY(ShapeRegion region, int index, double y)
    {
        var p = region.Wierzcholki[index]; // kopia
        p.Y = y;
        region.Wierzcholki[index] = p;     // nadpisanie
    }

    private async Task ZapiszRegion()
    {
        edytowanyRegionId = null;

        //await ClearCanvas();

        await ApplyZoom();

        // await Task.Delay(50);

        //  StateHasChanged(); // aby odświeżyć widok
    }

    private void ZamknijWlasciwosciOkn()
    {
        classShowWO = "";
        displayWO = "none";
    }

    private void ZamknijModal()
    {
        classShowTWZ = "";
        displayTWZ = "none";
    }

    private async Task PokazModal()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowTWZ = "show";
        displayTWZ = "block";
    }

    private async Task OtworzPrzeglad()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        StateContainer.States = _generatorStates
            .ToDictionary(
                entry => entry.Key,
                entry => entry.Value.Clone()
            );

        if (_generatorStates.Count == 0)
        {
            await _message.Warning("Brak zapisanych stanów generatora.", 1.5);
            return;
        }

        await Task.Delay(5); // Krótkie opóźnienie dla płynności

        _generatorState = true;

    }

    private void HandleCancel(MouseEventArgs e)
    {
        _generatorState = false;
    }

    private async Task PokazWlasciwosciOkna()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowWO = "show";
        displayWO = "block";

        _constWlasciwosciOknaBlokujWys = false;

        if (ShapeService.Shapes != null && ShapeService.Shapes.Count > 0)
        {
            if (!ShapeService.Shapes.Any(s => s == null))
            {
                if (ShapeService.Shapes[0].GetType() == typeof(GEORGE.Client.Pages.Models.XSquareShape) || ShapeService.Shapes[0].GetType() == typeof(GEORGE.Client.Pages.Models.XCircleShape))
                {
                    if (constWlasciwosciOkna != null)
                        constWlasciwosciOkna.Wysokosc = constWlasciwosciOkna.Szerokosc;

                    _constWlasciwosciOknaBlokujWys = true;
                }
            }
        }

        //await Task.Delay(50); // Krótkie opóźnienie dla płynności

        _constWlasciwosciOkna = true;
    }

    private void HandleWOCancel(MouseEventArgs e)
    {
        _constWlasciwosciOkna = false;
    }

    private async Task HandleZapis()
    {
        // Wywołanie zapisu w komponencie ZmienWymiaryOkna

        if (zmienWymiaryOknaRef == null) return;

        _constWlasciwosciOkna = false; // zamknie modal

        _czekajNaZmianeRozmiaru = true;

        await zmienWymiaryOknaRef.ZapiszDoRodzica();

        await ZmienWymiaryOkna();

        // await FitShapesToDisplayWindow();

        // await ZmienWymiaryOkna();

        // await Task.Delay(5); // Krótkie opóźnienie dla płynności

        //_czekajNaZmianeRozmiaru = false;

        //await InvokeAsync(StateHasChanged);

    }
    // Odbiór zmienionych danych z dziecka
    private void PrzyjmijZmiany(ConstWlasciwosciOkna zmieniony)
    {
        constWlasciwosciOkna = zmieniony;
        //  Console.WriteLine("Zmieniono wymiary!");
        // StateHasChanged();
    }

    private async Task DrawAllCanvasElements()
    {
        if (_context == null || ShapeService?.Shapes == null)
            return;

        try
        {
            // 1. Narysuj strukturę i restrykcje (jeśli potrzebne)
            if (isTextureLoaded)
            {
                await DrawStructureAndRestrykcje();
            }

            await _context.BeginBatchAsync();
            // 2. Narysuj wszystkie kształty
            foreach (var shape in ShapeService.Shapes)
            {
                if (shape?.Points != null && shape.Points.Count > 0)
                {
                    await shape.Draw(_context);
                }
            }
            await _context.EndBatchAsync();
            // 3. Renderuj ramkę (jeśli potrzebna)
            await RenderFrame();



            // Console.WriteLine($"🎨 Narysowano {ShapeService.Shapes.Count} kształtów");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Błąd rysowania: {ex.Message}");
        }
    }

    // private async Task ApplyTransformations()
    // {
    //     if (_context == null)
    //         return;

    //     try
    //     {
    //         // Zamiast ResetTransformAsync, używamy SetTransformAsync z wartościami domyślnymi
    //         // Reset transformacji: matrix(1, 0, 0, 1, 0, 0)
    //         await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);

    //         // Przesuń do środka
    //         await _context.TranslateAsync(0, 0);

    //         // Zastosuj skalowanie
    //         // await _context.ScaleAsync(_currentScale, _currentScale);

    //         // Console.WriteLine($"🔄 Transformacje: Pan({_panX:F1},{_panY:F1}), Scale({_currentScale:F2})");
    //     }
    //     catch (Exception ex)
    //     {
    //         Console.WriteLine($"⚠️ Błąd transformacji: {ex.Message}");
    //     }
    // }

    private async Task ClearCanvas()
    {
        try
        {
            if (_context == null)
                return;

            // Console.WriteLine($"🧹 Czyszczenie canvasu: {CanvasWidth}x{CanvasHeight}");

            // 1. Zresetuj transformacje
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);

            // 2. Ustaw styl wypełnienia na biały
            await _context.SetFillStyleAsync("white");

            // 3. Wypełnij cały obszar (nawet poza canvasem dla pewności)
            await _context.FillRectAsync(-10, -10, CanvasWidth + 20, CanvasHeight + 20);

            // 4. Wyczyść obszar canvasu
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // // 5. Dla pewności wyczyść jeszcze raz
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Console.WriteLine("✅ Canvas wyczyszczony");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"⚠️ Błąd czyszczenia canvasu: {ex.Message}");
        }
    }

    private async Task UsunOstatniObiekt()
    {
        if (_generatorStates.Count == 0)
            return;

        var ostatni = _generatorStates.Keys.LastOrDefault();
        if (string.IsNullOrWhiteSpace(ostatni))
            return;

        if (_generatorStates.TryGetValue(ostatni, out var state))
        {

            _generatorStates.Remove(ostatni);

            _ksztaltyNaRegion.Remove(state.IdRegion);
            ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
        }


        //  await ClearCanvas();

        isTextureLoaded = false;

        await Task.Delay(10);
        // await RedrawCanvas();
        await DrawStructureAndRestrykcje();

        await ApplyZoom();

    }



    private async Task ApplyChange()
    {

        _regionsDualRama[_selectedShapeIndex].Wierzcholki =
        ShapeService.Shapes[_selectedShapeIndex].GetNominalPoints();

        _regionsSkrzydlo[_selectedShapeIndex].Wierzcholki =
            ShapeService.Shapes[_selectedShapeIndex].GetNominalPoints();

        await GenerujObrysPozZmianieWymiarow(false);
    }

    private async Task ZoomIn()
    {
        var newScale = _aktywnaSkala * 1.2;

        // Ogranicz maksymalny zoom (np. 10x)
        if (newScale > 10.0)
        {
            Console.WriteLine("⛔ Osiągnięto maksymalny zoom (10x)");
            return;
        }

        await ApplyZoom(newScale);
    }

    private async Task ZoomOut()
    {
        var newScale = _aktywnaSkala / 1.2;

        // Ogranicz minimalny zoom
        newScale = Math.Max(newScale, 0.1);

        await ApplyZoom(newScale);
    }

    private async Task ApplyZoom(double newScale = -1)
    {
        if (CanvasWidth == 0 || CanvasHeight == 0 || CanvasRef == null)
        {
            Console.WriteLine("⚠️ Canvas nie jest gotowy do zoomu");
            return;
        }

        try
        {

            if (newScale == -1)
            {
                // 1. Oblicz bounding box kształtów
                double minX = ShapeService.Shapes.Min(s => s.GetBoundingBox().X);
                double minY = ShapeService.Shapes.Min(s => s.GetBoundingBox().Y);
                double maxX = ShapeService.Shapes.Max(s => s.GetBoundingBox().X + s.GetBoundingBox().Width);
                double maxY = ShapeService.Shapes.Max(s => s.GetBoundingBox().Y + s.GetBoundingBox().Height);

                double shapesWidth = maxX - minX;
                double shapesHeight = maxY - minY;

                // Console.WriteLine($"📐 Kształty: szerokość={shapesWidth:F0}, wysokość={shapesHeight:F0}");
                //  Console.WriteLine($"📐 Bounding box: X[{minX:F0}-{maxX:F0}], Y[{minY:F0}-{maxY:F0}]");

                // 2. Oblicz skalę z marginesem 5% (zmniejszono z 10% dla lepszego dopasowania)
                double scaleX = CanvasWidth / shapesWidth;
                double scaleY = CanvasHeight / shapesHeight;
                double scale = Math.Min(scaleX, scaleY) * 0.95; // 5% marginesu

                _aktywnaSkala = scale;
            }
            else
            {
                _aktywnaSkala = newScale;
            }

            // Console.WriteLine($"🔍 ZOOM: nowa skala = {newScale:F2}, aktualna skala = {_aktywnaSkala:F2}");


            if (_context == null)
            {
                //   Console.WriteLine("♻️ Odtwarzam kontekst Canvas...");
                _context = await CanvasRef.CreateCanvas2DAsync();
            }

            // 1. Zresetuj transformacje
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);

            await ClearCanvas();

            await _context.ScaleAsync(_aktywnaSkala, _aktywnaSkala);

            // 4. Narysuj wszystkie elementy
            await DrawAllCanvasElements();

            StateHasChanged();

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas zoomowania: {ex.Message}");
        }

    }

    private async Task FitToCanvas(IShapeDC targetShape, string idRegion, bool skalaAutomatyczna, List<XPoint> Wierzcholki, double klikX, double klikY)
    {

        Console.WriteLine($"🔍 FitToCanvas --> Dopasowano do shape: scale={_aktywnaSkala:F2}");

        // await DrawStructureAndRestrykcje(0);

        //await Task.Delay(250); // Krótkie opóźnienie dla płynności

        //if (await DodajWybranyKwadratOkna(idRegion, Wierzcholki) == false) return; // teraz z idRegion

        if (WybranyModel.Typ == "Słupek stały")
        {
            var match = ObliczWierzcholkiSlupkaStalego(Wierzcholki, klikX, klikY);

            var WierzcholkiST = match.Wierzcholki;
            var RegionIds = match.RegionIds;

            if (!await DodajWybranyKwadratOkna(idRegion, WierzcholkiST, klikX, klikY, true, RegionIds, Wierzcholki))
                return;
        }
        else
        {
            if (!await DodajWybranyKwadratOkna(idRegion, Wierzcholki, klikX, klikY, false, null, null))
                return;
        }

        await DrawStructureAndRestrykcje(0);

        isTextureLoaded = false;

        await ApplyZoom();

        // await UpdateCanvasSizeFromDiv();
        // await RenderFrame();

    }

    private SlupekMatchResult ObliczWierzcholkiSlupkaStalego(
        List<XPoint> wierzcholki,
        double klikX,
        double klikY)
    {
        var best = new SlupekMatchResult();
        double bestDist = double.MaxValue;

        if (wierzcholki == null || wierzcholki.Count < 2)
            return best;

        // Znormalizowane punkty kliknięcia
        var klik = new XPoint(Math.Round(klikX, 3), Math.Round(klikY, 3));

        var wszystkieRegiony = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .Where(r => r.Wierzcholki != null && r.Wierzcholki.Count == 2 && r.TypLiniiDzielacej == "Słupek stały")
            .ToList();

        Console.WriteLine($"🔍 ObliczWierzcholkiSlupkaStalego - liczba regionów: {wszystkieRegiony.Count}");

        foreach (var reg in wszystkieRegiony)
        {
            var pkt = reg.Wierzcholki.Select(p => new XPoint(Math.Round(p.X, 3), Math.Round(p.Y, 3))).ToList();
            double dist = DistancePointToSegment(klik, pkt[0], pkt[1]);

            Console.WriteLine($"🔍 Region {reg.Id} - odległość od kliknięcia: {dist}");

            if (dist < bestDist)
            {
                bestDist = dist;
                best = new SlupekMatchResult();
                best.Wierzcholki.AddRange(pkt);
                best.RegionIds.Add(reg.Id);

                Console.WriteLine($"🔍 Nowy najlepszy: Region ID {reg.Id}, dist={dist}");
            }
        }

        // Jeśli znaleziono linię, stwórz prostokąt 4 punktowy
        if (best.Wierzcholki.Count == 2)
        {
            Console.WriteLine("🔍 Znaleziono linię słupka - tworzę prostokąt");
            best.Wierzcholki = UtworzProstokatWokolLinii(best.Wierzcholki, 82.0); // 82 = grubość słupka
        }

        Console.WriteLine($"🔍 Wynik końcowy: znaleziono {best.Wierzcholki.Count} punktów, {best.RegionIds.Count} regionów");

        return best;
    }

    // Nowa pomocnicza funkcja do tworzenia prostokąta wokół linii
    private List<XPoint> UtworzProstokatWokolLinii(List<XPoint> linia, double grubosc)
    {
        if (linia.Count != 2) return linia;

        var p1 = linia[0];
        var p2 = linia[1];

        // Sprawdź orientację
        bool pionowy = Math.Abs(p1.X - p2.X) < 1e-6;
        bool poziomy = Math.Abs(p1.Y - p2.Y) < 1e-6;

        List<XPoint> prostokat = new List<XPoint>();
        double halfGrubosc = grubosc / 2;

        if (pionowy)
        {
            // Linia pionowa
            double x = p1.X;
            double y1 = Math.Min(p1.Y, p2.Y);
            double y2 = Math.Max(p1.Y, p2.Y);

            prostokat.Add(new XPoint(x - halfGrubosc, y1)); // lewy dolny
            prostokat.Add(new XPoint(x + halfGrubosc, y1)); // prawy dolny
            prostokat.Add(new XPoint(x + halfGrubosc, y2)); // prawy górny
            prostokat.Add(new XPoint(x - halfGrubosc, y2)); // lewy górny
        }
        else if (poziomy)
        {
            // Linia pozioma
            double y = p1.Y;
            double x1 = Math.Min(p1.X, p2.X);
            double x2 = Math.Max(p1.X, p2.X);

            prostokat.Add(new XPoint(x1, y - halfGrubosc)); // lewy dolny
            prostokat.Add(new XPoint(x2, y - halfGrubosc)); // prawy dolny
            prostokat.Add(new XPoint(x2, y + halfGrubosc)); // prawy górny
            prostokat.Add(new XPoint(x1, y + halfGrubosc)); // lewy górny
        }
        else
        {
            // Linia skośna - zostawiamy oryginalną linię
            Console.WriteLine($"⚠️ Linia słupka jest skośna - nie tworzę prostokąta");
            return linia;
        }

        Console.WriteLine($"🔍 Utworzono prostokąt z {prostokat.Count} punktami");
        return prostokat;
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (CanvasRef == null || _constWlasciwosciOkna) return;

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa (uwzględnia marginesy i DPI)
        double relativeX = (e.ClientX - rect.Left) * rect.ScaleX;
        double relativeY = (e.ClientY - rect.Top) * rect.ScaleY;

        // Przeliczenie na współrzędne modelu
        double modelX = (relativeX - _offsetX) / _aktywnaSkala;
        double modelY = (relativeY - _offsetY) / _aktywnaSkala;

        // Ograniczenie do obszaru modelu
        modelX = Math.Clamp(modelX, 0, constWlasciwosciOkna.Szerokosc);
        modelY = Math.Clamp(modelY, 0, constWlasciwosciOkna.Wysokosc);

        mousePosition = $"X: {modelX:F0} mm, Y: {modelY:F0} mm ";// (skala: {_currentScale:F2})";
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_context == null) return;

        if (CanvasRef == null)
        {
            Console.WriteLine("⚠️ Brak referencji do canvasu!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            await _message.Warning("Wybierz system okienny przed przeciągnięciem modelu.", 1.5);
            return;
        }

        if (WybranyModel == null)
        {
            await _message.Warning("Wybierz model z listy przed przeciągnięciem.", 1.0);
            return;
        }

        // Pobierz informacje o przeciąganym modelu
        var draggedInfo = await GetDraggedModelInfoAsync();
        if (draggedInfo != null && !string.IsNullOrEmpty(draggedInfo.Type))
        {
            SelectedModelType = draggedInfo.Type;
            SelectedRowIdType = draggedInfo.RowId;
        }

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa (uwzględnia marginesy i DPI)
        double relativeX = (e.ClientX - rect.Left) * rect.ScaleX;
        double relativeY = (e.ClientY - rect.Top) * rect.ScaleY;

        // Przeliczenie na współrzędne modelu
        double modelX = (relativeX - _offsetX) / _aktywnaSkala;
        double modelY = (relativeY - _offsetY) / _aktywnaSkala;

        // Ograniczenie do obszaru modelu
        modelX = Math.Clamp(modelX, 0, constWlasciwosciOkna.Szerokosc);
        modelY = Math.Clamp(modelY, 0, constWlasciwosciOkna.Wysokosc);


        Console.WriteLine($"🔧 relativeX: {relativeX}, relativeY: {relativeY}, Scale: {_aktywnaSkala}");
        Console.WriteLine($"📌 Pozycja w modelu: modelX={modelX}, modelY={modelY}");

        mousePosition = $"Wybrałeś: X: {modelX:F0} mm, Y: {modelY:F0} mm (skala: {_aktywnaSkala:F2}) {constWlasciwosciOkna.Szerokosc}x{constWlasciwosciOkna.Wysokosc}";

        bool tylkoRama = false;

        if (SelectedModelType == "Rama" || SelectedModelType == "Słupek stały") tylkoRama = true;

        // 🔍 Znajdź region, w który kliknięto
        var region = FindRegionAtPosition(modelX, modelY, tylkoRama);

        if (region == null)
        {
            await _message.Warning($"❌ Nie znaleziono regionu dla pozycji (X: {modelX:F2}, Y: {modelY:F2}). Pozycja kursora: {relativeX},{relativeY}", 1.5);
            return;
        }

        // 🔍 Znajdź shape wewnątrz regionu
        var shape = FindShapeInRegion(region);

        if (shape == null)
        {
            // Debug: wypisz wszystkie kształty
            Console.WriteLine($"📋 Lista kształtów ({ShapeService.Shapes.Count}):");
            foreach (var s in ShapeService.Shapes)
            {
                if (s is XLineShape line)
                {
                    Console.WriteLine($"📋 Lista   Linia {line.ID}: ({line.X1},{line.Y1})-({line.X2},{line.Y2})");
                }
                else
                {
                    var bbox = s.GetBoundingBox();
                    Console.WriteLine($"📋 Lista   {s.GetType().Name} {s.ID}: bbox={bbox}");
                }
            }

            await _message.Warning($"❌ Nie znaleziono kształtu w regionie {region.Id} dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }


        await FitToCanvas(shape, region.Id, false, region.Wierzcholki, modelX, modelY);

        WybranyModel = null;

        // Resetuj kursor JS
        await JS.InvokeVoidAsync("ResetCursorGlobal");

    }

    private IShapeDC FindShapeInRegion(ShapeRegion region)
    {
        Console.WriteLine($"🔍 Szukam kształtu dla regionu: {region.Id}, IdMaster: {region.IdMaster}");

        // 1. Spróbuj po IdMaster
        if (!string.IsNullOrEmpty(region.IdMaster))
        {
            var shapeById = ShapeService.Shapes.FirstOrDefault(s => s.ID == region.IdMaster);
            if (shapeById != null)
            {
                Console.WriteLine($"✅ Znaleziono kształt po IdMaster: {shapeById.GetType().Name} ID: {shapeById.ID}");
                return shapeById;
            }
        }

        // 2. Spróbuj wyciągnąć ID z region.Id
        var shapeIdFromRegion = region.Id.Split('|')[0];
        var shapeByIdFromRegion = ShapeService.Shapes.FirstOrDefault(s => s.ID == shapeIdFromRegion);
        if (shapeByIdFromRegion != null)
        {
            Console.WriteLine($"✅ Znaleziono kształt po ID z region: {shapeByIdFromRegion.GetType().Name} ID: {shapeByIdFromRegion.ID}");
            return shapeByIdFromRegion;
        }

        // 3. Sprawdź czy region zawiera punkty kształtu
        foreach (var s in ShapeService.Shapes)
        {
            // Dla linii
            if (s is XLineShape lineShape)
            {
                // Sprawdź czy którykolwiek punkt linii jest w regionie
                if (IsPointInPolygon(region.Wierzcholki, lineShape.X1, lineShape.Y1) ||
                    IsPointInPolygon(region.Wierzcholki, lineShape.X2, lineShape.Y2))
                {
                    Console.WriteLine($"✅ Znaleziono linię w regionie: {lineShape.ID}");
                    return lineShape;
                }
            }
            else
            {
                // Dla innych kształtów sprawdź czy środek kształtu jest w regionie
                var bbox = s.GetBoundingBox();
                var centerX = bbox.X + bbox.Width / 2;
                var centerY = bbox.Y + bbox.Height / 2;

                if (IsPointInPolygon(region.Wierzcholki, centerX, centerY))
                {
                    Console.WriteLine($"✅ Znaleziono kształt po środku: {s.GetType().Name} ID: {s.ID}");
                    return s;
                }

                // Sprawdź czy którykolwiek wierzchołek kształtu jest w regionie
                var points = s.GetPoints();
                if (points != null)
                {
                    foreach (var point in points)
                    {
                        if (IsPointInPolygon(region.Wierzcholki, point.X, point.Y))
                        {
                            Console.WriteLine($"✅ Znaleziono kształt po wierzchołku: {s.GetType().Name} ID: {s.ID}");
                            return s;
                        }
                    }
                }
            }
        }

        Console.WriteLine($"❌ Nie znaleziono kształtu dla regionu {region.Id}");

        return null;
    }

    private ShapeRegion? FindRegionAtPosition(double x, double y, bool tylkoRama)
    {
        Console.WriteLine($"\n🔍 FindRegionAtPosition START: punkt ({x:F2}, {y:F2}), tylkoRama={tylkoRama}");

        if (_regionsDualRama == null || !_regionsDualRama.Any() ||
            _regionsSkrzydlo == null || !_regionsSkrzydlo.Any())
        {
            Console.WriteLine("❌ Brak regionów do sprawdzenia!");
            return null;
        }

        var regionsToCheck = tylkoRama ? _regionsDualRama : _regionsSkrzydlo;
        Console.WriteLine($"   Sprawdzam {regionsToCheck.Count} regionów");

        foreach (var region in regionsToCheck)
        {
            if (region.Wierzcholki == null || region.Wierzcholki.Count < 2)
            {
                Console.WriteLine($"   ⚠️ Region {region.Id} pominięty - brak wierzchołków");
                continue;
            }

            // 🔴 REGION = LINIA (Słupek stały)
            if (SelectedModelType == "Słupek stały" &&
                region.Wierzcholki.Count == 2)
            {
                var p1 = region.Wierzcholki[0];
                var p2 = region.Wierzcholki[1];

                Console.WriteLine($"   🔴 Test region-linia {region.Id}");

                if (IsPointNearLine(
                    x, y,
                    p1.X, p1.Y,
                    p2.X, p2.Y,
                    tolerance: 6 / _aktywnaSkala))
                {
                    Console.WriteLine($"✅ Znaleziono region-linię: {region.Id}");
                    return region;
                }

                continue;
            }

            // 🟢 REGION = WIELOKĄT
            if (region.Wierzcholki.Count < 3)
            {
                Console.WriteLine($"   ⚠️ Region {region.Id} pominięty - mniej niż 3 wierzchołki");
                continue;
            }

            // Bounding box (optymalizacja + debug)
            double minX = region.Wierzcholki.Min(p => p.X);
            double maxX = region.Wierzcholki.Max(p => p.X);
            double minY = region.Wierzcholki.Min(p => p.Y);
            double maxY = region.Wierzcholki.Max(p => p.Y);

            Console.WriteLine($"   Region {region.Id} bounding box: X[{minX:F2}–{maxX:F2}], Y[{minY:F2}–{maxY:F2}]");
            Console.WriteLine($"   Punkt: X={x:F2}, Y={y:F2}");

            bool inBoundingBox = (x >= minX && x <= maxX && y >= minY && y <= maxY);
            Console.WriteLine($"   Punkt w bounding box? {inBoundingBox}");

            if (!inBoundingBox)
            {
                Console.WriteLine($"   ✗ Pomijam - punkt poza bounding box");
                continue;
            }

            Console.WriteLine($"   ✓ Przechodzę do dokładnego testu...");

            // 1️⃣ Test: punkt w wielokącie
            if (IsPointInPolygon(region.Wierzcholki, x, y))
            {
                Console.WriteLine($"✅ Znaleziono region (wnętrze): {region.Id}");
                return region;
            }

            // 2️⃣ Test: punkt blisko krawędzi (KLUCZOWE dla trójkątów)
            for (int i = 0; i < region.Wierzcholki.Count; i++)
            {
                var a = region.Wierzcholki[i];
                var b = region.Wierzcholki[(i + 1) % region.Wierzcholki.Count];

                if (IsPointNearLine(
                    x, y,
                    a.X, a.Y,
                    b.X, b.Y,
                    tolerance: 4 / _aktywnaSkala))
                {
                    Console.WriteLine($"✅ Znaleziono region (krawędź): {region.Id}");
                    return region;
                }
            }
        }

        Console.WriteLine("❌ Nie znaleziono regionu zawierającego punkt");
        return null;
    }

    private bool IsPointNearLine(
    double px, double py,
    double x1, double y1,
    double x2, double y2,
    double tolerance)
    {
        var dx = x2 - x1;
        var dy = y2 - y1;

        if (dx == 0 && dy == 0)
            return Math.Sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1)) <= tolerance;

        var t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
        t = Math.Clamp(t, 0, 1);

        var cx = x1 + t * dx;
        var cy = y1 + t * dy;

        var dxp = px - cx;
        var dyp = py - cy;

        return (dxp * dxp + dyp * dyp) <= tolerance * tolerance;
    }

    // Pomocnicza funkcja do obliczania odległości punktu od odcinka
    private double DistanceToSegment(double px, double py, double x1, double y1, double x2, double y2)
    {
        double A = px - x1;
        double B = py - y1;
        double C = x2 - x1;
        double D = y2 - y1;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = (len_sq != 0) ? dot / len_sq : -1;

        double xx, yy;

        if (param < 0)
        {
            xx = x1;
            yy = y1;
        }
        else if (param > 1)
        {
            xx = x2;
            yy = y2;
        }
        else
        {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        double dx = px - xx;
        double dy = py - yy;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    private bool IsPointInPolygon(List<XPoint> polygon, double x, double y)
    {
        if (polygon == null || polygon.Count < 3)
        {
            Console.WriteLine($"⚠️ IsPointInPolygon: Nieprawidłowy polygon (punkty: {polygon?.Count ?? 0})");
            return false;
        }

        bool inside = false;
        int n = polygon.Count;

        // DEBUG: wypisz pierwsze 3 i ostatnie 3 punkty
        Console.WriteLine($"🔍 IsPointInPolygon: sprawdzam punkt ({x:F2}, {y:F2})");
        Console.WriteLine($"   Polygon ma {n} punktów");
        if (n > 0)
        {
            Console.WriteLine($"   Pierwszy punkt: ({polygon[0].X:F2}, {polygon[0].Y:F2})");
            Console.WriteLine($"   Ostatni punkt: ({polygon[n - 1].X:F2}, {polygon[n - 1].Y:F2})");
        }

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            double xi = polygon[i].X;
            double yi = polygon[i].Y;
            double xj = polygon[j].X;
            double yj = polygon[j].Y;

            // Sprawdź czy punkt leży dokładnie na wierzchołku
            if (Math.Abs(xi - x) < 0.001 && Math.Abs(yi - y) < 0.001)
            {
                Console.WriteLine($"   Punkt leży DOKŁADNIE na wierzchołku {i} ({xi:F2}, {yi:F2})");
                return true;
            }

            // Sprawdź przecięcie
            bool intersect = ((yi > y) != (yj > y));

            if (intersect)
            {
                // Unikaj dzielenia przez zero - użyj większej tolerancji
                double denominator = (yj - yi);
                if (Math.Abs(denominator) < 0.000001)
                {
                    // Linia pozioma - sprawdź czy punkt jest na linii
                    if (Math.Abs(yi - y) < 0.001 && x >= Math.Min(xi, xj) && x <= Math.Max(xi, xj))
                    {
                        Console.WriteLine($"   Punkt leży na poziomej krawędzi {j}-{i}");
                        return true;
                    }
                    continue;
                }

                double intersectX = (xj - xi) * (y - yi) / denominator + xi;

                // Sprawdź czy punkt leży na krawędzi (z tolerancją)
                if (Math.Abs(x - intersectX) < 0.001)
                {
                    Console.WriteLine($"   Punkt leży NA krawędzi {j}-{i} (różnica: {Math.Abs(x - intersectX):E6})");
                    return true;
                }

                if (x < intersectX)
                {
                    inside = !inside;
                }
            }
        }

        Console.WriteLine($"   Wynik: punkt jest {(inside ? "WEWNĄTRZ" : "NA ZEWNĄTRZ")} polygonu");
        return inside;
    }

    private async Task OnlyRestrykcje()
    {

        if (!string.IsNullOrEmpty(SelectedModelType))
        {

            if (ListaModeli != null)
            {
                Console.WriteLine($"OnlyRestrykcje - Typ --> SelectedModelType: {SelectedModelType}");

                var _ListaModeliResrykcje = ListaModeli.FirstOrDefault(x => x.Typ == SelectedModelType);

                if (_ListaModeliResrykcje != null)
                {
                    if (infoObiekt == null)
                        infoObiekt = new List<WyrobWymiaryOpis>();

                    string restrykcje = "";

                    if (_ListaModeliResrykcje.KonstrMinSzer > constWlasciwosciOkna.Szerokosc)
                    {
                        restrykcje = "<#SYS> Konstrukcja nie spełnia warunku MIN szerokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMinWys > constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MAX wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }

                    // ✅ Poprawione: Utwórz nowy obiekt przed ustawieniem właściwości

                    if (restrykcje != "")
                    {
                        WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc, SelectedModelType, restrykcje);

                        infoObiekt.Add(opisy);
                    }

                    infoBoom.Clear();// czyści listę przed dodaniem nowych elementów

                    foreach (var danedoboom in ksztalty)
                    {
                        WygenerowaneMaterialy opisySys = new WygenerowaneMaterialy(
                         danedoboom.RowIdElementu,
                         danedoboom.DlogoscNaGotowoElementu,
                         danedoboom.NazwaElementu ?? "",
                         danedoboom.IndeksElementu ?? "",
                         1,
                         ""
                         );

                        infoBoom.Add(opisySys);
                    }

                }

            }
        }

        await Task.CompletedTask;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        //Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private bool isTextureLoaded = false;

    private async Task DrawStructureAndRestrykcje(int isTextureLoadedNZ = 999)
    {

        if (isTextureLoadedNZ == 0) isTextureLoaded = false;

        try
        {
            // if (CanvasRef == null)
            // {
            //     Console.WriteLine("⚠️ Brak referencji do canvasu!");
            //     return;
            // }

            // _context ??= await CanvasRef.CreateCanvas2DAsync();

            if (!isTextureLoaded)
            {

                await OnlyRestrykcje();

                Console.WriteLine("DrawStructureAndRestrykcje.");

            }


        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas rysowania: {ex.Message}");
        }
    }

    public async Task<DraggedModelInfo> GetDraggedModelInfoAsync()
    {
        try
        {
            var info = await JS.InvokeAsync<DraggedModelInfo>("getDraggedModelInfo");
            await JS.InvokeVoidAsync("clearCurrentModel"); // Opcjonalne czyszczenie po odczycie
            return info;
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Błąd pobierania informacji o modelu: {ex.Message}");
            return null;
        }
    }

    [JSInvokable]
    public async Task OnDragError(string message)
    {
        await _message.Error(message);
        StateHasChanged();
    }

    public void Dispose()
    {
        if (_disposed) return;

        _disposed = true;

        try
        {
            // Najpierw ustaw flagę, żeby uniknąć kolejnych wywołań
            _ = JS.InvokeVoidAsync("clearDotNetHelper").AsTask();
            _dotNetHelper?.Dispose();
            // Nie ustawiaj JS na null, bo może być potrzebny do innych operacji?
            // JS = null;
            Console.WriteLine($"🧹 Dispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd Dispose: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        try
        {
            isTextureLoaded = true;
            // Console.WriteLine("✅ Tekstura załadowana!");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ładowania tekstury: {ex.Message}");
        }
    }

    private async Task ZmienWymiaryOkna(bool regenerujShapeService = true)
    {
        if (ShapeService?.Shapes == null || !ShapeService.Shapes.Any())
        {
            Console.WriteLine("❌ ZmienWymiaryOkna: Brak kształtów do przeskalowania!");
            return;
        }

        try
        {
            Console.WriteLine("🔄 Rozpoczynam zmianę wymiarów okna...");

            double oldWidth = ShapeService.Shapes.Max(s => s.Szerokosc);
            double oldHeight = ShapeService.Shapes.Max(s => s.Wysokosc);

            double newWidth = constWlasciwosciOkna.Szerokosc;
            double newHeight = constWlasciwosciOkna.Wysokosc;

            Console.WriteLine($"📏 Zmiana wymiarów: {oldWidth}x{oldHeight} → {newWidth}x{newHeight}");


            // 2. Aktualizacja wymiarów kształtów
            foreach (var shape in ShapeService.Shapes)
            {
                if (shape != null)
                {
                    shape.Szerokosc = newWidth;
                    shape.Wysokosc = newHeight;
                }
            }

            // 3. Generuj obrys (BEZ automatycznego przerysowywania!)
            await GenerujObrysPozZmianieWymiarow(true);

            // double oldWidth = ShapeService.Shapes.Max(s => s.Szerokosc);
            // double oldHeight = ShapeService.Shapes.Max(s => s.Wysokosc);

            // double newWidth = constWlasciwosciOkna.Szerokosc;
            // double newHeight = constWlasciwosciOkna.Wysokosc;

            Console.WriteLine($"📏 Zmiana wymiarów: {oldWidth}x{oldHeight} → {newWidth}x{newHeight}");

            // 2. Aktualizacja wymiarów kształtów
            foreach (var shape in ShapeService.Shapes)
            {
                if (shape != null)
                {
                    shape.Szerokosc = newWidth;
                    shape.Wysokosc = newHeight;
                }
            }

            LineUtils.ShiftAllShapesToPositiveQuadrant(ShapeService.Shapes);

          //  LineUtils.ShiftAllShapesToPositiveQuadrant(ShapeService.Shapes);

            // await Task.Delay(1); // Krótkie opóźnienie dla stabilności

            // await GenerujObrysPozZmianieWymiarow(false);

            // 4. Przygotuj listę regionów
            var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo).ToList();
            Console.WriteLine($"🗺️ Regiony: dual={_regionsDualRama.Count}, skrzydło={_regionsSkrzydlo.Count}");

            // 5. Tymczasowe przechowanie nowych kształtów
            var noweKsztalty = new List<KsztaltElementu>();
            var noweKsztaltyNaRegion = new Dictionary<string, List<KsztaltElementu>>();

            // 6. Przetwarzaj stany generatorów
            var obrGen = _generatorStates.OrderBy(x => x.Value.ZIndeks).ToList();

            foreach (var genState in obrGen)
            {
                Console.WriteLine($"🔄 Przetwarzam region: {genState.Value.IdRegion}");
            }

            foreach (var genState in obrGen)
            {
                string cleanId = genState.Value.IdRegion;

                Console.WriteLine($"🔄 Przetwarzam region cleanId:{cleanId} SelectedModelType?.Trim(): {SelectedModelType?.Trim()}");

                var region = wszystkieRegiony.FirstOrDefault(r => r.Id == cleanId);
                if (region == null)
                {
                    Console.WriteLine($"⚠ Brak regionu dla cleanId:{cleanId}");
                    continue;
                }

                // Aktualizuj wierzchołki w stanie generatora
                if (region.Wierzcholki != null && region.Wierzcholki.Any())
                {
                    var nowe = region.Wierzcholki.Select(p => new XPoint(p.X, p.Y)).ToList();

                    genState.Value.Wierzcholki = nowe;
                    genState.Value.WierzcholkiWartosciNominalne = nowe;
                    genState.Value.StaryRegionOrigin = region.Wierzcholki.First();

                    Console.WriteLine($"📐 Nowe wierzchołki dla cleanId: {cleanId} TypKsztaltu: {region.TypKsztaltu} --> {region.Wierzcholki.Max(x => x.X)}x{region.Wierzcholki.Max(x => x.Y)}");
                }

                var generator = genState.Value.Generator;
                if (generator == null)
                {
                    Console.WriteLine($"⚠ Brak generatora dla cleanId: {cleanId}");
                    continue;
                }

                // Wyczyść stare elementy
                generator.ElementyRamyRysowane.Clear();

                // Wylicz nowe kwadraty
                genState.Value.ListaKwadratow = WyliczKwadratyPoZmianie(region);
                _generatorStates[cleanId].ListaKwadratow = genState.Value.ListaKwadratow;

                // Obsługa specjalna dla skrzydeł
                if (SelectedModelType?.Trim() == "Skrzydło" || SelectedModelType?.Trim() == "Skrzydło z słupkiem ruchomym")
                {
                    var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == region.Id);
                    if (wybranyRegionSkrzydlo != null)
                    {
                        generator.IdRegionuPonizej = wybranyRegionSkrzydlo.IdRegionuPonizej ?? region.Id + "-BLAD";

                        var minX = wybranyRegionSkrzydlo.Wierzcholki.Min(p => p.X);
                        var maxX = wybranyRegionSkrzydlo.Wierzcholki.Max(p => p.X);
                        var minY = wybranyRegionSkrzydlo.Wierzcholki.Min(p => p.Y);
                        var maxY = wybranyRegionSkrzydlo.Wierzcholki.Max(p => p.Y);

                        generator.Szerokosc = (float)(maxX - minX);
                        generator.Wysokosc = (float)(maxY - minY);
                        generator.Zindeks = SelectedModelType == "Skrzydło z słupkiem ruchomym" ? 2 : 3;
                        generator.CzyElementJestRama = false;

                        // Wylicz obszar skrzydła
                        if (wybranyRegionSkrzydlo.Wierzcholki != null)
                        {
                            double przesLewo = 0, przesPrawo = 0, przesGora = 0, przesDol = 0;
                            await WyliczObszarSkrzydla(
                                _generatorStates[cleanId],
                                przesLewo, przesPrawo,
                                przesGora, przesDol,
                                generator.RuchomySlupekPoLewej, generator.RuchomySlupekPoPrawej,
                                generator, wybranyRegionSkrzydlo
                            );
                        }
                    }
                }

                if (SelectedModelType?.Trim() == "Słupek stały")
                {
                    var wybranyRegionSlupek = _regionsDualRama
                        .FirstOrDefault(r => r.Id == region.Id);

                    Console.WriteLine($"📐 WyliczObszarSlupkaStalego -> r => r.Id == region.Id == {region.Id}");

                    if (wybranyRegionSlupek != null)
                    {
                        double przesLewo = 0, przesPrawo = 0;
                        double przesGora = 0, przesDol = 0;

                        await WyliczObszarSlupkaStalego(
                            _generatorStates[cleanId],
                            przesLewo,
                            przesPrawo,
                            przesGora,
                            przesDol,
                            generator,
                            wybranyRegionSlupek
                        );
                    }
                }

                // Dodaj elementy do generatora
                var daneKwadratow = genState.Value.ListaKwadratow ?? new List<DaneKwadratu>();

                if (generator.CzyElementJestRama)
                {
                    var ok = await generator.AddElements(
                          new List<ShapeRegion> { region },
                          cleanId,
                          _generatorStates,
                          _regionsDualRama,
                          daneKwadratow,
                          wszystkieRegiony.FirstOrDefault(f => f.Rama).Wierzcholki
                      );

                    if (!ok)
                    {
                        _message.Error($"Nie można wygenerować elementów dla regionu {cleanId}. Sprawdź wymiary i kształt regionu.");
                    }
                }
                else
                {

                    var ok = await generator.AddElements(
                        new List<ShapeRegion> { region },
                        cleanId,
                        _generatorStates,
                        _regionsSkrzydlo,
                        daneKwadratow,
                            wszystkieRegiony.FirstOrDefault(f => f.Rama).Wierzcholki
                    );

                    if (!ok)
                    {
                        _message.Error($"Nie można wygenerować elementów dla regionu {cleanId}. Sprawdź wymiary i kształt regionu.");
                    }

                }

                // Zapisz wygenerowane kształty do tymczasowej kolekcji
                if (generator.ElementyRamyRysowane.Any())
                {
                    noweKsztaltyNaRegion[cleanId] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
                    noweKsztalty.AddRange(generator.ElementyRamyRysowane);

                    Console.WriteLine($"✅ Wygenerowano {generator.ElementyRamyRysowane.Count} kształtów dla {cleanId}");
                }

                // Aktualizuj stan generatora
                AddOrUpdateGeneratorState(cleanId, genState.Value, generator);
            }

            // 7. SYNCHRONIZACJA: Zamień stare kształty na nowe (ATOMOWO)
            lock (_ksztaltyNaRegion)
            {
                _ksztaltyNaRegion.Clear();
                foreach (var kvp in noweKsztaltyNaRegion)
                {
                    _ksztaltyNaRegion[kvp.Key] = kvp.Value;
                }

                ksztalty.Clear();
                ksztalty.AddRange(noweKsztalty);
            }
            await Task.Delay(10); // Krótkie opóźnienie dla stabilności

            Console.WriteLine($"✅ ZmienWymiaryOkna zakończono pomyślnie");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd w ZmienWymiaryOkna: {ex.Message}, {ex.StackTrace}");
            await _message.Error($"Błąd zmiany wymiarów: {ex.Message}");
        }
        _czekajNaZmianeRozmiaru = false;
        await ApplyZoom();
    }

    private List<DaneKwadratu> WyliczKwadratyPoZmianie(ShapeRegion region)
    {
        // Spróbuj znaleźć istniejący stan dla tego regionu
        var existingState = _generatorStates.Values.FirstOrDefault(s => s.IdRegion == region.Id);

        if (existingState?.ListaKwadratow != null && existingState.ListaKwadratow.Count > 0)
        {
            Console.WriteLine($"ℹ WyliczKwadratyPoZmianie existingState dla regionu {region.Id} kwadratów -> {region.Wierzcholki.Max(x => x.X)} x {region.Wierzcholki.Max(x => x.Y)}");
            // Zwróć klony, żeby nie mutować oryginału
            return existingState.ListaKwadratow.Select(k => k.Clone()).ToList();
        }

        // Brak wcześniejszych danych — zbuduj prosty DaneKwadratu z wierzchołków regionu
        var wynik = new List<DaneKwadratu>();

        if (region.Wierzcholki != null && region.Wierzcholki.Count >= 2)
        {
            // Utwórz pojedynczy DaneKwadratu z dwoma pierwszymi punktami (linia -> profil)
            var dk = new DaneKwadratu
            {
                Wierzcholki = new List<XPoint>
            {
                new XPoint(region.Wierzcholki[0].X, region.Wierzcholki[0].Y),
                new XPoint(region.Wierzcholki[1].X, region.Wierzcholki[1].Y)
            },
                BoolElementLinia = true
            };

            wynik.Add(dk);
        }
        else if (region.Wierzcholki != null && region.Wierzcholki.Count > 0)
        {
            // Jeden punkt -> mały kwadrat
            var p = region.Wierzcholki[0];
            wynik.Add(new DaneKwadratu
            {
                Wierzcholki = new List<XPoint>
            {
                new XPoint(p.X - 5, p.Y - 5),
                new XPoint(p.X + 5, p.Y + 5)
            }
            });
        }

        Console.WriteLine($"ℹ WyliczKwadratyPoZmianie dla regionu {region.Id} - wygenerowano {wynik.Count} kwadratów -> {region.Wierzcholki.Max(x => x.X)} x {region.Wierzcholki.Max(x => x.Y)}");

        return wynik;
    }

    private async Task<bool> DodajWybranyKwadratOkna(string idRegion, List<XPoint> wierzcholki, double klikX, double klikY, bool slupekStaly, List<string> idSlupka, List<XPoint> wierzcholkiMaster)
    {
        if (SelectedModelType == null || string.IsNullOrEmpty(SelectedModelType))
        {
            Console.WriteLine("❌ SelectedModelType jest puste, nie można kontynuować.");
            return false;
        }

        if (_generatorStates != null && _generatorStates.Count == 0)
        {
            if (SelectedModelType.Trim() != "Rama")
            {
                await _message.Info($"Wybierz konstrukcję typu rama!!!");
                return false;
            }
        }

        Console.WriteLine($"📦 -> DodajWybranyKwadratOkna wywołane z idRegion: {idRegion} SelectedRowIdType: {SelectedRowIdType} - konfmodeleelementy");

        var generator = new Generator
        {
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82
        };

        if (KonfiguracjeSystemu != null)
        {
            generator.KonfiguracjeSystemu = KonfiguracjeSystemu;
            generator.RowIdSystemu = Guid.Parse(SelectedSystemId);

            if (Guid.TryParse(SelectedRowIdType, out var rowIdModeluSzukaj))
            {
                generator.RowIdModelu = rowIdModeluSzukaj;

                var powiazanyModel = await Http.GetFromJsonAsync<MVCKonfModele>($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{SelectedRowIdType}");
                if (powiazanyModel != null)
                {
                    generator.MVCKonfModelu = powiazanyModel;

                    if (generator.MVCKonfModelu.KonfModele != null)
                        Console.WriteLine($"! Powiązany model: {generator.MVCKonfModelu.KonfModele[0].NazwaKonfiguracji} ile: {generator.MVCKonfModelu.KonfModele.Count()}");
                }
                else
                {
                    Console.WriteLine($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    await _message.Error($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    return false;
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                await _message.Error($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                return false;

            }
        }
        else
        {
            if (string.IsNullOrEmpty(SelectedSystemId))
            {
                Console.WriteLine("❌ KonfiguracjeSystemu jest puste, nie można kontynuować.");
                return false;
            }

            var kofiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");
            generator.KonfiguracjeSystemu = kofiguracjeSystemu;
        }

        generator.EdytowanyModel = WybranyModel;
        generator.TypKsztaltu = WybranyKsztalt;
        generator.Wierzcholki = wierzcholki;

        var regionReferencyjny = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .FirstOrDefault(r => r.Id == idRegion);

        if (regionReferencyjny == null || regionReferencyjny.Wierzcholki == null)
        {
            Console.WriteLine("❌ Brak regionu referencyjnego.");
            return false;
        }

        var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo);

        // foreach (var r in wszystkieRegiony)
        // {
        //     Console.WriteLine($"🔎 Region: {r.Id}, Typ: {r.TypKsztaltu}, Wierzcholki: {r.Wierzcholki?.Count} TypLiniiDzielacej: {r.TypLiniiDzielacej}");

        //     foreach (var linia in r.Wierzcholki)
        //     {
        //         Console.WriteLine($"🔎 Styczne linie w #1 - Wierzcholki: {(int)linia.X},{(int)linia.Y}");
        //     }
        // }

        var zawarteRegiony = wszystkieRegiony
           .Where(r =>
               r.Wierzcholki != null &&
               r.Wierzcholki.Count >= 3 &&
               r.Wierzcholki.All(p => CzyPunktWNWielokacie(p, regionReferencyjny.Wierzcholki))
           )
           .ToList();

        // foreach (var r in wszystkieRegiony)
        // {
        //     Console.WriteLine($"🧩 Region: {r.Id} | Typ: {r.TypKsztaltu} | TypLiniiDzielacej: {r.TypLiniiDzielacej} | Wierzcholki: {r.Wierzcholki?.Count ?? 0}");

        //     if (r.Wierzcholki != null)
        //     {
        //         foreach (var p in r.Wierzcholki)
        //             Console.WriteLine($"   Punkt: {p.X};{p.Y}");
        //     }
        // }

        var wszystkieRegionyLinii = wszystkieRegiony
        .Select(r =>
        {
            if (r.Wierzcholki == null || r.Wierzcholki.Count < 2)
                return null;

            List<XPoint> punktyLinii;

            // Jeśli to prostokąt (4 punkty) — wyciągnij linię środkową
            if (r.Wierzcholki.Count >= 4)
            {
                var minX = r.Wierzcholki.Min(p => p.X);
                var maxX = r.Wierzcholki.Max(p => p.X);
                var minY = r.Wierzcholki.Min(p => p.Y);
                var maxY = r.Wierzcholki.Max(p => p.Y);

                // Jeśli wysokość > szerokości → linia pionowa
                if (Math.Abs(maxY - minY) > Math.Abs(maxX - minX))
                {
                    var midX = (minX + maxX) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = midX, Y = minY },
                    new XPoint { X = midX, Y = maxY }
                };
                }
                else // pozioma
                {
                    var midY = (minY + maxY) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = minX, Y = midY },
                    new XPoint { X = maxX, Y = midY }
                };
                }
            }
            else
            {
                punktyLinii = r.Wierzcholki;
            }

            return new ShapeRegion
            {
                Id = r.Id,
                TypKsztaltu = r.TypKsztaltu,
                TypLiniiDzielacej = r.TypLiniiDzielacej,
                Wierzcholki = punktyLinii
            };
        })
        .Where(r => r != null)
        .ToList();

        var styczneLinie = wszystkieRegionyLinii
            .Where(r =>
                r.Wierzcholki != null &&
                r.Wierzcholki.Count == 2 &&
                !CzyPunktyRowneSlupek(r.Wierzcholki[0], r.Wierzcholki[1])
            )
            .ToList();

        Console.WriteLine($"✅ Styczne linie: {styczneLinie.Count}");

        foreach (var linia in styczneLinie)
        {
            Console.WriteLine($"✅ Styczne linie: 🔹 Linia: {linia.Id}, {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
        }

        bool czyRegionZawieraSlupekRuchomy = false;
        bool stronaLewa = false;
        bool stronaPrawa = false;

        if (styczneLinie.Count() > 0)
            Console.WriteLine($"⚠️⚠️⚠️ styczneLinie region rama/skrzydło: {styczneLinie.Count()} zawarteRegiony: {zawarteRegiony.Count()} styczneLinie:{styczneLinie[styczneLinie.Count() - 1].TypKsztaltu}  ⚠️");


        if (styczneLinie.Any())
        {
            // 🔹 Grupowanie i usuwanie duplikatów słupków
            var slupkiRuchome = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek ruchomy")
                .GroupBy(x => string.Join("|", x.Wierzcholki.Select(p => $"{p.X:F3},{p.Y:F3}")))
                .Select(g => g.First())
                .ToList();

            var slupkiStale = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek stały" || x.TypLiniiDzielacej == "Podwójna rama")
                .GroupBy(x => string.Join("|", x.Wierzcholki.Select(p => $"{p.X:F3},{p.Y:F3}")))
                .Select(g => g.First())
                .ToList();

            czyRegionZawieraSlupekRuchomy = slupkiRuchome.Any();

            // double tolerancjaKlik = 0.05; // aby uniknąć efektu granicznego

            if (czyRegionZawieraSlupekRuchomy)
            {
                Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy w ilości: {slupkiRuchome.Count}.");

                // Obliczamy środki X wszystkich słupków ruchomych
                var srodkiRuchomych = slupkiRuchome
                    .Select(sl => (sl.Wierzcholki[0].X + sl.Wierzcholki[1].X) / 2)
                    .OrderBy(x => x)
                    .ToList();

                if (srodkiRuchomych.Count == 1)
                {
                    double srodekX = srodkiRuchomych.First();
                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2}, 1 słupek ruchomy");

                    if (klikX > srodekX)
                    {
                        stronaLewa = true;
                        Console.WriteLine("⬅️ Kliknięcie po prawej stronie słupka ruchomego → słupek po lewej stronie.");
                    }
                    else
                    {
                        stronaPrawa = true;
                        Console.WriteLine("➡️ Kliknięcie po lewej stronie słupka ruchomego → słupek po prawej stronie.");
                    }
                }
                else if (srodkiRuchomych.Count >= 2)
                {
                    // Dwa słupki ruchome – obliczamy środek między nimi
                    double srodekX = (srodkiRuchomych.First() + srodkiRuchomych.Last()) / 2;
                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2}, {srodkiRuchomych.Count} słupków ruchomych");

                    foreach (var sl in slupkiRuchome)
                    {
                        Console.WriteLine($"📐 Słupek ruchomy: {sl.Id} [{sl.Wierzcholki[0].X:F2},{sl.Wierzcholki[0].Y:F2}] → [{sl.Wierzcholki[1].X:F2},{sl.Wierzcholki[1].Y:F2}]");
                    }

                    // Domyślnie — słupki ruchome po obu stronach
                    stronaLewa = true;
                    stronaPrawa = true;

                    // Określamy kliknięcie względem środka
                    if (klikX > srodekX)
                    {
                        Console.WriteLine("⬅️ Kliknięcie po prawej stronie zestawu słupków → priorytet słupka ruchomego po lewej stronie.");
                    }
                    else
                    {
                        Console.WriteLine("➡️ Kliknięcie po lewej stronie zestawu słupków → priorytet słupka ruchomego po prawej stronie.");
                    }

                    // 🧱 Sprawdzamy, czy między słupkami ruchomymi znajduje się słupek stały
                    if (slupkiStale.Any())
                    {
                        var srodkiStalych = slupkiStale
                            .Select(sl => (sl.Wierzcholki[0].X + sl.Wierzcholki[1].X) / 2)
                            .OrderBy(x => x)
                            .ToList();

                        double minRuchomy = srodkiRuchomych.First();
                        double maxRuchomy = srodkiRuchomych.Last();

                        foreach (var stalyX in srodkiStalych)
                        {
                            Console.WriteLine($"🧱 Słupek stały X={stalyX:F2}, klikX={klikX:F2}");

                            // Jeśli słupek stały leży POMIĘDZY słupkami ruchomymi
                            if (stalyX > minRuchomy && stalyX < maxRuchomy)
                            {
                                // Jeśli klik po lewej stronie słupka stałego → zablokuj prawą stronę
                                if (klikX < stalyX)
                                {
                                    stronaPrawa = false;
                                    Console.WriteLine("🚫 Słupek stały po prawej stronie kliknięcia → wyłączam prawą stronę.");
                                }
                                // Jeśli klik po prawej stronie słupka stałego → zablokuj lewą stronę
                                else if (klikX > stalyX)
                                {
                                    stronaLewa = false;
                                    Console.WriteLine("🚫 Słupek stały po lewej stronie kliknięcia → wyłączam lewą stronę.");
                                }
                            }
                        }
                    }
                }
                else
                {
                    // W razie większej liczby słupków — obie strony aktywne
                    stronaLewa = true;
                    stronaPrawa = true;
                    Console.WriteLine("↔️ Słupek ruchomy po obu stronach.");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka ruchomego.");
            }

            if (slupkiStale.Any())
            {
                Console.WriteLine($"📏 Region {idRegion} zawiera {slupkiStale.Count} słupków stałych.");
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka stałego.");
            }

            Console.WriteLine($"✅ Ustawiono w generatorze: Lewa={generator.RuchomySlupekPoLewej}, Prawa={generator.RuchomySlupekPoPrawej}");
        }
        else
        {
            Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera linii stycznych.");
        }

        generator.RuchomySlupekPoLewej = stronaLewa;
        generator.RuchomySlupekPoPrawej = stronaPrawa;

        if (czyRegionZawieraSlupekRuchomy && SelectedModelType != "Rama" && SelectedModelType != "Słupek stały")
        {

            bool czyZawieraSlupekRuchomyWPowiazanymModelu = _generatorStates
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfModele != null &&
                     state.Value.MVCKonfModelu.KonfModele.Any(ks => ks.Typ == "Skrzydło z słupkiem ruchomym")
                 );

            Console.WriteLine($"✅✅✅ Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów. Model-Typ: {WybranyModel.Typ} czyZawieraSlupekRuchomyWPowiazanymModelu: {czyZawieraSlupekRuchomyWPowiazanymModelu}");

            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {

                if (WybranyModel.Typ != "Skrzydło z słupkiem ruchomym")
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj wcześniej słupek ruchomy do konstrukcji.",
                        2.0
                    );
                    return false;
                }

            }

        }

        int ileRegionWSkrzydleZawieraSlupekRuchomy = _regionsSkrzydlo.Where(x => x.TypLiniiDzielacej == "Słupek ruchomy").Count();

        int ileJestDodanychSlRuchWRegionach = _generatorStates.Values
            .SelectMany(x => x.ListaKwadratow) // spłaszczamy kolekcje kwadratów
            .Count(v => v.TypKsztaltu == "Słupek ruchomy");

        // int ileJestDodanychSlRuchWRegionach = _generatorStates
        //     .SelectMany(x => x.Value) // spłaszczamy kolekcje regionów
        //     .Count(v => v.TypLiniiDzielacej == "Słupek ruchomy");

        if (generator.MVCKonfModelu == null || generator.MVCKonfModelu.KonfModele == null || generator == null) return false;

        int ileRegionDRZawieraSlupekRuchomy = generator.MVCKonfModelu.KonfModele.Where(x => x.Typ == "Skrzydło z słupkiem ruchomym").Count();

        if (WybranyModel == null)
        {
            await _message.Warning(
                "Błąd wyboru modelu!!!!",
                2.0
            );
            return false;
        }

        Console.WriteLine($"🟩 Ile regionów skrzydła zawiera słupek ruchomy: {ileRegionWSkrzydleZawieraSlupekRuchomy} - Ile regionów DR zawiera słupek ruchomy: {ileRegionDRZawieraSlupekRuchomy} - SelectedModelType: {SelectedModelType} -> ileJestDodanychSlRuchWRegionach: {ileJestDodanychSlRuchWRegionach} Wybrany typ {WybranyModel.Typ}");

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && ileRegionDRZawieraSlupekRuchomy == 0 && SelectedModelType != "Rama" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            Console.WriteLine($"🟩 Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego! SelectedModelType: {SelectedModelType}");

            await _message.Warning(
                "1# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;

        }

        //Sprawdzić czy to potrzebne ???
        // if (ileJestDodanychSlRuchWRegionach > ileRegionDRZawieraSlupekRuchomy && SelectedModelType != "Rama" && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        // {
        //     await _message.Warning(
        //         "W regionie skrzydła jest już dodany słupek ruchomy. Nie można dodać więcej słupków ruchomych do tej konstrukcji.",
        //         2.0
        //     );
        //     return false;
        // }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == ileJestDodanychSlRuchWRegionach && SelectedModelType != "Rama" && WybranyModel.Typ != "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            await _message.Warning(
                "2# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;
        }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym")
        {
            await _message.Warning(
                "Dodajesz konstrukcję z słupkiem ruchomym, W konstrukcji nie ma podzaiłu z słupkiem ruchomym",
                2.0
            );
            return false;
        }

        double minX = 0;
        double maxX = 0;
        double minY = 0;
        double maxY = 0;
        string linieDzielace = "";
        List<XPoint> WierzcholkiWartosciNominalne = new();

        WierzcholkiWartosciNominalne.AddRange(wierzcholki);

        Console.WriteLine($"📐📐📐 SelectedModelType  = {SelectedModelType} Ilość wierzchołków: {wierzcholki.Count()} 📐📐📐");

        generator.ElementLiniowy = SelectedModelType.Trim() == "Słupek stały";

        if (SelectedModelType.Trim() == "Rama")
        {

            var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionDualRama != null)
            {
                var regionPoints = wybranyRegionDualRama.Wierzcholki;

                if (regionPoints == null || regionPoints.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej ?? idRegion;
                linieDzielace = wybranyRegionDualRama.TypLiniiDzielacej ?? "Brak";

                minX = regionPoints.Min(p => p.X);
                maxX = regionPoints.Max(p => p.X);
                minY = regionPoints.Min(p => p.Y);
                maxY = regionPoints.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = 0;
                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej;
                generator.CzyElementJestRama = true;

                Console.WriteLine($"📐📐📐 Region Zindeks = 0 ID: {wybranyRegionDualRama.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc} generator.Wierzcholki.Count():{generator.Wierzcholki.Count()}");

                // stronaLewa = false;
                //stronaPrawa = false;

                generator.RuchomySlupekPoLewej = false;
                generator.RuchomySlupekPoPrawej = false;

                var ok = await generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);//Rama nie ma sąsiada dla tego null
                if (!ok)
                {
                    _message.Error($"Nie można wygenerować elementów dla regionu {idRegion}. Sprawdź wymiary i kształt regionu.");
                }
            }
        }

        // Oblicz przesunięcia tylko dla skrzydeł zmienne
        double przesLewo = 0, przesPrawo = 0, przesGora = 0, przesDol = 0;

        // Przygotowanie stanu generatora
        var state = new GeneratorState
        {
            Id = _generatorStates.Count + 1,
            IdRegion = idRegion,
            ZIndeks = generator.Zindeks,
            RowIdSystemu = Guid.Parse(SelectedSystemId),
            RowIdModelu = Guid.TryParse(SelectedRowIdType, out var rowIdModelu) ? rowIdModelu : (Guid?)null,
            MVCKonfModelu = generator.MVCKonfModelu,
            WybranyModel = WybranyModel,
            WybranyKsztalt = WybranyKsztalt,
            IdRegionWarstwaNizej = generator.IdRegionuPonizej,
            Wierzcholki = generator.ElementyRamyRysowane.SelectMany(k => k.Wierzcholki ?? new List<XPoint>()).Distinct().ToList(),
            WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne,
            LinieDzielace = linieDzielace,
            SlupekRuchomyPoLewejStronie = stronaLewa,
            SlupekRuchomyPoPrawejStronie = stronaPrawa,
            ListaKwadratow = new List<DaneKwadratu>(),
            ElementLiniowy = generator.ElementLiniowy,
            CzyElementJestRama = generator.CzyElementJestRama
        };

        Console.WriteLine($"🟦 DodajWybranyKwadratOkna -> Utworzono stan generatora o ID: {state.Id}, IdRegion: {state.IdRegion}, WybranyTyp: {state.WybranyKsztalt}, WierzcholkiWartosciNominalne.Count: {(WierzcholkiWartosciNominalne != null ? WierzcholkiWartosciNominalne.Count : "null")}");

        var linie = ExtractLinesFromSquare(WierzcholkiWartosciNominalne);

        //string idGenerator = $"{idRegion}_{Guid.NewGuid()}";

        // Zapisz stan generatora
        // _generatory[idGenerator] = generator;

        //ZapiszStanGeneratora(idGenerator, state);

        List<SasiadInfo> sasiedzi = new();

        Console.WriteLine($"🔎 DodajWybranyKwadratOkna wierzchołki dla słupka: {string.Join(", ", state.Wierzcholki.Select(p => $"({p.X:F2},{p.Y:F2})"))} ExtractLinesFromSquare -> {linie.Count()} _generatorStates.Count: {_generatorStates.Values.ToList().Count()}");

        foreach (var linia in linie)
        {
            Console.WriteLine($"🔎 DodajWybranyKwadratOkna -> Przetwarzam linię z punktami: ({linia[0].X},{linia[0].Y}) -> ({linia[1].X},{linia[1].Y}) _generatorStates.Count: {_generatorStates.Values.ToList().Count()}");

            if (linia.Count != 2) continue;

            var katSzukaj = ObliczKatLinii(linia);

            Console.WriteLine($"🔎 DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° w stanie ID: {state.Id}, IdRegion: {state.IdRegion}, WybranyTyp: {state.WybranyKsztalt}");

            sasiedzi = await ZnajdzSasiada(
                linia,
                _generatorStates.Values.ToList(),
                (float)katSzukaj,
                state.SlupekRuchomyPoLewejStronie,
                state.SlupekRuchomyPoPrawejStronie,
                state.IdRegion,
                state.Id,
                WybranyModel.Typ == "Skrzydło z słupkiem ruchomym",
                WybranyModel.Typ == "Słupek stały",
                0.05
            );

            /// -------------------------------------------------- Wyszukiwanie sąsiadów --------------------------------------------------

            Console.WriteLine($"   🔹 Sasiad: Funkcja 🔍 ZnajdzSasiada wyszukała obiektów: {sasiedzi.Count()} kąt: {katSzukaj}°");

            foreach (var s in sasiedzi)
            {
                Console.WriteLine($"   🔹 Sasiad: Wyszukani sąsiedzi 🔍 ZnajdzSasiada  WybranyTyp: {s.WybranyTyp} linia.Count:{linia.Count()} MaSlupekRuchomy: {s.MaSlupekRuchomy} RowIdElementu: {s.RowIdElementu} kąt: {katSzukaj}°");
            }

            // foreach (var s in linia)
            // {
            //     Console.WriteLine($"   🔹 Sasiad: WybranyTyp: X:{s.X} Y:{s.Y} kąt: {katSzukaj}°");
            // }

            // przykład pobrania najlepszego sąsiada
            // Dla kątów 135-225° (około 180°) ustawiamy WystepujeDol = true
            bool powinnoWystepowacDol = katSzukaj >= 135 && katSzukaj <= 225;

            var najlepszySasiad = sasiedzi.FirstOrDefault(x =>
                x.WystepujeDol == powinnoWystepowacDol);

            if (najlepszySasiad == null) najlepszySasiad = sasiedzi.FirstOrDefault();

            Console.WriteLine($"   🔹 Sasiad: Funkcja 🔍 ZnajdzSasiada FirstOrDefault -> RowIdElementu: {najlepszySasiad.RowIdElementu}");

            string wybranyTypSasiada = "BRAK-DANYCH";

            string stronaZFunkcji = "NIEOKREŚLONA";

            if (sasiedzi != null && sasiedzi.Any())
            {
                double minX1 = WierzcholkiWartosciNominalne.Min(p => p.X);
                double maxX1 = WierzcholkiWartosciNominalne.Max(p => p.X);
                double minY1 = WierzcholkiWartosciNominalne.Min(p => p.Y);
                double maxY1 = WierzcholkiWartosciNominalne.Max(p => p.Y);

                // Logowanie wszystkich sąsiadów
                for (int i = 0; i < sasiedzi.Count; i++)
                {
                    var s = sasiedzi[i];
                    var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                    if (stan?.WierzcholkiWartosciNominalne == null) continue;

                    double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                    double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                    double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                    double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                    double roznicaDopasowania = Math.Abs(minX1 - stanMinX) +
                                               Math.Abs(maxX1 - stanMaxX) +
                                               Math.Abs(minY1 - stanMinY) +
                                               Math.Abs(maxY1 - stanMaxY);

                    Console.WriteLine(
                        $"   🔹 Sasiad {i + 1}: IdRegionu: {s.IdRegionu}, " +
                        $"Typ: {s.WybranyTyp}, Kąt: {s.KatSasiada}°, " +
                        $"Kierunki[G:{s.WystepujeGora} D:{s.WystepujeDol} L:{s.WystepujeLewa} P:{s.WystepujePrawa}], " +
                        $"Dopasowanie: {roznicaDopasowania:F4}, ZIndeks: {s.ZIndeks}");
                }

                // 🔹 Określ oczekiwany kierunek na podstawie kąta
                // W miejscu gdzie masz oryginalny fragment:
                bool oczekujeGora, oczekujeDol, oczekujeLewa, oczekujePrawa;

                stronaZFunkcji = OkreslStroneNaPodstawieKataZWierzcholkami(
                    katSzukaj: (float)katSzukaj,
                    WierzcholkiWartosciNominalne: WierzcholkiWartosciNominalne,  // Twoje punkty
                    out oczekujeGora,
                    out oczekujeDol,
                    out oczekujeLewa,
                    out oczekujePrawa);

                Console.WriteLine($"📐 Określono stronę: {stronaZFunkcji} (kąt: {katSzukaj}°)");

                // 🔹 Funkcja pomocnicza do obliczania dopasowania
                double ObliczDopasowanie(SasiadInfo s)
                {
                    var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                    if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                    double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                    double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                    double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                    double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                    return Math.Abs(minX1 - stanMinX) +
                           Math.Abs(maxX1 - stanMaxX) +
                           Math.Abs(minY1 - stanMinY) +
                           Math.Abs(maxY1 - stanMaxY);
                }

                // 🔹 FUNKCJA SPRAWDZAJĄCA CZY KIERUNEK PASUJE
                bool KierunekPasuje(SasiadInfo s)
                {
                    // Sprawdź czy którykolwiek oczekiwany kierunek pasuje do sąsiada
                    bool pasuje = (oczekujeGora && s.WystepujeGora) ||
                                 (oczekujeDol && s.WystepujeDol) ||
                                 (oczekujeLewa && s.WystepujeLewa) ||
                                 (oczekujePrawa && s.WystepujePrawa);

                    if (pasuje)
                    {
                        Console.WriteLine($"✅ Kierunek pasuje dla sąsiada {s.WybranyTyp} " +
                                         $"[G:{s.WystepujeGora} D:{s.WystepujeDol} L:{s.WystepujeLewa} P:{s.WystepujePrawa}]");
                    }

                    return pasuje;
                }

                // 🔹 1. PRIORYTET: "Słupek ruchomy" Z PASUJĄCYM KIERUNKIEM
                Console.WriteLine("🔍 Szukam typ --> Słupek ruchomy Z PASUJĄCYM KIERUNKIEM");

                najlepszySasiad = sasiedzi
                    .Where(s => s.WybranyTyp == "Słupek ruchomy" && KierunekPasuje(s))
                    .OrderBy(ObliczDopasowanie)
                    .FirstOrDefault();

                // 🔹 2. Jeśli nie znaleziono -> "Słupek ruchomy" BEZ KIERUNKU
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam typ --> Słupek ruchomy (bez sprawdzania kierunku)");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp == "Słupek ruchomy")
                        .OrderBy(ObliczDopasowanie)
                        .FirstOrDefault();
                }

                // 🔹 3. Jeśli nie znaleziono -> "Słupek stały" Z PASUJĄCYM KIERUNKIEM
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam typ --> Słupek stały Z PASUJĄCYM KIERUNKIEM");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp == "Słupek stały" && KierunekPasuje(s))
                        .OrderBy(ObliczDopasowanie)
                        .FirstOrDefault();
                }

                // 🔹 4. Jeśli nie znaleziono -> "Słupek stały" BEZ KIERUNKU
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam typ --> Słupek stały (bez sprawdzania kierunku)");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp == "Słupek stały")
                        .OrderBy(ObliczDopasowanie)
                        .FirstOrDefault();
                }

                // 🔹 5. Jeśli nie znaleziono -> INNE TYPY Z PASUJĄCYM KIERUNKIEM
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam innych typów Z PASUJĄCYM KIERUNKIEM");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp != "Słupek ruchomy" &&
                                   s.WybranyTyp != "Słupek stały" &&
                                   KierunekPasuje(s))
                        .OrderBy(ObliczDopasowanie)
                        .ThenBy(s => s.Id)
                        .FirstOrDefault();
                }

                // 🔹 6. Jeśli nadal nie znaleziono -> DOWOLNY INNY TYP
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam dowolnego typu (ostatnia szansa)");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp != "Słupek ruchomy" &&
                                   s.WybranyTyp != "Słupek stały")
                        .OrderBy(ObliczDopasowanie)
                        .ThenBy(s => s.Id)
                        .FirstOrDefault();
                }

                // 🔹 7. Jeśli nadal nic -> PIERWSZY Z LISTY
                if (najlepszySasiad == null && sasiedzi.Any())
                {
                    Console.WriteLine("⚠️ Biorę pierwszego z listy (żaden nie spełnia warunków)");
                    najlepszySasiad = sasiedzi.First();
                }
            }

            if (najlepszySasiad != null)
            {
                wybranyTypSasiada = najlepszySasiad.WybranyTyp;

                Console.WriteLine($"✅ WYBRANO: {najlepszySasiad.WybranyTyp}, " +
                                 $"Region: {najlepszySasiad.IdRegionu}, " +
                                 $"Kąt: {najlepszySasiad.KatSasiada}°, " +
                                 $"Kierunki[G:{najlepszySasiad.WystepujeGora} D:{najlepszySasiad.WystepujeDol} " +
                                 $"L:{najlepszySasiad.WystepujeLewa} P:{najlepszySasiad.WystepujePrawa}]");
            }
            else
            {
                Console.WriteLine("⚠️ NIE WYBRANO ŻADNEGO SĄSIADA!");
            }

            if (najlepszySasiad != null) wybranyTypSasiada = najlepszySasiad.WybranyTyp;

            Console.WriteLine(
                $"✅ DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° - " +
                $"Najlepszy sąsiad: {(najlepszySasiad != null ? najlepszySasiad.RowIdElementu : "NIE-ZNALEZIONO-ROWID")} Typ: {wybranyTypSasiada}"
            );

            /// ------------------------------------------------ Wyszukiwanie sąsiadów KONIEC ------------------------------------------------

            var rowId = ZnajdzKonfiguracjeDlaLinii(linia, state, stronaLewa, stronaPrawa, idRegion, "Słupek ruchomy");

            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = linia,
                RowIdElementu = rowId,
                RowIdSasiada = najlepszySasiad?.RowIdElementu ?? Guid.Empty,
                RowIdRegionuSasiada = najlepszySasiad?.IdRegionu ?? "",
                KatLinii = (float)katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                TypKsztaltu = generator.TypKsztaltu,
                WypelnienieWewnetrzne = generator.KolorWewnetrzny,
                WypelnienieZewnetrzne = generator.KolorZewnetrzny,
                GruboscObramowania = 2.0f,
                ZIndex = generator.Zindeks,
                Strona = stronaZFunkcji,
            });

            //if (SelectedModelType.ToLower().Trim() == "słupek stały") break;

        }

        //--------------------------------------------------- Obsługa słupka stałego --------------------------------------------------

        if (SelectedModelType.ToLower().Trim() == "słupek stały")
        {

            if (!styczneLinie.Any())
            {
                Console.WriteLine($"✅ Region {idRegion} nie zawiera słupka stałego.");
                return false;
            }

            Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Znaleziono {styczneLinie.Count} potencjalnych linii dla słupka stałego");

            generator.Zindeks = 1;

            // 🔹 Spróbuj znaleźć linię typu „Słupek stały”
            var liniaStala = styczneLinie
                .Where(s =>
                    !string.IsNullOrWhiteSpace(s.TypLiniiDzielacej) &&
                    s.TypLiniiDzielacej.ToLower().Contains("słupek") &&
                    s.Wierzcholki != null &&
                    s.Wierzcholki.Count == 2)
                .GroupBy(s => new
                {
                    X1 = Math.Round(s.Wierzcholki[0].X, 2),
                    Y1 = Math.Round(s.Wierzcholki[0].Y, 2),
                    X2 = Math.Round(s.Wierzcholki[1].X, 2),
                    Y2 = Math.Round(s.Wierzcholki[1].Y, 2),
                    Typ = s.TypLiniiDzielacej
                })
                .Select(g => g.First()) // usuwa duplikaty
                .FirstOrDefault(s =>
                    Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) > 0.01 ||
                    Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01);

            foreach (var linia in styczneLinie)
            {
                Console.WriteLine($"🔹 Sprawdzana linia: {linia.Id}, TypLiniiDzielacej: '{linia.TypLiniiDzielacej}', Wierzcholki: {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
            }

            liniaStala = styczneLinie
            .Where(s =>
                s.Wierzcholki != null &&
                s.Wierzcholki.Count == 2 &&
                s.TypLiniiDzielacej == "Słupek stały" &&
                Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) < 0.01 &&  // linia pionowa
                Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01)    // nie pozioma
            .OrderBy(s => Math.Abs(s.Wierzcholki[0].X - klikX))              // najbliżej kliknięcia
            .FirstOrDefault();

            //}

            if (liniaStala == null)
            {
                Console.WriteLine($"⚠️ Nie znaleziono linii z TypLiniiDzielacej='Słupek stały'. Szukam pionowej linii jako zamiennika... klikX: {klikX}");

                liniaStala = styczneLinie
            .Where(s =>
                s.Wierzcholki != null &&
                s.Wierzcholki.Count == 2 &&
                s.TypLiniiDzielacej == "Słupek stały" &&
                Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) > 0.01 &&  // linia pozioma
                Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) < 0.01)    // nie pionowa
            .OrderBy(s => Math.Abs(s.Wierzcholki[0].Y - klikY))              // najbliżej kliknięcia
            .FirstOrDefault();
            }

            if (liniaStala == null)
            {
                //Console.WriteLine($"⚠️ Nie znaleziono linii z TypLiniiDzielacej='Słupek stały'. Szukam poziomej linii jako zamiennika... klikY: {klikY}");
                _message.Warning("Nie znaleziono linii stycznych!!!");
                return false;
            }

            // foreach (var linia in liniaStala.Wierzcholki)
            // {
            //     Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Sprawdzana linia:  Wierzcholki: {linia.X},{linia.Y} 🔹🔹🔹🔹🔹🔹");
            // }

            if (liniaStala == null)
            {
                //Console.WriteLine("❌ Nadal nie znaleziono poprawnej linii słupka (brak dwóch różnych punktów lub pionowej linii).");
                return false;
            }

            // 🔹 Określ orientację
            bool pionowy = Math.Abs(liniaStala.Wierzcholki[0].X - liniaStala.Wierzcholki[1].X) < 0.01;
            bool poziomy = Math.Abs(liniaStala.Wierzcholki[0].Y - liniaStala.Wierzcholki[1].Y) < 0.01;

            var orientacja = pionowy ? "Pionowa" : poziomy ? "Pozioma" : "Skośna";
            // Console.WriteLine($"📏 Rozpoznano linię: {orientacja} Ilość linii stycznych: {styczneLinie.Count()}");

            // 🔹 Oblicz kąt
            var katSzukaj = ObliczKatLinii(liniaStala.Wierzcholki);

            // Console.WriteLine($"📐 Kąt słupka stałego: {katSzukaj:F2}° X0:{liniaStala.Wierzcholki[0].X} Y0:{liniaStala.Wierzcholki[0].Y} X1:{liniaStala.Wierzcholki[1].X} Y1:{liniaStala.Wierzcholki[1].Y}");

            generator.RowIdModelu = generator.MVCKonfModelu.KonfSystem.FirstOrDefault().RowId;// Pobieram RowIdModelu z konfiguracji systemu
            generator.CzyElementJestRama = false;

            List<XPoint> liniaStalaWierzcholki = new List<XPoint>
                {
                    new XPoint { X = liniaStala.Wierzcholki[0].X, Y = liniaStala.Wierzcholki[0].Y },
                    new XPoint { X = liniaStala.Wierzcholki[1].X, Y = liniaStala.Wierzcholki[1].Y }
                };

            // 🔹 Wyszukaj najlepszego sąsiada
            var najlepszySasiadA = sasiedzi
                .Where(s =>
                    s.WybranyTyp != "Słupek ruchomy" && (s.WystepujeGora || s.WystepujeLewa))
                .FirstOrDefault();

            var najlepszySasiadB = sasiedzi
            .Where(s =>
                s.WybranyTyp != "Słupek ruchomy" && (s.WystepujeDol || s.WystepujePrawa))
            .OrderByDescending(sasiedzi => sasiedzi.WystepujeDol)
            .FirstOrDefault();

            // 🔹 Zapisz dane do stanu (jeśli znaleziono sąsiada)
            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = liniaStalaWierzcholki,
                RowIdElementu = Guid.Empty, //generator.RowIdModelu, -- do sprawdzenia....
                RowIdSasiada = najlepszySasiadA?.RowIdElementu ?? Guid.Empty,

                // 🔸 Strona A — jeśli sąsiad występuje od góry lub lewej
                RowIdSasiadaStronaA = najlepszySasiadA?.RowIdElementu ?? Guid.Empty,

                // 🔸 Strona B — jeśli sąsiad występuje od dołu lub prawej
                RowIdSasiadaStronaB = najlepszySasiadB?.RowIdElementu ?? Guid.Empty,

                RowIdRegionuSasiada = najlepszySasiadA?.IdRegionu ?? "",
                KatLinii = (float)katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                Strona = "Środek",
                BoolElementLinia = true,
                TypKsztaltu = generator.TypKsztaltu,
                WypelnienieWewnetrzne = generator.KolorWewnetrzny,
                WypelnienieZewnetrzne = generator.KolorZewnetrzny,
                GruboscObramowania = 2.0f,
                ZIndex = generator.Zindeks,
            });

            // 🔹 Aktualizacja stanu
            state.ZIndeks = generator.Zindeks;
            state.WierzcholkiWartosciNominalne = liniaStalaWierzcholki;
            generator.RuchomySlupekPoLewej = stronaLewa;
            generator.RuchomySlupekPoPrawej = stronaPrawa;
            generator.ElementLiniowy = true;

            //Console.WriteLine($"✅ Rozpoczynam przekazywanie AddElements ID: {idRegion} sasiedzi.Count: {sasiedzi.Count()} najlepszy sąsiad stroanA: {najlepszySasiadA?.RowIdElementu ?? Guid.Empty} stroanB: {najlepszySasiadB?.RowIdElementu ?? Guid.Empty}");

            // //   var regionLinia = wszystkieRegiony.
            // foreach (var r in wszystkieRegiony)
            // {
            //     Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Sprawdzany region dla słupka stałego: ID: {r.Id} Wierzcholki.Count: {r.Wierzcholki.Count} X:{r.Wierzcholki[0].X} Y:{r.Wierzcholki[0].Y} TypLiniiDzielacej: {r.TypLiniiDzielacej}🔹🔹🔹🔹🔹🔹");
            // }

            double tolerancjaKlikniecia = 55.0; // odległość w jednostkach np. pikselac

            var regionKlikniety = wszystkieRegiony
             .Select(r => new
             {
                 Region = r,
                 Odleglosc = OdlegloscPunktuOdOdcinka(
                     klikX, klikY,
                     r.Wierzcholki[0].X, r.Wierzcholki[0].Y,
                     r.Wierzcholki[1].X, r.Wierzcholki[1].Y)
             })
             .OrderBy(x => x.Odleglosc)
             .FirstOrDefault(x => x.Odleglosc < tolerancjaKlikniecia)?.Region;

            if (regionKlikniety != null)
            {

                var ok = await generator.AddElements(
                      new List<ShapeRegion> { regionKlikniety },
                      idRegion,
                      _generatorStates,
                      _regionsDualRama,
                      state.ListaKwadratow,
                      wszystkieRegiony.FirstOrDefault(r => r.IdMaster.Contains(idRegion.Substring(0, 35))).Wierzcholki
                  );

                if (!ok)
                {
                    _message.Error($"Nie można wygenerować elementów dla regionu {idRegion}. Sprawdź wymiary i kształt regionu.");
                }

            }

            Console.WriteLine($"📐📐📐 Słupek stały zakończony pomyślnie --> wierzcholkiMaster.Count: {wierzcholkiMaster.Count()} idRegion: {idRegion} 📐📐📐");

        }

        //--------------------------------------------------- Obsługa skrzydła --------------------------------------------------
        if (SelectedModelType.Trim() == "Skrzydło" || SelectedModelType.Trim() == "Skrzydło z słupkiem ruchomym")
        {
            var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);
            linieDzielace = wybranyRegionSkrzydlo?.TypLiniiDzielacej ?? "Brak";

            if (wybranyRegionSkrzydlo != null)
            {
                var regionPointsSkrzydlo = wybranyRegionSkrzydlo.Wierzcholki;

                if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionSkrzydlo.IdRegionuPonizej ?? idRegion + "-BLAD";

                minX = regionPointsSkrzydlo.Min(p => p.X);
                maxX = regionPointsSkrzydlo.Max(p => p.X);
                minY = regionPointsSkrzydlo.Min(p => p.Y);
                maxY = regionPointsSkrzydlo.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = SelectedModelType == "Skrzydło z słupkiem ruchomym" ? 2 : 3;
                generator.CzyElementJestRama = false;

                //luzy wynikahjące z przesunięcia

                // najpierw wczytujesz region i dodajesz jego dane
                var regionDoDodania = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

                if (regionDoDodania != null)
                {
                    // ✅ KOPIOWANIE punktów do regionu, na którym operuje AddElements
                    regionDoDodania.Wierzcholki = WierzcholkiWartosciNominalne
                        .Select(p => new XPoint { X = p.X, Y = p.Y })
                        .ToList();

                    // ✅ Najpierw przesuń punkty
                    await WyliczObszarSkrzydla(
                        state,
                        przesLewo, przesPrawo,
                        przesGora, przesDol,
                        stronaLewa, stronaPrawa,
                        generator, regionDoDodania
                    );

                    await Task.Delay(1); // krótkie opóźnienie dla stabilności

                    // 4. Zapisz do stanu
                    state.ZIndeks = generator.Zindeks;
                    state.Wierzcholki = regionDoDodania.Wierzcholki;
                    state.WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne;

                    generator.RuchomySlupekPoLewej = stronaLewa;
                    generator.RuchomySlupekPoPrawej = stronaPrawa;

                    // 5. Dodaj elementy
                    var ok = await generator.AddElements(new List<ShapeRegion> { regionDoDodania }, idRegion, _generatorStates, _regionsSkrzydlo, state.ListaKwadratow);

                    if (!ok)
                    {
                        _message.Error($"Nie można wygenerować elementów dla regionu {idRegion}. Sprawdź wymiary i kształt regionu.");
                    }

                }
                else
                {
                    Console.WriteLine($"❌ Nie znaleziono regionu skrzydła o ID: {idRegion}");

                }

            }
            else
            {
                Console.WriteLine($"📐📐📐 wybranyRegionSkrzydlo == null");
            }
        }

        //   Console.WriteLine($"✅ ElementyRamyRysowane.Count: {generator.ElementyRamyRysowane.Count}");

        if (generator.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine($"❌ Brak elementów do rysowania! Dla: {WybranyModel.NazwaKonfiguracji}");
            return false;
        }

        // Console.WriteLine($"📦📦📦 Generowanie elementów ListaKwadratow: {state.ListaKwadratow.Count}.");

        // Console.WriteLine($"📦📦📦 Dodano elementy do regionu {idRegion} o typie {SelectedModelType}. przesLewo:{przesLewo}, przesPrawo:{przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol} 📦📦📦");
        // Zapis do słownika i aktualizacja listy

        if (slupekStaly)
        {
            string best = WybierzNajblizszySlupek(wierzcholki, idSlupka, klikX, klikY);

            if (best != null)
            {
                Console.WriteLine($"📌 -SL- Dopasowano słupek stały do ID: {best}");
            }
            else
            {
                Console.WriteLine($"⚠️ -SL- Nie dopasowano słupka stałego, generuję nowy ID.");
                _message.Warning("Nie dopasowano słupka stałego, generuję nowy ID.");
            }

            state.IdRegion = best ?? $"{idRegion}-SL-" + Guid.NewGuid().ToString();
        }
        else
        {
            state.IdRegion = idRegion;
        }

        _ksztaltyNaRegion[state.IdRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        Console.WriteLine($"📦📦📦 Generowanie elementów zarejetrowano ilość ksztalty: {ksztalty.Count}.");

        string cleanId = CleanId(state.IdRegion);

        await Task.Delay(500); // krótkie opóźnienie dla stabilności

        AddOrUpdateGeneratorState(cleanId, state, generator);

        //await ApplyZoom(_currentScale);

        return true;
    }

    /// <summary>
    /// Określa stronę elementu na podstawie kąta i wierzchołków (z korektą dla elementów w górnej części).
    /// </summary>
    /// <param name="katSzukaj">Kąt elementu w stopniach</param>
    /// <param name="WierzcholkiWartosciNominalne">Lista wierzchołków elementu (opcjonalna, dla korekty)</param>
    /// <param name="oczekujeGora">[out] Czy oczekiwana jest strona górna</param>
    /// <param name="oczekujeDol">[out] Czy oczekiwana jest strona dolna</param>
    /// <param name="oczekujeLewa">[out] Czy oczekiwana jest strona lewa</param>
    /// <param name="oczekujePrawa">[out] Czy oczekiwana jest strona prawa</param>
    /// <returns>Nazwa strony ("Góra", "Dół", "Lewa", "Prawa")</returns>
    public string OkreslStroneNaPodstawieKataZWierzcholkami(
        float katSzukaj,
        List<XPoint> WierzcholkiWartosciNominalne,
        out bool oczekujeGora,
        out bool oczekujeDol,
        out bool oczekujeLewa,
        out bool oczekujePrawa)
    {
        // Inicjalizacja zmiennych wyjściowych
        oczekujeGora = false;
        oczekujeDol = false;
        oczekujeLewa = false;
        oczekujePrawa = false;

        // Normalizuj kąt do zakresu 0-360
        float kat = katSzukaj % 360;
        if (kat < 0) kat += 360;

        // Logika identyczna z OkreslStroneNaPodstawieKata
        string strona = kat switch
        {
            >= 45 and < 135 => "Prawa",
            >= 135 and < 225 => "Dół",
            >= 225 and < 315 => "Lewa",
            _ => "Góra"
        };

        // KOREKTA: Jeśli mamy punkty w WierzcholkiWartosciNominalne, możemy spróbować określić pozycję
        if (WierzcholkiWartosciNominalne != null && WierzcholkiWartosciNominalne.Count >= 2)
        {
            // Jeśli mamy tylko 2 punkty (linia), uśrednij ich pozycje
            double centerY;
            if (WierzcholkiWartosciNominalne.Count == 2)
            {
                centerY = (WierzcholkiWartosciNominalne[0].Y + WierzcholkiWartosciNominalne[1].Y) / 2;
            }
            else
            {
                // Dla wielokąta oblicz środek geometryczny
                centerY = WierzcholkiWartosciNominalne.Average(p => p.Y);
            }

            double minYSK = WierzcholkiWartosciNominalne.Min(p => p.Y);
            double maxYSK = WierzcholkiWartosciNominalne.Max(p => p.Y);

            // Jeśli środek jest w górnej 1/3 kształtu
            if (centerY < minYSK + (maxYSK - minYSK) * 0.33)
            {
                // Sprawdź czy kąt jest zbliżony do poziomego
                bool isNearHorizontal = (Math.Abs(kat) < 30) ||
                                       (Math.Abs(kat - 360) < 30) ||
                                       (Math.Abs(kat - 180) < 30);

                if (isNearHorizontal)
                {
                    strona = "Góra";
                    Console.WriteLine($"📐 KOREKTA: Zmieniono na GÓRA (element w górnej części, kąt: {kat}°)");
                }
            }
        }

        // Ustaw flagi boolowskie na podstawie określonej strony
        oczekujeGora = (strona == "Góra");
        oczekujeDol = (strona == "Dół");
        oczekujeLewa = (strona == "Lewa");
        oczekujePrawa = (strona == "Prawa");

        Console.WriteLine($"📐 Określono stronę: {strona} (kąt: {kat}°)");

        return strona;
    }

    private string WybierzNajblizszySlupek(
        List<XPoint> wierzcholki,
        List<string> idSlupka,
        double klikX,
        double klikY)
    {
        if (wierzcholki == null || wierzcholki.Count < 2)
            return null;

        if (idSlupka == null || idSlupka.Count == 0)
            return null;

        var pKlik = new XPoint(klikX, klikY);

        double minDist = double.MaxValue;
        string bestId = null;

        int index = 0;

        // Zakładamy, że każda para punktów (0,1), (2,3), ... odpowiada jednemu idSlupka[index]
        for (int i = 0; i + 1 < wierzcholki.Count; i += 2)
        {
            if (index >= idSlupka.Count) break;

            var a = wierzcholki[i];
            var b = wierzcholki[i + 1];

            double dist = DistancePointToSegment(pKlik, a, b);

            if (dist < minDist)
            {
                minDist = dist;
                bestId = idSlupka[index];
            }

            index++;
        }

        return bestId;
    }

    // Pomocnicza: odległość punktu od odcinka (przyjmuje XPoint)
    private double DistancePointToSegment(XPoint p, XPoint a, XPoint b)
    {
        double A = p.X - a.X;
        double B = p.Y - a.Y;
        double C = b.X - a.X;
        double D = b.Y - a.Y;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = (len_sq != 0) ? dot / len_sq : -1;

        double xx, yy;

        if (param < 0)
        {
            xx = a.X;
            yy = a.Y;
        }
        else if (param > 1)
        {
            xx = b.X;
            yy = b.Y;
        }
        else
        {
            xx = a.X + param * C;
            yy = a.Y + param * D;
        }

        double dx = p.X - xx;
        double dy = p.Y - yy;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    private static double OdlegloscPunktuOdOdcinka(double px, double py, double x1, double y1, double x2, double y2)
    {
        double A = px - x1;
        double B = py - y1;
        double C = x2 - x1;
        double D = y2 - y1;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = len_sq != 0 ? dot / len_sq : -1;

        double najblizszyX, najblizszyY;

        if (param < 0)
        {
            najblizszyX = x1;
            najblizszyY = y1;
        }
        else if (param > 1)
        {
            najblizszyX = x2;
            najblizszyY = y2;
        }
        else
        {
            najblizszyX = x1 + param * C;
            najblizszyY = y1 + param * D;
        }

        double dx = px - najblizszyX;
        double dy = py - najblizszyY;
        return Math.Sqrt(dx * dx + dy * dy);
    }

    // Przeciążenie dla XPoint
    private static double OdlegloscPunktuOdOdcinka(XPoint p, XPoint a, XPoint b)
    {
        return OdlegloscPunktuOdOdcinka(p.X, p.Y, a.X, a.Y, b.X, b.Y);
    }

    private static bool CzyPunktyRowneSlupek(XPoint p1, XPoint p2, double epsilon = 0.001)
    {
        return Math.Abs(p1.X - p2.X) < epsilon && Math.Abs(p1.Y - p2.Y) < epsilon;
    }

    private async Task<ShapeRegion> WyliczObszarSlupkaStalego(
        GeneratorState state,
        double przesLewo, double przesPrawo,
        double przesGora, double przesDol,
        Generator generator,
        ShapeRegion regionSlupka)
    {
        Console.WriteLine($"📐 WyliczObszarSlupkaStalego -> Przesunięcia: Lewo: {przesLewo}, Prawo: {przesPrawo}, Góra: {przesGora}, Dół: {przesDol}");

        if (regionSlupka == null || regionSlupka.Wierzcholki == null || regionSlupka.Wierzcholki.Count < 2)
            return null;

        var punkty = regionSlupka.Wierzcholki;

        double minX = punkty.Min(p => p.X);
        double maxX = punkty.Max(p => p.X);
        double minY = punkty.Min(p => p.Y);
        double maxY = punkty.Max(p => p.Y);

        double width = maxX - minX;
        double height = maxY - minY;

        bool pionowy = height > width;   // wykrycie orientacji
        bool poziomy = !pionowy;

        var nowe = new List<XPoint>();

        foreach (var p in punkty)
        {
            double newX = p.X;
            double newY = p.Y;

            if (pionowy)
            {
                // 🔹 przesunięcie w osi X
                newX += (przesPrawo - przesLewo);

                // 🔹 zmiana długości (góra/dół)
                if (Math.Abs(p.Y - minY) < 0.001)
                    newY += przesDol;

                if (Math.Abs(p.Y - maxY) < 0.001)
                    newY -= przesGora;
            }
            else
            {
                // 🔹 przesunięcie w osi Y
                newY += (przesGora - przesDol);

                // 🔹 zmiana długości (lewo/prawo)
                if (Math.Abs(p.X - minX) < 0.001)
                    newX += przesLewo;

                if (Math.Abs(p.X - maxX) < 0.001)
                    newX -= przesPrawo;
            }

            nowe.Add(new XPoint(newX, newY));
        }

        regionSlupka.Wierzcholki = nowe;

        // zapis offsetów do state (opcjonalnie)
        if (state != null && state.ListaKwadratow.Count > 0)
        {
            state.ListaKwadratow[^1].OffsetLeft = przesLewo;
            state.ListaKwadratow[^1].OffsetRight = przesPrawo;
            state.ListaKwadratow[^1].OffsetTop = przesGora;
            state.ListaKwadratow[^1].OffsetBottom = przesDol;
        }

        await Task.Delay(5);
        return regionSlupka;
    }

    private async Task<ShapeRegion> WyliczObszarSkrzydla(
        GeneratorState state,
        double przesLewo, double przesPrawo, double przesGora, double przesDol,
        bool stronaLewa, bool stronaPrawa,
        Generator generator,
        ShapeRegion _regionsSkrzydlo)
    {
        if (_regionsSkrzydlo == null)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla -> Nie znaleziono regionu o podanym ID.");
            return null;
        }

        var regionPointsSkrzydlo = _regionsSkrzydlo.Wierzcholki;

        if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla -> Region ma za mało punktów.");
            return null;
        }

        // 🔹 Oblicz bounding box
        double minX = regionPointsSkrzydlo.Min(p => p.X);
        double maxX = regionPointsSkrzydlo.Max(p => p.X);
        double minY = regionPointsSkrzydlo.Min(p => p.Y);
        double maxY = regionPointsSkrzydlo.Max(p => p.Y);

        // 🔹 Pobierz przesunięcia z boków
        foreach (var bok in state.ListaKwadratow)
        {
            var polaczenieWartosci = await PobierzPolaczenia(bok.RowIdSasiada, bok.RowIdElementu, bok.Strona ?? "NaN");
            var spolaczenieStrona = polaczenieWartosci.FirstOrDefault();

            double przesY = spolaczenieStrona != null
                ? Math.Abs(spolaczenieStrona.PrzesuniecieY)
                : 0;

            Console.WriteLine($"📦 WyliczObszarSkrzydla -> Sprawdzam bok: {bok.RowIdElementu}, Strona: {bok.Strona}, przesY: {przesY} przesLewo: {przesLewo} przesPrawo: {przesPrawo} przesGora: {przesGora} przesDol: {przesDol}");

            switch (bok.Strona.ToLower())
            {
                case "lewa": przesLewo = przesY; break;
                case "prawa": przesPrawo = przesY; break;
                case "góra": przesGora = przesY; break;
                case "dół": przesDol = przesY; break;
            }

            // fallback tylko gdy brak sąsiada
            if (bok.RowIdSasiada == Guid.Empty)
            {
                var konf = generator.KonfiguracjeSystemu
                    .FirstOrDefault(s => s.RowId == bok.RowIdElementu);

                if (konf != null)
                {
                    double fallback = -((konf.PoziomDol ?? 0) - (konf.PoziomOsSymetrii ?? 0));

                    Console.WriteLine($"📦 WyliczObszarSkrzydla -> bok.RowIdElementu: {bok.RowIdElementu}, fallback: {fallback}");

                    switch (bok.Strona.ToLower())
                    {
                        case "lewa": if (stronaLewa) przesLewo = fallback; break;
                        case "prawa": if (stronaPrawa) przesPrawo = fallback; break;
                        case "góra": przesGora = fallback; break;
                        case "dół": przesDol = fallback; break;
                    }
                }
            }
        }

        // 🔧 Przesuń punkty konturu — teraz po normalnych do krawędzi (obsługuje trapezy)
        var nowePunkty = new List<XPoint>();

        for (int i = 0; i < regionPointsSkrzydlo.Count; i++)
        {
            var prev = regionPointsSkrzydlo[(i - 1 + regionPointsSkrzydlo.Count) % regionPointsSkrzydlo.Count];
            var curr = regionPointsSkrzydlo[i];
            var next = regionPointsSkrzydlo[(i + 1) % regionPointsSkrzydlo.Count];

            // Wektor poprzedniej i następnej krawędzi
            var dir1 = new XPoint(curr.X - prev.X, curr.Y - prev.Y);
            var dir2 = new XPoint(next.X - curr.X, next.Y - curr.Y);

            // Normalizuj
            double len1 = Math.Sqrt(dir1.X * dir1.X + dir1.Y * dir1.Y);
            double len2 = Math.Sqrt(dir2.X * dir2.X + dir2.Y * dir2.Y);
            if (len1 < 0.0001 || len2 < 0.0001)
            {
                nowePunkty.Add(curr);
                continue;
            }
            dir1.X /= len1; dir1.Y /= len1;
            dir2.X /= len2; dir2.Y /= len2;

            // Wektory normalne (prostopadłe)
            var n1 = new XPoint(-dir1.Y, dir1.X);
            var n2 = new XPoint(-dir2.Y, dir2.X);

            // Kąty normalnych
            double kat1 = (Math.Atan2(n1.Y, n1.X) * 180.0 / Math.PI + 360) % 360;
            double kat2 = (Math.Atan2(n2.Y, n2.X) * 180.0 / Math.PI + 360) % 360;

            // Wybór przesunięcia na podstawie kierunku
            double offset1 = (kat1 >= 315 || kat1 < 45) ? przesLewo :
                             (kat1 >= 45 && kat1 < 135) ? przesGora :
                             (kat1 >= 135 && kat1 < 225) ? przesPrawo :
                             przesDol;

            double offset2 = (kat2 >= 315 || kat2 < 45) ? przesLewo :
                             (kat2 >= 45 && kat2 < 135) ? przesGora :
                             (kat2 >= 135 && kat2 < 225) ? przesPrawo :
                             przesDol;

            // Przesuń obie linie wzdłuż ich normalnych
            var p1a = new XPoint(prev.X + n1.X * offset1, prev.Y + n1.Y * offset1);
            var p1b = new XPoint(curr.X + n1.X * offset1, curr.Y + n1.Y * offset1);

            var p2a = new XPoint(curr.X + n2.X * offset2, curr.Y + n2.Y * offset2);
            var p2b = new XPoint(next.X + n2.X * offset2, next.Y + n2.Y * offset2);

            // Oblicz przecięcie przesuniętych linii (czyli nowy wierzchołek)

            var nowy = PrzeciecieLinii(p1a, p1b, p2a, p2b);
            nowePunkty.Add(nowy ?? new XPoint(curr.X, curr.Y));
        }

        regionPointsSkrzydlo = nowePunkty;

        double minXSPRAWDZENIE = regionPointsSkrzydlo.Min(p => p.X);
        Console.WriteLine($"📦📦📦 WyliczObszarSkrzydla -> Po przesunięciu minX: {minXSPRAWDZENIE}, przesLewo: {przesLewo}, przesPrawo: {przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol}");

        // 🔹 Zaktualizuj offsety w stanie
        if (state != null && state.ListaKwadratow.Count() > 0)
        {
            state.ListaKwadratow[^1].OffsetLeft = przesLewo;
            state.ListaKwadratow[^1].OffsetRight = przesPrawo;
            state.ListaKwadratow[^1].OffsetTop = przesGora;
            state.ListaKwadratow[^1].OffsetBottom = przesDol;
        }

        _regionsSkrzydlo.Wierzcholki = regionPointsSkrzydlo;

        await Task.Delay(10); // krótkie opóźnienie dla stabilności

        return _regionsSkrzydlo;
    }

    private XPoint? PrzeciecieLinii(XPoint p1, XPoint p2, XPoint p3, XPoint p4)
    {
        double A1 = p2.Y - p1.Y;
        double B1 = p1.X - p2.X;
        double C1 = A1 * p1.X + B1 * p1.Y;

        double A2 = p4.Y - p3.Y;
        double B2 = p3.X - p4.X;
        double C2 = A2 * p3.X + B2 * p3.Y;

        double det = A1 * B2 - A2 * B1;
        if (Math.Abs(det) < 0.0001)
            return null; // teraz poprawnie, bo typ jest XPoint?

        double x = (B2 * C1 - B1 * C2) / det;
        double y = (A1 * C2 - A2 * C1) / det;
        return new XPoint(x, y);
    }

    private async Task<List<PrzesuniecieDto>> PobierzPolaczenia(Guid zewId, Guid wewId, string strona)
    {
        if (zewId == Guid.Empty || wewId == Guid.Empty || string.IsNullOrWhiteSpace(strona))
        {
            if (infoObiekt == null)
            {
                infoObiekt = new List<WyrobWymiaryOpis>();
            }

            if (string.IsNullOrWhiteSpace(strona))
            {
                strona = "NaN";
            }

            WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc, SelectedModelType ?? "", $"Nie wyszukano indesku elementu dla strony: {strona}");
            infoObiekt.Add(opisy);

            return new List<PrzesuniecieDto>();
        }

        try
        {
            Console.WriteLine($"📦 PobierzPolaczenia-> Pobieram przesunięcia zewnątrz: {zewId} wewnątrz: {wewId} strona: {strona}");

            var response = await Http.GetAsync($"api/konfpolaczenie/find-shifts/{zewId}/{wewId}/{strona}");

            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<PrzesuniecieDto>>();

                if (lista != null && lista.Count() > 0)
                {
                    foreach (var item in lista)
                    {
                        Console.WriteLine($"📦 PobierzPolaczenia-> : PrzesuniecieX: {item.PrzesuniecieX}, PrzesuniecieY: {item.PrzesuniecieY}");
                    }
                }

                return lista ?? new List<PrzesuniecieDto>();
            }
            else
            {
                Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {ex.Message}");
        }

        return new List<PrzesuniecieDto>();
    }


    private async Task<List<KonfPolaczenie>> PobierzPolaczeniaAll(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 Pobieram dane połączeń z: {zewId} w: {wewId} strona: {strona}");
            var response = await Http.GetAsync($"api/konfpolaczenie/find-by-elements-all/{zewId}/{wewId}");
            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>();
                return lista ?? new List<KonfPolaczenie>();
            }
            else
            {
                Console.WriteLine($"❌ Błąd podczas pobierania połączeń: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd podczas pobierania połączenia: {ex.Message}");
        }

        return new List<KonfPolaczenie>();
    }

    private static double ObliczKatLinii(List<XPoint> linia)
    {
        if (linia == null || linia.Count < 2)
            return 0;

        var p1 = linia[0];
        var p2 = linia[1];

        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;

        if (Math.Abs(dx) < 0.001 && Math.Abs(dy) < 0.001)
            return 0;

        double kat = Math.Atan2(dy, dx) * 180.0 / Math.PI;
        kat = (kat + 360) % 360; // Normalizacja do 0-360

        return kat;
    }

    public static Guid ZnajdzKonfiguracjeDlaLinii(
        List<XPoint> linia,
        GeneratorState stan,
        bool slRuchStroLewa,
        bool slRuchStroPrawa,
        string obecnyRegionId,
        string typSlupka)
    {
        if (linia == null || linia.Count != 2 || stan?.WierzcholkiWartosciNominalne == null)
            return Guid.Empty;

        var p1 = linia[0];
        var p2 = linia[1];

        // 🔹 Oblicz rzeczywisty kąt linii (0-360°)
        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;
        double katLinii = Math.Atan2(dy, dx) * 180.0 / Math.PI;
        katLinii = (katLinii + 360) % 360; // Normalizacja do 0-360

        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> Kąt linii: {katLinii:F1}°");

        // 🔹 Określ typ linii z większą tolerancją
        const double katTolerancja = 12.0;

        bool jestPionowa = Math.Abs(katLinii - 90) <= katTolerancja ||
                          Math.Abs(katLinii - 270) <= katTolerancja;
        bool jestPozioma = Math.Abs(katLinii) <= katTolerancja ||
                          Math.Abs(katLinii - 180) <= katTolerancja ||
                          Math.Abs(katLinii - 360) <= katTolerancja;
        bool jestSkosna = !jestPionowa && !jestPozioma;

        // 🔹 Określ kierunek (ważne dla skośnych)
        string kierunek = "";
        if (jestSkosna)
        {
            if (katLinii > 0 && katLinii < 90) kierunek = "GORA_PRAWO";
            else if (katLinii > 90 && katLinii < 180) kierunek = "PRAWO_DOL";
            else if (katLinii > 180 && katLinii < 270) kierunek = "DOL_LEWO";
            else kierunek = "LEWO_GORA";
        }

        double minX = stan.WierzcholkiWartosciNominalne.Min(v => v.X);
        double maxX = stan.WierzcholkiWartosciNominalne.Max(v => v.X);
        double minY = stan.WierzcholkiWartosciNominalne.Min(v => v.Y);
        double maxY = stan.WierzcholkiWartosciNominalne.Max(v => v.Y);

        // 🔹 Oblicz środki dynamicznie
        double srodekX = (minX + maxX) / 2;
        double srodekY = (minY + maxY) / 2;

        // 🔹 Tolerancja procentowa (np. 5% wymiarów)
        double tolerancjaX = (maxX - minX) * 0.05;
        double tolerancjaY = (maxY - minY) * 0.05;

        if (stan?.MVCKonfModelu?.KonfSystem == null)
            return Guid.Empty;

        string slLewa = slRuchStroLewa ? typSlupka : "";
        string slPrawa = slRuchStroPrawa ? typSlupka : "";

        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> Typ: {typSlupka}, " +
                          $"Pionowa: {jestPionowa}, Pozioma: {jestPozioma}, Skośna: {jestSkosna}, " +
                          $"Kierunek: {kierunek}, Środek X: {srodekX:F1}, Y: {srodekY:F1}");

        // 🔹 DLA LINII SKOŚNYCH - specjalna logika
        if (jestSkosna)
        {
            Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii 🔍 Linia skośna -> potrzeba specjalnej logiki dla kąta {katLinii:F1}°");

            if (kierunek == "GORA_PRAWO")
            {
                // Może być traktowana jako "lewa" lub "górna" w zależności od kontekstu
                foreach (var konf in stan.MVCKonfModelu.KonfSystem)
                {
                    if (konf.WystepujePrawa || konf.WystepujeGora)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Skośna] {kierunek} -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }
            }

            if (kierunek == "LEWO_GORA")
            {
                // Może być traktowana jako "lewa" lub "górna" w zależności od kontekstu
                foreach (var konf in stan.MVCKonfModelu.KonfSystem)
                {
                    if (konf.WystepujeLewa || konf.WystepujeGora)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Skośna] {kierunek} -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }
            }

            if (kierunek == "DOL_LEWO")
            {
                // Może być traktowana jako "lewa" lub "górna" w zależności od kontekstu
                foreach (var konf in stan.MVCKonfModelu.KonfSystem)
                {
                    if (konf.WystepujeLewa)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Skośna] {kierunek} -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }
            }

            if (kierunek == "PRAWO_DOL")
            {
                // Może być traktowana jako "lewa" lub "górna" w zależności od kontekstu
                foreach (var konf in stan.MVCKonfModelu.KonfSystem)
                {
                    if (konf.WystepujePrawa)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Skośna] {kierunek} -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }
            }


        }

        Guid znaleziony = Guid.Empty;

        // 🔹 DLA LINII PIONOWYCH/POZIOMYCH - oryginalna logika z poprawkami

        // 1️⃣ Najpierw próba z uwzględnieniem słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                // 🔹 Sprawdź czy linia jest blisko lewej krawędzi
                if (Math.Abs(p1.X - minX) < tolerancjaX && konf.WystepujeLewa)
                {
                    bool czyPasujeDoSlupka = string.IsNullOrEmpty(slLewa) ||
                                            konf.Typ.Contains(slLewa) ||
                                            (!string.IsNullOrEmpty(typSlupka) && konf.Typ.Contains(typSlupka));

                    if (czyPasujeDoSlupka)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Słupkowy] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }

                // 🔹 Sprawdź czy linia jest blisko prawej krawędzi
                if (Math.Abs(p1.X - maxX) < tolerancjaX && konf.WystepujePrawa)
                {
                    bool czyPasujeDoSlupka = string.IsNullOrEmpty(slPrawa) ||
                                            konf.Typ.Contains(slPrawa) ||
                                            (!string.IsNullOrEmpty(typSlupka) && konf.Typ.Contains(typSlupka));

                    if (czyPasujeDoSlupka)
                    {
                        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Słupkowy] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                        return konf.RowId;
                    }
                }
            }
            else if (jestPozioma)
            {
                // 🔹 Sprawdź czy linia jest blisko górnej krawędzi
                if (Math.Abs(p1.Y - minY) < tolerancjaY && konf.WystepujeGora)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Słupkowy] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                // 🔹 Sprawdź czy linia jest blisko dolnej krawędzi
                if (Math.Abs(p1.Y - maxY) < tolerancjaY && konf.WystepujeDol)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Słupkowy] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        // 2️⃣ Jeśli nie znaleziono — szukaj bez słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (Math.Abs(p1.X - minX) < tolerancjaX && konf.WystepujeLewa)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Bez słupka] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (Math.Abs(p1.X - maxX) < tolerancjaX && konf.WystepujePrawa)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Bez słupka] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (Math.Abs(p1.Y - minY) < tolerancjaY && konf.WystepujeGora)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Bez słupka] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (Math.Abs(p1.Y - maxY) < tolerancjaY && konf.WystepujeDol)
                {
                    Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Bez słupka] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        // 3️⃣ Fallback - pierwsza pasująca konfiguracja
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa && (konf.WystepujeLewa || konf.WystepujePrawa))
            {
                Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Fallback] -> {konf.RowId} Typ:{konf.Typ}");
                return konf.RowId;
            }

            if (jestPozioma && (konf.WystepujeGora || konf.WystepujeDol))
            {
                Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Fallback] -> {konf.RowId} Typ:{konf.Typ}");
                return konf.RowId;
            }

            if (jestSkosna)
            {
                // Dla skośnych akceptujemy dowolną konfigurację
                Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii ✅ [Fallback skośna] -> {konf.RowId} Typ:{konf.Typ}");
                return konf.RowId;
            }
        }

        Console.WriteLine("🔍 ZnajdzKonfiguracjeDlaLinii ❌ ZnajdzKonfiguracjeDlaLinii -> Nie znaleziono konfiguracji.");
        return Guid.Empty;
    }

    public async Task<List<SasiadInfo>> ZnajdzSasiada(
        List<XPoint> linia,
        List<GeneratorState> wszystkieStany,
        float kat,
        bool ruchomySlupekPoLewej,
        bool ruchomySlupekPoPrawej,
        string obecnyRegionId,
        int id,
        bool czyModelMaSlupekRuchomy,
        bool szukajNieRownoleglych,
        double tolerancja)
    {
        Console.WriteLine($"🔍 ZnajdzSasiada start funkcji");

        var pasujace = new List<SasiadInfo>();

        // 🔹 Walidacja wejścia
        if (linia == null || linia.Count != 2)
        {
            Console.WriteLine($"🔍 ZnajdzSasiada zmienna linia ma punktów: {(linia == null ? "linia ma wartość null" : linia.Count)}");
            return new List<SasiadInfo>
        {
            new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = "",
                ZIndeks = -1,
                MaSlupekRuchomy = false,
                Id = 0,
                WybranyTyp = "LINIA NIE SPEŁNIA WARUNKÓW"
            }
        };
        }

        var p1 = linia[0];
        var p2 = linia[1];

        // Obliczamy rzeczywisty kąt linii
        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;
        double katLinii = Math.Atan2(dy, dx) * 180.0 / Math.PI;
        katLinii = (katLinii + 360) % 360; // normalizacja do 0–360°

        Console.WriteLine($"📐 ZnajdzSasiada -> Rzeczywisty kąt linii: {katLinii:F1}°, Parametr kat: {kat}°");

        // 🔹 Określ typ linii z większą tolerancją
        const double katTolerancja = 12.0; // Zwiększona tolerancja dla kątów skośnych

        bool jestPionowa = Math.Abs(katLinii - 90) <= katTolerancja || Math.Abs(katLinii - 270) <= katTolerancja;
        bool jestPozioma = Math.Abs(katLinii) <= katTolerancja || Math.Abs(katLinii - 180) <= katTolerancja;
        bool jestSkosna = !jestPionowa && !jestPozioma;

        Console.WriteLine($"📐 ZnajdzSasiada -> Typ linii: Pionowa={jestPionowa}, Pozioma={jestPozioma}, Skośna={jestSkosna}");

        // 🔹 Określ kierunek dla linii skośnych
        string kierunekSkosny = "";
        if (jestSkosna)
        {
            // if (katLinii > 0 && katLinii < 90) kierunekSkosny = "LEWO_GORA_PRAWO_DOL";
            // else if (katLinii > 90 && katLinii < 180) kierunekSkosny = "LEWO_DOL_PRAWO_GORA";
            // else if (katLinii > 180 && katLinii < 270) kierunekSkosny = "PRAWO_DOL_LEWO_GORA";
            // else kierunekSkosny = "PRAWO_GORA_LEWO_DOL";

            if (katLinii > 0 && katLinii < 90) kierunekSkosny = "GORA_PRAWO";
            else if (katLinii > 90 && katLinii < 180) kierunekSkosny = "PRAWO_DOL";
            else if (katLinii > 180 && katLinii < 270) kierunekSkosny = "DOL_LEWO";
            else kierunekSkosny = "LEWO_GORA";

            Console.WriteLine($"📐 ZnajdzSasiada -> Kierunek skośny: {kierunekSkosny}");
        }

        var ileModelMaSlupkowStalych = wszystkieStany.SelectMany(s => s.ListaKwadratow.FindAll(x => x.BoolElementLinia)).Count();

        Console.WriteLine($"🔍 ZnajdzSasiada -> Szukam sąsiada dla linii o kącie {kat}° w regionie {obecnyRegionId}");

        var stanyDoPrzeszukania = wszystkieStany
            .Where(s => s.WierzcholkiWartosciNominalne != null && s.Id != id)
            .OrderByDescending(s => s.Id)
            .ToList();

        foreach (var stan in stanyDoPrzeszukania)
        {
            Console.WriteLine($"🔍 ZnajdzSasiada -> Sprawdzam stan IdRegion: {stan.IdRegion}, Id: {stan.Id}");

            var wierzcholki = stan.WierzcholkiWartosciNominalne!;
            var linieStanu = ExtractLinesFromSquare(wierzcholki);

            foreach (var innaLinia in linieStanu)
            {
                if (innaLinia.Count != 2) continue;

                var q1 = innaLinia[0];
                var q2 = innaLinia[1];

                // 🔹 Obliczamy kąt sąsiada
                double dx2 = q2.X - q1.X;
                double dy2 = q2.Y - q1.Y;
                double katSasiada = Math.Atan2(dy2, dx2) * 180.0 / Math.PI;
                katSasiada = (katSasiada + 360) % 360;

                // 🔹 Normalizujemy kąty do zakresu 0-180 dla porównania (linie mają 2 kierunki)
                double katLiniiNorm = katLinii % 180;
                double katSasiadaNorm = katSasiada % 180;

                Console.WriteLine($"🔍 Porównanie: Linia={katLiniiNorm:F1}°, Sąsiad={katSasiadaNorm:F1}°");

                // 🔹 Sprawdź czy linie są równoległe (lub przeciwnie skierowane)
                bool saRownolegle = Math.Abs(katLiniiNorm - katSasiadaNorm) < 15.0 ||
                                   Math.Abs(katLiniiNorm - katSasiadaNorm - 180) < 15.0 ||
                                   Math.Abs(katLiniiNorm - katSasiadaNorm + 180) < 15.0;

                bool przecinajaSie = CzyPrzecinajaSie(p1, p2, q1, q2, tolerancja);
                bool nakladaja = CzyNakladajaSieDowolne(p1, p2, q1, q2, tolerancja, kat);

                Console.WriteLine($"🔍 Warunki: Równoległe={saRownolegle}, Przecinają={przecinajaSie}, Nakładają={nakladaja}");

                // 🔹 Logika wyboru sąsiada
                bool czyDodac = false;

                if (szukajNieRownoleglych)
                {
                    // Szukamy przecinających się (np. dla słupka stałego)
                    czyDodac = przecinajaSie && !saRownolegle;
                }
                else
                {
                    // Szukamy równoległych (standardowo)
                    czyDodac = saRownolegle && nakladaja;

                    // Dla linii skośnych rozszerzamy kryteria
                    if (jestSkosna && !saRownolegle && przecinajaSie)
                    {
                        czyDodac = true;
                    }
                }

                if (!czyDodac) continue;

                // 🔹 Znaleziono sąsiada - dodaj do listy
                var konfLista = stan.MVCKonfModelu?.KonfSystem;
                if (konfLista == null) continue;

                foreach (var konf in konfLista)
                {
                    // 🔹 Dla linii skośnych wybieramy wszystkie pasujące konfiguracje
                    if (jestSkosna)
                    {
                        pasujace.Add(new SasiadInfo
                        {
                            RowIdElementu = konf.RowId,
                            IdRegionu = stan.IdRegion,
                            ZIndeks = stan.ZIndeks,
                            MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                            Id = stan.Id,
                            WybranyTyp = konf.Typ ?? "BRAK",
                            KatSasiada = (int)katSasiada,
                            WystepujeGora = konf.WystepujeGora,
                            WystepujeDol = konf.WystepujeDol,
                            WystepujeLewa = konf.WystepujeLewa,
                            WystepujePrawa = konf.WystepujePrawa,
                            JestSkosna = true,
                            KierunekSkosny = kierunekSkosny
                        });

                        Console.WriteLine($"✅ ZnajdzSasiada -> Dodano skośnego sąsiada: {stan.IdRegion}, Kąt: {katSasiada:F1}°, Typ: {konf.Typ}");
                    }
                    else if (jestPionowa)
                    {
                        // 🔹 Dla linii pionowych sprawdź strony
                        if (Math.Abs(katLinii - 90) <= katTolerancja && konf.WystepujeLewa)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada,
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });
                        }
                        else if (Math.Abs(katLinii - 270) <= katTolerancja && konf.WystepujePrawa)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada,
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });
                        }
                    }
                    else if (jestPozioma)
                    {
                        // 🔹 Dla linii poziomych sprawdź górę/dół
                        if ((Math.Abs(katLinii) <= katTolerancja || Math.Abs(katLinii - 360) <= katTolerancja) && konf.WystepujeGora)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada,
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });
                        }
                        else if (Math.Abs(katLinii - 180) <= katTolerancja && konf.WystepujeDol)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada,
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });
                        }
                    }
                }
            }
        }

        // 🔹 Filtracja wyników
        List<SasiadInfo> wynik = pasujace.OrderBy(p => p.Id).ToList();

        // 🔹 Priorytet dla słupków stałych
        if (wynik.Count > 1 && wynik.Any(x => x.ZIndeks == 1))
        {
            var wybrany = wynik.First(x => x.ZIndeks == 1);
            wynik = new List<SasiadInfo> { wybrany };
            Console.WriteLine($"🔍 ZnajdzSasiada -> Wybrano sąsiada ze ZIndeks == 1");
        }

        // 🔹 Brak wyników - zwróć pustego sąsiada
        if (!wynik.Any())
        {
            wynik.Add(new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = Guid.Empty.ToString(),
                ZIndeks = -1,
                Id = -1,
                MaSlupekRuchomy = false,
                WybranyTyp = "BRAK-PASUJACEGO-SASIADA",
                KatSasiada = kat,
                JestSkosna = jestSkosna,
                KierunekSkosny = kierunekSkosny
            });

            if (SelectedModelType != "Rama")
            {
                if (infoObiekt == null) infoObiekt = new List<WyrobWymiaryOpis>();

                string typLinii = jestSkosna ? "skośna" : (jestPionowa ? "pionowa" : "pozioma");
                infoObiekt.Add(new WyrobWymiaryOpis(
                    constWlasciwosciOkna.Szerokosc,
                    constWlasciwosciOkna.Wysokosc,
                    SelectedModelType ?? "",
                    $"Nie wyszukano połączenia dla elementu {typLinii} w pozycji (kąt): {kat}°"));
            }
        }

        Console.WriteLine($"🔍 ZnajdzSasiada -> Znaleziono {wynik.Count} sąsiadów");

        await Task.CompletedTask;
        return wynik;
    }

    private bool CzyPunktyRowne(XPoint p1, XPoint p2, double tolerancja)
    {
        return Math.Abs(p1.X - p2.X) < tolerancja && Math.Abs(p1.Y - p2.Y) < tolerancja;
    }

    private double DlugoscWspolna(XPoint a1, XPoint a2, XPoint b1, XPoint b2)
    {
        if (Math.Abs(a1.X - a2.X) < 0.01) // pionowa
        {
            var minY1 = Math.Min(a1.Y, a2.Y);
            var maxY1 = Math.Max(a1.Y, a2.Y);
            var minY2 = Math.Min(b1.Y, b2.Y);
            var maxY2 = Math.Max(b1.Y, b2.Y);
            return Math.Max(0, Math.Min(maxY1, maxY2) - Math.Max(minY1, minY2));
        }
        else if (Math.Abs(a1.Y - a2.Y) < 0.01) // pozioma
        {
            var minX1 = Math.Min(a1.X, a2.X);
            var maxX1 = Math.Max(a1.X, a2.X);
            var minX2 = Math.Min(b1.X, b2.X);
            var maxX2 = Math.Max(b1.X, b2.X);
            return Math.Max(0, Math.Min(maxX1, maxX2) - Math.Max(minX1, minX2));
        }

        return 0;
    }

    // 🔹 Sprawdza, czy dwie linie się przecinają
    private static bool CzyPrzecinajaSie(XPoint p1, XPoint p2, XPoint q1, XPoint q2, double tolerancja)
    {
        double d1 = ObliczKierunek(q1, q2, p1);
        double d2 = ObliczKierunek(q1, q2, p2);
        double d3 = ObliczKierunek(p1, p2, q1);
        double d4 = ObliczKierunek(p1, p2, q2);

        // 🔹 Klasyczne przecięcie (krzyżowanie się)
        bool krzyzujaSie = ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                           ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0));

        if (krzyzujaSie)
            return true;

        // 🔹 Dodatkowo: traktujemy jako "przecinają się" jeśli styka się końcami
        if (Math.Abs(d1) < tolerancja && PunktNaOdcinku(p1, q1, q2, tolerancja)) return true;
        if (Math.Abs(d2) < tolerancja && PunktNaOdcinku(p2, q1, q2, tolerancja)) return true;
        if (Math.Abs(d3) < tolerancja && PunktNaOdcinku(q1, p1, p2, tolerancja)) return true;
        if (Math.Abs(d4) < tolerancja && PunktNaOdcinku(q2, p1, p2, tolerancja)) return true;

        // 🔹 Jeśli którykolwiek koniec jest "blisko" drugiego odcinka
        if (OdlegloscPunktuOdOdcinka(p1.X, p1.Y, q1.X, q1.Y, q2.X, q2.Y) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(p2.X, p2.Y, q1.X, q1.Y, q2.X, q2.Y) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(q1.X, q1.Y, p1.X, p1.Y, p2.X, p2.Y) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(q2.X, q2.Y, p1.X, p1.Y, p2.X, p2.Y) < tolerancja) return true;

        return false;
    }
    // 🔹 Pomocnicza funkcja obliczająca kierunek (iloczyn wektorowy)

    private static double ObliczKierunek(XPoint a, XPoint b, XPoint c)
    {
        return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);
    }

    // 🔹 Sprawdza, czy punkt leży na odcinku
    private static bool PunktNaOdcinku(XPoint p, XPoint a, XPoint b, double tolerancja)
    {
        return p.X <= Math.Max(a.X, b.X) + tolerancja &&
               p.X >= Math.Min(a.X, b.X) - tolerancja &&
               p.Y <= Math.Max(a.Y, b.Y) + tolerancja &&
               p.Y >= Math.Min(a.Y, b.Y) - tolerancja;
    }

    private static bool CzyNakladajaSieDowolne(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol = 0.02, float kat = 0)
    {
        // 🔹 Oblicz długości linii
        double dxA = a2.X - a1.X;
        double dyA = a2.Y - a1.Y;
        double dlugoscA = Math.Sqrt(dxA * dxA + dyA * dyA);

        double dxB = b2.X - b1.X;
        double dyB = b2.Y - b1.Y;
        double dlugoscB = Math.Sqrt(dxB * dxB + dyB * dyB);

        if (dlugoscA < 0.001 || dlugoscB < 0.001)
            return false; // linia zerowej długości

        // 🔹 Oblicz kąt między liniami
        double cosTheta = (dxA * dxB + dyA * dyB) / (dlugoscA * dlugoscB);

        // Zabezpieczenie przed błędami numerycznymi
        cosTheta = Math.Max(-1.0, Math.Min(1.0, cosTheta));

        double katMiedzy = Math.Acos(cosTheta) * 180.0 / Math.PI;

        Console.WriteLine($"🔍 CzyNakladajaSieDowolne -> Kąt linii A: {ObliczKatLinii(new List<XPoint> { a1, a2 }):F1}°, " +
                         $"Kąt linii B: {ObliczKatLinii(new List<XPoint> { b1, b2 }):F1}°, Δkat={katMiedzy:F1}°");

        // 🔹 DOPASOWANE WARUNKI DLA RÓŻNYCH TYPÓW LINII:

        // 1. LINIE PROSTE (0°, 90°, 180°, 270°) - standardowa tolerancja
        double katA = ObliczKatLinii(new List<XPoint> { a1, a2 });
        double katB = ObliczKatLinii(new List<XPoint> { b1, b2 });

        bool jestAProsta = Math.Abs(katA % 90) < 5.0; // Blisko 0, 90, 180, 270
        bool jestBProsta = Math.Abs(katB % 90) < 5.0;

        if (jestAProsta && jestBProsta)
        {
            // Dla linii prostych - tradycyjne sprawdzanie
            if (katMiedzy > 15.0 && katMiedzy < 165.0)
            {
                Console.WriteLine($"🚫 Linie proste nie są równoległe (Δkat={katMiedzy:F1}°)");
                return false;
            }

            // Reszta logiki dla linii prostych...
        }
        else
        {
            // 2. LINIE SKOŚNE - większa tolerancja kąta
            double tolerancjaKatSko = 45.0; // Dla skośnych akceptujemy większy rozrzut

            // Normalizujemy kąty do zakresu 0-180
            double katANorm = katA % 180;
            double katBNorm = katB % 180;
            double roznica = Math.Abs(katANorm - katBNorm);
            if (roznica > 90) roznica = 180 - roznica;

            Console.WriteLine($"🔍 Linia skośna A={katANorm:F1}°, B={katBNorm:F1}°, różnica={roznica:F1}°");

            if (roznica > tolerancjaKatSko)
            {
                Console.WriteLine($"🚫 Linie skośne zbyt różne (Δ={roznica:F1}° > {tolerancjaKatSko}°)");
                return false;
            }

            // Dla linii skośnych stosujemy inne kryteria nakładania
            return CzyNakladajaSieSkośne(a1, a2, b1, b2, tol);
        }

        // 🔹 Wektor kierunkowy linii A
        double ux = dxA / dlugoscA;
        double uy = dyA / dlugoscA;

        // 🔹 Rzutujemy punkty B na kierunek linii A
        double aMin = 0;
        double aMax = dlugoscA;

        double projB1 = ((b1.X - a1.X) * ux + (b1.Y - a1.Y) * uy);
        double projB2 = ((b2.X - a1.X) * ux + (b2.Y - a1.Y) * uy);
        double bMin = Math.Min(projB1, projB2);
        double bMax = Math.Max(projB1, projB2);

        // 🔹 Odległość prostopadła między liniami
        double odleglosc = Math.Abs((b1.X - a1.X) * (-uy) + (b1.Y - a1.Y) * ux);

        // Tolerancja zależna od typu linii
        double maxOdleglosc = jestAProsta ? tol * 10 : tol * 50; // Większa dla skośnych

        if (odleglosc > maxOdleglosc)
        {
            Console.WriteLine($"🚫 Odległość={odleglosc:F3} > max={maxOdleglosc:F3}");
            return false;
        }

        // 🔹 Sprawdź nakładanie projekcji
        bool nakladaja = aMax >= bMin - tol && bMax >= aMin - tol;

        // 🔹 Dodatkowe sprawdzenie dla skośnych - czy linie faktycznie się "dotykają"
        if (!jestAProsta && !nakladaja)
        {
            // Sprawdź czy końce linii są blisko siebie
            double odl1 = OdlegloscPunktuOdOdcinka(a1, b1, b2);
            double odl2 = OdlegloscPunktuOdOdcinka(a2, b1, b2);
            double odl3 = OdlegloscPunktuOdOdcinka(b1, a1, a2);
            double odl4 = OdlegloscPunktuOdOdcinka(b2, a1, a2);

            double minOdl = Math.Min(Math.Min(odl1, odl2), Math.Min(odl3, odl4));

            if (minOdl < tol * 20)
            {
                Console.WriteLine($"✅ Linie skośne stykają się w odległości {minOdl:F3}");
                nakladaja = true;
            }
        }

        Console.WriteLine($"🔍 CzyNakladajaSieDowolne -> odległość={odleglosc:F3}, nakładają={nakladaja}");
        return nakladaja;
    }

    private static bool CzyNakladajaSieSkośne(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol)
    {
        // 1. Sprawdź czy linie się przecinają
        if (CzyPrzecinajaSie(a1, a2, b1, b2, tol * 10))
        {
            Console.WriteLine($"✅ Linie skośne się przecinają");
            return true;
        }

        // 2. Sprawdź czy końce są blisko siebie
        double[] odleglosci = new double[]
        {
            OdlegloscPunktuOdOdcinka(a1, b1, b2),
            OdlegloscPunktuOdOdcinka(a2, b1, b2),
            OdlegloscPunktuOdOdcinka(b1, a1, a2),
            OdlegloscPunktuOdOdcinka(b2, a1, a2)
        };

        double minOdl = odleglosci.Min();
        Console.WriteLine($"🔍 Linie skośne - min odległość końca: {minOdl:F3}");

        // Dla linii skośnych większa tolerancja
        return minOdl < tol * 50;
    }

    private readonly struct Vector2D
    {
        public readonly double X;
        public readonly double Y;

        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }

        public double Length => Math.Sqrt(X * X + Y * Y);

        public Vector2D Normalize()
        {
            var len = Length;
            return len > 0 ? new Vector2D(X / len, Y / len) : new Vector2D(0, 0);
        }

        public static double Cross(Vector2D a, Vector2D b) => a.X * b.Y - a.Y * b.X;

        public double Dot(Vector2D other) => X * other.X + Y * other.Y;
    }


    public static List<List<XPoint>> ExtractLinesFromSquare(List<XPoint> wierzcholki)
    {
        var linie = new List<List<XPoint>>();

        if (wierzcholki == null || wierzcholki.Count < 2)
            return linie; // brak linii

        for (int i = 0; i < wierzcholki.Count; i++)
        {
            var start = wierzcholki[i];
            var end = (i == wierzcholki.Count - 1) ? wierzcholki[0] : wierzcholki[i + 1]; // zamknięcie figury

            linie.Add(new List<XPoint> { start, end });
        }

        Console.WriteLine($"ExtractLinesFromSquare -- > {(linie == null ? "null" : linie.Count)}");

        return linie;
    }

    // 🔧 Normalizacja ID – zapobiega problemom z białymi znakami, końcówkami itp.
    private string CleanId(string id)
    {
        if (string.IsNullOrWhiteSpace(id))
            return "";

        return id.Trim();
    }


    // ========================================================
    //          📌 1. ZAPIS / NADPISANIE STANU
    // ========================================================
    public void AddOrUpdateGeneratorState(string regionId, GeneratorState state, Generator generator)
    {
        regionId = CleanId(regionId);

        if (string.IsNullOrWhiteSpace(regionId))
        {
            Console.WriteLine("AddOrUpdateGeneratorState ❌ AddOrUpdateGeneratorState: regionId jest puste!");
            return;
        }

        // Ustawiamy poprawny RegionID w samym stanie
        state.IdRegion = regionId;
        state.Generator = generator;

        // Nadpisanie lub dodanie
        _generatorStates[regionId] = state;

        if (generator.Wierzcholki == null || generator.Wierzcholki.Count() == 0)
        {
            Console.WriteLine($"AddOrUpdateGeneratorState 💾 Zapisano/Nadpisano stan generatora dla regionId = '{regionId}'  -> BRAK WIERZCHOŁKÓW");
        }
        else
        {
            Console.WriteLine($"AddOrUpdateGeneratorState 💾 Zapisano/Nadpisano stan generatora dla regionId = '{regionId}'  -> {generator.Wierzcholki.Max(x => x.X)} x {generator.Wierzcholki.Max(x => x.Y)}");
        }

        Console.WriteLine($"AddOrUpdateGeneratorState 📦 Liczba stanów generatora = {_generatorStates.Count}");

        // _ = InvokeAsync(StateHasChanged);
    }


    // ========================================================
    //          📌 2. POBIERANIE STANU
    // ========================================================
    public GeneratorState? GetGeneratorState(string regionId)
    {
        regionId = CleanId(regionId);

        Console.WriteLine($"🔍 GetGeneratorState -> regionId = '{regionId}'");

        if (_generatorStates.TryGetValue(regionId, out var found))
        {
            Console.WriteLine("✅ GeneratorState znaleziony!");
            return found;
        }

        Console.WriteLine("❌ Brak GeneratorState o takim regionId!");
        return null;
    }

    // ========================================================
    //          📌 4. SPRAWDZENIE CZY ISTNIEJE
    // ========================================================
    public bool ContainsGeneratorState(string regionId)
    {
        regionId = CleanId(regionId);
        return _generatorStates.ContainsKey(regionId);
    }


    // ========================================================
    //          📌 5. POBIERANIE WSZYSTKICH
    // ========================================================
    public IReadOnlyDictionary<string, GeneratorState> GetAllGeneratorStates()
    {
        return _generatorStates;
    }

    private bool CzyPunktLezyNaKrawedzi(XPoint punkt, List<XPoint> wielokat)
    {
        const double eps = 0.001; // tolerancja błędu
        for (int i = 0; i < wielokat.Count; i++)
        {
            var a = wielokat[i];
            var b = wielokat[(i + 1) % wielokat.Count];

            double cross = (punkt.Y - a.Y) * (b.X - a.X) - (punkt.X - a.X) * (b.Y - a.Y);
            if (Math.Abs(cross) > eps) continue;

            double dot = (punkt.X - a.X) * (b.X - a.X) + (punkt.Y - a.Y) * (b.Y - a.Y);
            if (dot < 0) continue;

            double squaredLen = (b.X - a.X) * (b.X - a.X) + (b.Y - a.Y) * (b.Y - a.Y);
            if (dot > squaredLen) continue;

            return true;
        }
        return false;
    }


    private double Odleglosc(XPoint a, XPoint b)
    {
        return Math.Sqrt(Math.Pow(a.X - b.X, 2) + Math.Pow(a.Y - b.Y, 2));
    }

    private bool CzyPunktWNWielokacie(XPoint punkt, List<XPoint> wielokat)
    {
        int j = wielokat.Count - 1;
        bool inside = false;

        for (int i = 0; i < wielokat.Count; j = i++)
        {
            if (((wielokat[i].Y > punkt.Y) != (wielokat[j].Y > punkt.Y)) &&
                (punkt.X < (wielokat[j].X - wielokat[i].X) * (punkt.Y - wielokat[i].Y) / (wielokat[j].Y - wielokat[i].Y) + wielokat[i].X))
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private bool CzyLiniaPrzecinaRegion(List<XPoint> linia, List<XPoint> wielokat)
    {
        var a = linia[0];
        var b = linia[1];

        // 1. klasyczne przecięcie
        for (int i = 0; i < wielokat.Count; i++)
        {
            var c = wielokat[i];
            var d = wielokat[(i + 1) % wielokat.Count];

            if (CzyPrzecinajaSie(a, b, c, d, 0.02))
                return true;
        }

        // 2. jeden koniec linii wewnątrz regionu
        if (CzyPunktWNWielokacie(a, wielokat) || CzyPunktWNWielokacie(b, wielokat))
            return true;

        // 3. jeden koniec linii na krawędzi regionu
        if (CzyPunktLezyNaKrawedzi(a, wielokat) || CzyPunktLezyNaKrawedzi(b, wielokat))
            return true;

        return false;
    }

    private bool PunktNaOdcinku(XPoint p, XPoint a, XPoint b)
    {
        return p.X <= Math.Max(a.X, b.X) && p.X >= Math.Min(a.X, b.X) &&
               p.Y <= Math.Max(a.Y, b.Y) && p.Y >= Math.Min(a.Y, b.Y);
    }


    private double Kierunek(XPoint a, XPoint b, XPoint c)
    {
        return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);
    }


    private async Task GenerujElementyDlaRegionu(string idRegion, float szerokosc, float wysokosc)
    {
        if (!_generatorStates.TryGetValue(idRegion, out var state))
        {
            //await GenerujObrysPozZmianieWymiarow(true);

            Console.WriteLine($"❌ Brak stanu generatora dla regionu {idRegion}, żeden model nie został dodany!");
            return;
        }
        else
        {
            await GenerujObrysPozZmianieWymiarow(true);

        }

        var generator = new Generator
        {
            //KonfiguracjeSystemu = state.PowiazaneModele,
            RowIdSystemu = state.RowIdSystemu,
            MVCKonfModelu = state.MVCKonfModelu,
            TypKsztaltu = state.WybranyKsztalt,
            EdytowanyModel = state.WybranyModel,
            ElementLiniowy = state.ElementLiniowy,
        };


        var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);
        var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

        // Sprawdź, czy region skrzydła ma linię dzielącą z ruchomym słupkiem
        bool czyRegionZawieraSlupekRuchomy = _regionsSkrzydlo?.Any(x => x.TypLiniiDzielacej == "Słupek ruchomy") == true;

        bool czyRegionZawieraSlupekStaly = _regionsDualRama?.Any(x => x.TypLiniiDzielacej == "Słupek stały") == true;

        Console.WriteLine($"✅ czyRegionZawieraSlupekStaly: {czyRegionZawieraSlupekStaly}");

        if (czyRegionZawieraSlupekRuchomy)
        {
            Console.WriteLine($"✅ GenerujElementyDlaRegionu-> Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów.");

            // Sprawdź, czy istnieje "Słupek ruchomy" w jakimkolwiek PowiazanymModelu (lista)
            bool czyZawieraSlupekRuchomyWPowiazanymModelu = StateContainer.States
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfSystem != null &&
                     state.Value.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy")
                 );


            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {
                // Sprawdź, czy istnieje "Słupek ruchomy" w pojedynczym PowiazanymModelu (np. generator)
                bool czySlupekRuchomyWPojedynczymModelu = generator.MVCKonfModelu != null &&
                    generator.MVCKonfModelu.KonfSystem != null &&
                    generator.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy");

                if (!czySlupekRuchomyWPojedynczymModelu)
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj słupek ruchomy do systemu.",
                        2.0
                    );
                    return;
                }
            }
        }

        double minX = 0, maxX = 0, minY = 0, maxY = 0;

        if (wybranyRegionDualRama != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionDualRama.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 0;

            var ok = await generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);

            if (!ok)
            {
                _message.Error($"Nie można wygenerować elementów dla regionu {idRegion}. Sprawdź wymiary i kształt regionu.");
            }
        }
        else if (wybranyRegionSkrzydlo != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionSkrzydlo.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 1;

            var ok = await generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion, _generatorStates, _regionsSkrzydlo, null);

            if (!ok)
            {
                _message.Error($"Nie można wygenerować elementów dla regionu {idRegion}. Sprawdź wymiary i kształt regionu.");
            }
        }
        else
        {
            Console.WriteLine($"❌ GenerujElementyDlaRegionu-> Nie znaleziono regionu o ID {idRegion}");
            return;
        }

        // Skalowanie i przesunięcie jeśli zmieniasz szerokość/wysokość
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }

            }
        }

        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        // Console.WriteLine($"✅ Wygenerowano elementy dla regionu {idRegion} po skalowaniu.");
        await Task.CompletedTask;
    }

    private async Task RenderFrame(bool calculate = true)
    {
        try
        {
            if (_context == null || _disposed || _czekajNaZmianeRozmiaru)
                return;

            // ZAPISZ stan na początku
            await _context.SaveAsync();

            // W rysowaniu:
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            await _context.TranslateAsync(_offsetX, _offsetY);
            await _context.ScaleAsync(_aktywnaSkala, _aktywnaSkala);

            // Console.WriteLine($"RenderFrame _currentScale: {_aktywnaSkala}");

            if (ksztalty == null || !ksztalty.Any())
                return;

            // Przygotowanie tekstury
            var baseUrl = Navigation.BaseUri;
            var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

            // Rysowanie każdego kształtu
            foreach (var ksztalt in ksztalty)
            {
                //Console.WriteLine($"Rysuję kształt: {ksztalt.TypKsztaltu}");
                if (ksztalt.Wierzcholki == null || ksztalt.Wierzcholki.Count < 3)
                    continue;

                //  Console.WriteLine($"*********** >>>>>> IndeksElementu: {ksztalt.IndeksElementu} Grupa: {ksztalt.Grupa} DlogoscElementu: {ksztalt.DlogoscElementu}");

                await DrawShapeWithVariableOffset(_context, ksztalt, imageUrl, calculate);
                await DrawSingleContourTextOnly(_context, ksztalt.Wierzcholki, $"{ksztalt.IndeksElementu.ToString()} [{ksztalt.Kat.ToString()}/{ksztalt.Strona}]", (ksztalt.Kat == 180 ? 0 : ksztalt.Kat)); // Tekst z ID i kątem na profilu
            }

            await _context.RestoreAsync();

            // await _context.SaveAsync();

            // await Task.Delay(50); // Krótkie opóźnienie dla płynności

            // StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd renderowania: {ex.Message}\n{ex.StackTrace}");
        }
    }

    private async Task DrawShapeWithVariableOffset(Canvas2DContext context, KsztaltElementu ksztalt, string textureUrl, bool calculate)
    {
        try
        {
            var outerPoints = ksztalt.Wierzcholki;
            var offsets = GetOffsetsForGroup(ksztalt.Grupa);

            await DrawSingleContour(context, outerPoints);

            // Sprawdź, czy _dotNetHelper nie jest null i czy komponent nie został usunięty
            if (_dotNetHelper != null && !_disposed)
            {
                try
                {
                    await JS.InvokeVoidAsync("loadAndDrawTexture",
                        CanvasRef.CanvasReference,
                        textureUrl,
                        _dotNetHelper
                    );
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ Błąd podczas ładowania tekstury: {ex.Message}");
                    // Możesz tutaj podjąć decyzję, czy chcesz kontynuować bez tekstury, czy coś innego
                }
            }

            await context.SetStrokeStyleAsync("#000000");
            await context.SetLineWidthAsync(1.5f);
            await context.StrokeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd w DrawShapeWithVariableOffset: {ex.Message}");
        }
    }


    private (float left, float right, float top, float bottom) GetOffsetsForGroup(string grupa)
    {
        // Domyślne wartości (można dostosować)
        float grLewo = 82;
        float grPrawo = 82;
        float grGora = 82;
        float grDol = 92;

        return grupa switch
        {
            "Lewo" => (grLewo, 0, 0, 0),
            "Prawo" => (0, grPrawo, 0, 0),
            "Gora" => (0, 0, grGora, 0),
            "Dol" => (0, 0, 0, grDol),
            _ => (grLewo, grPrawo, grGora, grDol) // Domyślne dla innych przypadków
        };
    }

    private async Task DrawSingleContour(Canvas2DContext context, List<XPoint> outerPoints)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Rysuj pojedynczy kontur zewnętrzny
        await context.BeginPathAsync();

        // Rozpocznij od pierwszego punktu
        await context.MoveToAsync(outerPoints[0].X, outerPoints[0].Y);

        // Rysuj linie do kolejnych punktów
        for (int i = 1; i < outerPoints.Count; i++)
        {
            await context.LineToAsync(outerPoints[i].X, outerPoints[i].Y);
        }

        // Zamknij kształt
        await context.ClosePathAsync();

        // Opcjonalne stylowanie
        await context.SetStrokeStyleAsync("black");
        await context.SetLineWidthAsync(2);
        await context.StrokeAsync();
    }

    private async Task DrawSingleContourTextOnly(
    Canvas2DContext context,
    List<XPoint> outerPoints,
    string tekst,
    float kat // w stopniach
    )
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Środek figury
        double centerX = outerPoints.Average(p => p.X);
        double centerY = outerPoints.Average(p => p.Y);

        // Stopnie -> radiany
        double angleRad = kat * Math.PI / 180.0;

        // Rysowanie tekstu
        await context.SaveAsync();
        await context.SetFontAsync("30px Arial");
        await context.SetFillStyleAsync("black");
        await context.SetTextAlignAsync(TextAlign.Center);
        await context.SetTextBaselineAsync(TextBaseline.Middle);

        // Przenieś układ współrzędnych do środka
        await context.TranslateAsync(centerX, centerY);

        // Obróć o zadany kąt
        await context.RotateAsync((float)angleRad);

        // Rysuj w (0,0) — bo środek już jest przestawiony
        await context.FillTextAsync(tekst, 0, 0);

        await context.RestoreAsync();
    }



    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task GoCAD()
    {
        Console.WriteLine("GoCAD START");

        await JS.InvokeVoidAsync("ResetCursorGlobal");

        // Console.WriteLine("JS done");

        if (ShapeService != null)
        {
            ShapeService._szerokosc = constWlasciwosciOkna.Szerokosc;
            ShapeService._wysokosc = constWlasciwosciOkna.Wysokosc;
        }

        Console.WriteLine("GoCAD Próba nawigacji → /DrawCAD");

        //_shapes.Clear();

        NavigationManager.NavigateTo("/DrawCAD");

        Console.WriteLine("GoCAD END");
    }


    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                //Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------

    public class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }

        public double ScaleX { get; set; }
        public double ScaleY { get; set; }
    }

    private class PointClassification
    {
        public bool IsLeft { get; set; }
        public bool IsRight { get; set; }
        public bool IsTop { get; set; }
        public bool IsBottom { get; set; }
    }

    public class DraggedModelInfo
    {
        public string? Type { get; set; }
        public string? RowId { get; set; }
    }

    private class DomSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    public class SasiadInfo
    {
        public Guid RowIdElementu { get; set; }// RowId elementu sąsiada równoległego
        public string? IdRegionu { get; set; }
        public int ZIndeks { get; set; }
        public bool MaSlupekRuchomy { get; set; }
        public int Id { get; set; }
        public string? WybranyTyp { get; set; }
        public float KatSasiada { get; set; }
        public bool WystepujeDol { get; set; } = false;
        public bool WystepujeLewa { get; set; } = false;
        public bool WystepujeGora { get; set; } = false;
        public bool WystepujePrawa { get; set; } = false;

        public bool JestSkosna { get; set; }
        public string KierunekSkosny { get; set; } = "";
    }

    public class PrzesuniecieDto
    {
        public double PrzesuniecieX { get; set; }
        public double PrzesuniecieY { get; set; }
    }

    public class SlupekMatchResult
    {
        public List<XPoint> Wierzcholki { get; set; } = new();
        public List<string> RegionIds { get; set; } = new();
    }

}
