@page "/Modele-okienne"
@using AntDesign
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@using GEORGE.Shared.ViewModels;
@using GEORGE.Client.Pages.Utils
@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@using System.Globalization
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation
@inject NavigationManager NavigationManager
@inject ShapeTransferService ShapeService

@using System.IO;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.Formats.Png;

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using GEORGE.Client.Pages.Models
@using GEORGE.Client.Pages.Okna

@inject GeneratorStateContainer StateContainer

@implements IDisposable
@implements IAsyncDisposable

<style>
    /* Globalne ustawienia */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
    }

    /* Specjalna klasa dla resetu */
    .cursor-reset * {
        cursor: default !important;
        pointer-events: auto !important;
    }

    /* Kontener główny */
    .window-model-container {
        display: flex;
        height: 70vh;
        background-color: #fff;
        padding: 10px;
        box-sizing: border-box;
    }

    /* Panel boczny z modelami */
    .wing-model-container {
        flex: 0 0 250px; /* Szerokość panelu bocznego */
        height: 100%;
        overflow-y: auto;
        border-right: 2px solid #ddd;
        padding: 10px;
        background: #f8f9fa;
    }

        /* Tabela modeli */
        .wing-model-container table {
            font-size: 13px;
            width: 100%;
            border-collapse: collapse;
        }

        .wing-model-container th, .wing-model-container td {
            padding: 6px;
            text-align: center;
        }

        .wing-model-container th {
            background-color: #007bff;
            color: white;
        }

        .wing-model-container tr:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        /* Miniatury modeli */
        .wing-model-container img {
            width: 45px;
            height: 45px;
            object-fit: contain;
            cursor: -webkit-grab; /* Obsługa w Safari */
            cursor: grab;
            transition: transform 0.2s ease-in-out;
        }

            .wing-model-container img:hover {
                transform: scale(1.1);
            }

    /* Główne okno wyświetlania */
    .display-window {
        flex-grow: 1;
        height: 100%;
        min-height: 400px; /* Zapewnienie minimalnej wysokości */
        border: 2px solid #ddd;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        position: relative;
        overflow: hidden;
        cursor: crosshair;
    }

    .container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .canvas-container {
        width: @(CanvasWidth + "px");
        height: @(CanvasHeight + "px");
        pointer-events: none; /* Wyłącz interakcje z canvasem */
        max-width: 100%;
        max-height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ukrywa przewijanie */
        position: relative;
    }

    canvas {
        pointer-events: none; /* Kontynuuj ignorowanie zdarzeń */
        display: block;
        max-width: 100%;
        max-height: 100%;
        background-color: transparent;
    }

    .interactive-layer {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2; /* Warstwa NAD canvasem */
        pointer-events: auto; /* Włącz interakcje */
    }
    /* Paski przewijania */
    .wing-model-container::-webkit-scrollbar {
        width: 8px;
    }

    .wing-model-container::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 5px;
    }

        .wing-model-container::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }

    /* 🔹 Toolbar z przyciskami */
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        justify-content: center;
        padding: 10px;
        background: #fff;
    }

        /* Styl dla przycisków */
        .toolbar .btn {
            flex: 1;
            min-width: 90px;
            font-size: 13px;
            padding: 6px 8px;
            transition: all 0.2s ease-in-out;
        }

            .toolbar .btn:hover {
                transform: scale(1.05);
            }

    .zoom-controls {
        position: absolute;
        top: 170px; /* Ustawienie 10px od góry */
        right: 10px; /* Ustawienie 10px od prawej */
        display: flex;
        gap: 10px; /* Odstęp między przyciskami */
        z-index: 1000; /* Upewnia się, że są na wierzchu */
    }

    .btn-zoom {
        width: 40px;
        height: 40px;
        font-size: 20px;
        border-radius: 50%; /* Okrągłe przyciski */
        border: none;
        background-color: #007bff; /* Niebieski, możesz zmienić */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Delikatny cień */
        transition: background-color 0.3s ease;
    }

        .btn-zoom:hover {
            background-color: #0056b3; /* Ciemniejszy niebieski przy najechaniu */
        }

    /* Panel zajmuje pełną szerokość */
    .scrollable-panel {
        width: 100%;
        max-height: 400px; /* Możesz zmienić na więcej, np. 600px */
        overflow-y: auto; /* Włącza przewijanie w pionie */
    }

    /* Sider zajmuje całą szerokość */
    .info-panel {
        background-color: #222;
        color: #ffeb99;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
        width: 500px; /* Pełna szerokość */
        max-width: 1000px;
    }

    /* Lista informacji */
    .info-list {
        list-style: none;
        padding: 0;
        width: 760px;
    }

    /* Każdy element ma własne miejsce */
    .info-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 760px;
    }

        /* Tekst jasnożółty */
        .info-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .info-item strong {
            color: #ffcc00;
        }

    /* Obsługa braku danych */
    .no-data {
        color: red;
        text-align: center;
        font-style: italic;
    }

    /* Lista materiałów */
    .materials-list {
        list-style: none;
        padding: 0;
        width: 100%;
    }

    /* Pojedynczy materiał */
    .material-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
    }

        /* Kolor jasny dla tekstu */
        .material-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .material-item strong {
            color: #ffcc00;
        }
</style>

<!-- Nagłówek Skypty są zapisane w pliku \JS\canvasHelpers.js i podpięte w index.html-->

<div class="d-flex justify-content-between align-items-center mt-2 mb-2">
    <h3 class="mb-0">Modele Okienne &nbsp;</h3>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoCAD">
        OKN-CAD
    </Button>
    &nbsp;&nbsp;
    <button class="btn btn-primary" @onclick="GoBack">
        <i class="fas fa-arrow-left"></i> Wróć do poprzednej strony
    </button>

</div>

<Collapse Animation>

    <Panel Header="Informacja o wyrobie restrykcje" Key="2" class="scrollable-panel">
        <Sider class="info-panel">
            <h4 style="color:aquamarine;">🛠️ Informacja o wyrobie:</h4>

            @if (infoObiekt != null && infoObiekt.Any())
            {
                <p class="entries-count"> 📌 Liczba wpisów: <strong>@infoObiekt.Count()</strong></p>
                <ul class="info-list">
                    @foreach (var wymiar in infoObiekt)
                    {
                        <li class="info-item">
                            <span><strong>📏 Szerokość:</strong> @wymiar.Szerokosc mm</span>
                            <span><strong>📐 Wysokość:</strong> @wymiar.Wysokosc mm</span>
                            <span><strong>🏗️ Wyrób:</strong> @wymiar.RodzajObiektu</span>
                            <span><strong>⚠️ Restrykcje:</strong> @wymiar.Restrykcja</span>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p class="no-data">❌ Brak danych o wyrobie.</p>
            }
        </Sider>
    </Panel>
    <Panel Header="Materiały" Key="3" class="scrollable-panel">
        @if (infoBoom != null && infoBoom.Any())
        {
            <p class="entries-count">📌 Liczba materiałów: <strong>@infoBoom.Count()</strong></p>
            <ul class="materials-list">
                @foreach (var material in infoBoom)
                {
                    <li class="material-item">
                        <span><strong>📏 Długość:</strong> @material.Dlugosc mm</span>
                        <span><strong>🏷️ Nazwa:</strong> @material.Nazwa</span>
                        <span><strong title="@material.RowIdIndeksu">🔢 Indeks:</strong> @material.Indeks</span>
                        <span><strong>📦 Ilość sztuk:</strong> @material.IloscSztuk</span>
                        <span><strong>⚠️ Restrykcje:</strong> @material.Restrykcja</span>
                    </li>
                }
            </ul>
        }
        else
        {
            <p class="no-data">❌ Brak użytych materiałów.</p>
        }
    </Panel>

</Collapse>


<!-- Kontener na modele i canvas -->
<div class="window-model-container">
    <!-- Kontener na przyciski -->
    <div class="zoom-controls">
        <label>@mousePosition skala: @((int)(_currentScale * 100))</label>
        <button @onclick="PokazWlasciwosciOkna" class="btn-zoom">📖</button>
        <button @onclick="UsunOstatniObiekt" class="btn-zoom">🗑️</button>
        <button @onclick="ZoomIn" class="btn-zoom">➕</button>
        <button @onclick="ZoomOut" class="btn-zoom">➖</button>
        <button @onclick="PokazModal" class="btn-zoom">💎</button>
        <button class="btn btn-zoom" @onclick="OtworzPrzeglad">🔍</button>
    </div>
    <!-- Panel boczny z modelami -->
    <div class="wing-model-container">
        <!-- 🔹 Wybór systemu -->
        <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
            <div class="d-flex">
                @if (Systemy != null && Systemy.Any())
                {
                    <select class="form-select me-2" style="width:100%" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                }
            </div>
        </Tooltip>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Typ</th>
                    <th>Wymiary</th>
                    <th>Miniaturka</th>
                </tr>
            </thead>
            <tbody>
                @if (ListaModeli != null)
                {
                    @foreach (var model in ListaModeli)
                    {
                        <tr>
                            <td>@model.Typ</td>
                            <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                            <td>
                                @if (model.Rysunek != null && model.Ikona32x32.Length > 0)
                                {
                                    <img id="@($"wing-{model.Typ}")"
                                         src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                         @onclick='@(() => WybierzModel(model))'
                                         @ondragstart='@(e => JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId))'
                                         @onmouseout='@(e => JS.InvokeVoidAsync("ResetCursor"))'
                                         draggable="true"
                                         style="cursor: grab;
                                         width: auto;
                                         height: auto;
                                         max-width: 50px;
                                         max-height: 50px;
                                         border: @(model == WybranyModel ? "4px solid #007bff" : "none")" />

                                }
                                else
                                {
                                    <span class="text-muted">Brak</span>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <!-- Główne okno wyświetlania -->
    <div class="display-window" @onmouseup="OnMouseUp" @onmousemove="OnMouseMove"
         style="position: relative; /* Wymagane dla warstw */
            overflow: visible; /* Zapobiega przycinaniu kursora */
            cursor: inherit; /* Dziedziczy kursor z JS */">

        <!-- Tutaj elementy reagujące na kursor (np. przyciski) -->
        @if (hasCanvasError)
        {
            <p style="color: red; position: relative; z-index: 100;">❌ Błąd: Nie udało się załadować canvasu!</p>
        }
        else
        {
            <!-- Canvas -->
            <div class="canvas-container" style="padding:0px;background-color: transparent;border: 0px;">
                <BECanvas @ref="CanvasRef" Width="@CanvasWidth" Height="@CanvasHeight" />
            </div>
        }
    </div>

</div>

<div class="modal fade @classShowTWZ" tabindex="-1"
     style="display: @displayTWZ; margin: auto; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; width: 80%;">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Punkty elementów okien</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal"></button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto; font-size: 0.85rem; font-family: Consolas, monospace;">
                @if (ksztalty is not null && ksztalty.Any())
                {

                    @foreach (var ksztalt in ksztalty)
                    {
                        <div class="card my-2 shadow-sm">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>Typ:</strong> @ksztalt.TypKsztaltu &nbsp;|&nbsp;
                                    <strong>Grupa:</strong> @ksztalt.Grupa &nbsp;|&nbsp;
                                    <strong>ZIndex:</strong> @ksztalt.ZIndex &nbsp;|&nbsp;
                                    <strong>RowIdElementu:</strong> @ksztalt.RowIdElementu
                                    <strong>Kąt:</strong> @ksztalt.Kat [@ksztalt.Strona]
                                    <br />
                                    <strong>IdRegion:</strong> @ksztalt.IdRegion
                                </div>
                                <button class="btn btn-sm btn-primary" @onclick="@(() => EdytujKsztalt(ksztalt.Id))">Edytuj</button>
                            </div>
                            <div class="card-body">
                                @if (edytowanyId == ksztalt.Id)
                                {
                                    <div class="mb-2">
                                        <label>Typ kształtu</label>
                                        <input class="form-control" @bind="ksztalt.TypKsztaltu" />
                                    </div>
                                    <!-- Pozostałe inputy jak wcześniej... -->

                                    <div class="mb-2">
                                        <label><strong>Wierzchołki (X, Y):</strong></label>
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var punkt = ksztalt.Wierzcholki[i];
                                            var lokalnyIndex = i;  // 👈 to jest klucz

                                            <div class="d-flex align-items-center mb-1" @key="punkt">
                                                <span class="me-2">[@lokalnyIndex]</span>
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                       @oninput="@(e => ZmienX(ksztalt, lokalnyIndex, e))" placeholder="X" />
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                       @oninput="@(e => ZmienY(ksztalt, lokalnyIndex, e))" placeholder="Y" />
                                            </div>
                                        }
                                    </div>

                                    <button class="btn btn-success btn-sm" @onclick="@ZapiszKsztalt">Zapisz</button>
                                    <button class="btn btn-secondary btn-sm ms-2" @onclick="@AnulujEdycje">Anuluj</button>
                                }
                                else
                                {
                                    <p><strong>Wypełnienie wewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieWewnetrzne">@ksztalt.WypelnienieWewnetrzne</span></p>
                                    <p><strong>Wypełnienie zewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieZewnetrzne">@ksztalt.WypelnienieZewnetrzne</span></p>
                                    <p><strong>Grubość obramowania:</strong> @ksztalt.GruboscObramowania px</p>
                                    <p><strong>Czy zawiera otwór:</strong> @(ksztalt.CzyZawieraOtwor ? "Tak" : "Nie")</p>
                                    <p><strong>Widoczny:</strong> @(ksztalt.Widoczny ? "Tak" : "Nie")</p>
                                    <p><strong>Długość: @ksztalt.DlogoscElementu</strong></p>
                                    <p><strong>Kąt: @ksztalt.Kat</strong></p>
                                    <p><strong>Wierzchołki:</strong></p>

                                    <ul class="list-group list-group-flush">
                                        @foreach (var p in ksztalt.Wierzcholki)
                                        {
                                            <li class="list-group-item">
                                                X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                            </li>
                                        }
                                    </ul>
                                }
                            </div>
                        </div>
                    }

                    <hr>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @constWlasciwosciOkna.Szerokosc x @constWlasciwosciOkna.Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>

                }
                else
                {
                    <p class="text-muted">Brak danych do wyświetlenia 😔 nie wygenerowano okien</p>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @constWlasciwosciOkna.Szerokosc x @constWlasciwosciOkna.Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @p.X, Y: @p.Y
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>
                }
            </div>
        </div>
    </div>
</div>

<Modal Title="Podgląd danych wygenerowanych "
       Visible="@_generatorState"
       OnOk="@HandleCancel"
       OnCancel="@HandleCancel"
       Maximizable="@true"
       Centered="@true"
       DefaultMaximized="@true">
    <Generator_state_viewer StateContainer="StateContainer"></Generator_state_viewer>
</Modal>

<Modal Title="Podgląd danych wygenerowanych"
       Visible="@_constWlasciwosciOkna"
       OnOk="@HandleZapis"
       OnCancel="@HandleWOCancel"
       Width="@("50%")"
       Centered="true"
       Maximizable="true">

    <ZmienWymiaryOkna Model="constWlasciwosciOkna"
                      OnSave="PrzyjmijZmiany">
    </ZmienWymiaryOkna>

</Modal>


@code {

    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private KonfModele? WybranyModel { get; set; }

    private string WybranyKsztalt = "prostokat";

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef; // Referencja do komponentu BECanvas
    private Canvas2DContext? _context;
    private DotNetObjectReference<Modele_okienne>? _dotNetHelper;

    // Dodaj nowe pola w sekcji @code
    private string? SelectedModelType { get; set; }
    private string? SelectedRowIdType { get; set; }
    // private double DropX { get; set; }
    // private double DropY { get; set; }
    private ElementReference canvasElement;

    private double _currentScale = 1.0;
    private const double ScaleFactor = 1.1;
    private double _panX = 0;
    private double _panY = 0;

    private long CanvasWidth { get; set; } = 900;
    private long CanvasHeight { get; set; } = 600;

    private double _zoomCenterX = 450; // Środek canvasu
    private double _zoomCenterY = 300;

    private List<WyrobWymiaryOpis>? infoObiekt;

    private List<WygenerowaneMaterialy> infoBoom = new List<WygenerowaneMaterialy>();

    private List<IShapeDC> _shapes = new List<IShapeDC>();

    private List<ShapeRegion> _regionsDualRama = new();
    private List<ShapeRegion> _regionsSkrzydlo = new();

    private double _offsetX = 0;
    private double _offsetY = 0;


    private string woodPatternName = "sosna.jpg"; // Nazwa pliku do wzoru drewna meranti.jpg wood.jpg

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private string classShowTWZ = "";
    private string displayTWZ = "none";
    private string edytowanyId = "";

    private string classShowWO = "";
    private string displayWO = "none";

    private string edytowanyIdshape = "";

    private string mousePosition = "X: 0, Y: 0";

    private string? edytowanyRegionId;

    private Dictionary<string, List<KsztaltElementu>> _ksztaltyNaRegion = new();
    private List<KsztaltElementu> ksztalty = new();

    private Dictionary<string, GeneratorState> _generatorStates = new();
    private readonly Dictionary<string, Generator> _generatory = new();

    private ConstWlasciwosciOkna? constWlasciwosciOkna = new ConstWlasciwosciOkna();
    private ZmienWymiaryOkna? zmienWymiaryOknaRef = new ZmienWymiaryOkna();

    private bool _generatorState = false;
    private bool _constWlasciwosciOkna = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            if(constWlasciwosciOkna == null)
                constWlasciwosciOkna = new ConstWlasciwosciOkna();

            // constWlasciwosciOkna.Szerokosc = 1000;
            // constWlasciwosciOkna.Wysokosc = 1000;

            Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

            // if (_dotNetHelper == null)
            // {
            //     _dotNetHelper = DotNetObjectReference.Create(this);
            //     //   await Task.Delay(25); // Krótkie opóźnienie dla płynności
            //     await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
            //     // await Task.Delay(25); // Krótkie opóźnienie dla płynności
            //     //Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
            // }

            // Sprawdź, czy skrypt JS został poprawnie załadowany
            var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
            if (!isScriptLoaded)
            {
                throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");

                // await JS.InvokeVoidAsync("AddCanvasHoverListener", CanvasRef);

            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas inicjalizacji: {ex.Message}");
        }

        await Laduj_Uprawnienia();
    }

    private bool _disposed = false;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {

            if (firstRender && CanvasRef != null && !_disposed)
            {
                Console.WriteLine("🖌️ Inicjalizacja canvasu...");

                if (_dotNetHelper == null)
                {
                    _dotNetHelper = DotNetObjectReference.Create(this);
                    //   await Task.Delay(25); // Krótkie opóźnienie dla płynności
                    await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
                    // await Task.Delay(25); // Krótkie opóźnienie dla płynności
                    //Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
                }

                var isFunctionDefined = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
                if (!isFunctionDefined)
                    throw new Exception("⚠️ Funkcja setCanvasRef nie jest zdefiniowana!");


                await JS.InvokeVoidAsync("setCanvasRef", CanvasRef.CanvasReference);

                Console.WriteLine("✅ Canvas ustawiony!");

                await Task.Delay(50); // Krótkie opóźnienie dla płynności

                await GenerujObrysPozZmianieWymiarow(true);

                // 👇 TU DODAJ
                _context ??= await CanvasRef.CreateCanvas2DAsync();

                await JS.InvokeVoidAsync("registerResizeCallback", DotNetObjectReference.Create(this));

            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Krytyczny błąd: {ex.Message}");
            hasCanvasError = true;
            StateHasChanged();
        }
    }

    private async Task GenerujObrysPozZmianieWymiarow(bool onApplyZoom)
    {
        _shapes.Clear();

        _shapes = ShapeService.Shapes;

        if (_shapes != null && _shapes.Count > 0)
        {
            if (_shapes.Any(s => s == null))
            {
                Console.WriteLine("⚠️ GenerujObrysPozZmianieWymiarow --> Niektóre kształty w _shapes są null");
            }
            else
            {
                if (_shapes[0].GetType() == typeof(GEORGE.Client.Pages.Models.XSquareShape))
                {
                    Console.WriteLine("✅ GenerujObrysPozZmianieWymiarow --> Kształty są typu KsztaltElementu");
                    constWlasciwosciOkna.Wysokosc = constWlasciwosciOkna.Szerokosc;
                }
            }
        }

        Console.WriteLine($"🔄 GenerujObrysPozZmianieWymiarow --> Odebrano dane _shapes: {_shapes?.Count()}");

        if (_shapes != null && _shapes.Count() > 0 && constWlasciwosciOkna != null)
        {

            Console.WriteLine($"🔄 GenerujObrysPozZmianieWymiarow --> Przetwarzanie kształtów dla wymiarów: Szerokosc={constWlasciwosciOkna.Szerokosc} - {_shapes.Max(x => x.Szerokosc)}, Wysokosc={constWlasciwosciOkna.Wysokosc} - {_shapes.Max(x => x.Wysokosc)}");

            // double maxWysokosc = _shapes.Max(s => s.Wysokosc);
            // double maxSzerokosc = _shapes.Max(s => s.Szerokosc);

            // if (nowyObrys)
            // {
            //     constWlasciwosciOkna.Wysokosc = (int)maxWysokosc;
            //     constWlasciwosciOkna.Szerokosc = (int)maxSzerokosc;
            // }

            // Generuj regiony po transformacji
            //  _regions = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)CanvasWidth, (int)CanvasHeight);

            _regionsDualRama = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)constWlasciwosciOkna.Szerokosc, (int)constWlasciwosciOkna.Wysokosc, true);
            _regionsSkrzydlo = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)constWlasciwosciOkna.Szerokosc, (int)constWlasciwosciOkna.Wysokosc, false); // ostatni parametr nie wiem czy potrzeby do sprawdzenia (czy rama true/falsa)

            foreach (var rds in _regionsSkrzydlo)
            {
                var center = GeometryUtils.ObliczCentroid(rds.Wierzcholki);

                foreach (var rdr in _regionsDualRama)
                {
                    if (GeometryUtils.CzyPunktWielokacie(center, rdr.Wierzcholki))
                    {
                        rds.IdRegionuPonizej = rdr.Id;
                        // Console.WriteLine($"🔗 Region skrzydła {rds.Id} przypisany do regionu ramy {rdr.Id}");
                        break; // Przypisz tylko pierwszą pasującą ramę
                    }
                }
            }

            // 2. Oblicz skalę z zachowaniem proporcji tak, by dopasować do docelowych wymiarów
            double scaleX = constWlasciwosciOkna.Szerokosc / CanvasWidth;
            double scaleY = constWlasciwosciOkna.Wysokosc / CanvasHeight;
            double scale = Math.Min(scaleX, scaleY) / 2;

            scale = scale * 0.9;

            double minX = 0;
            double minY = 0;
            double maxX = constWlasciwosciOkna.Szerokosc;
            double maxY = constWlasciwosciOkna.Wysokosc;

            double contentWidth = maxX - minX;
            double contentHeight = maxY - minY;

            double centerX = CanvasWidth / 2;
            double centerY = CanvasHeight / 2;

            double contentCenterX = (minX + maxX) / 2;
            double contentCenterY = (minY + maxY) / 2;

            _panX = centerX - contentCenterX * scale;
            _panY = centerY - contentCenterY * scale;

            Console.WriteLine($"🔍 OnInitializedAsync --> Przeskalowano kształty: skala={scale} CanvasWidth: {CanvasWidth} CanvasHeight: {CanvasHeight}");

            if (onApplyZoom) await ApplyZoom(scale);

            Console.WriteLine($"Odebrano dane _shapes: {_shapes.Count()}");

            //_context = null;
            // await RedrawCanvas();

        }
        else
        {
            Console.WriteLine($"Odebrano dane _shapes: null");
        }

        // await Task.Delay(50);
    }

    private void WybierzModel(KonfModele model)
    {
        WybranyModel = model;
        // Dodatkowe akcje przy wyborze modelu
        JS.InvokeVoidAsync("SetCustomCursor", Convert.ToBase64String(model.Ikona32x32));
        JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId);
    }

    private void ZmienX(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienX wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newX))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.X = newX;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newX}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienX: {ex.Message}");
        }
    }

    private void ZmienY(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienY wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newY))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.Y = newY;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienY: indeks {index}, nowa wartość Y: {newY}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienY: {ex.Message}");
        }
    }


    private async Task EdytujKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null && !_disposed)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        edytowanyId = id;
        Console.WriteLine($"edytowanyId: {edytowanyId}");
    }

    private async Task ZapiszKsztalt()
    {
        // Nie zmieniaj listy ksztalty – dane są już w niej zaktualizowane przez binding
        edytowanyId = "";
        await RenderFrame(false);
    }


    private void AnulujEdycje()
    {
        edytowanyId = "";
    }

    private void ZmienXRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var x))
        {
            var punkt = region.Wierzcholki[index];
            punkt.X = x;// / _currentScale;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private void ZmienYRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var y))
        {
            var punkt = region.Wierzcholki[index];
            punkt.Y = y;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private async Task ZapiszRegion()
    {
        edytowanyRegionId = null;
        //StateHasChanged(); // aby odświeżyć widok
    }


    private async Task PokazWlasciwosciOkna()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowWO = "show";
        displayWO = "block";
        await Task.Delay(50); // Krótkie opóźnienie dla płynności
        _constWlasciwosciOkna = true;
    }

    private void ZamknijWlasciwosciOkn()
    {
        classShowWO = "";
        displayWO = "none";
    }

    private void ZamknijModal()
    {
        classShowTWZ = "";
        displayTWZ = "none";
    }

    private async Task PokazModal()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowTWZ = "show";
        displayTWZ = "block";
    }

    private async Task OtworzPrzeglad()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        StateContainer.States = _generatorStates;

        if (_generatorStates.Count == 0)
        {
            await _message.Warning("Brak zapisanych stanów generatora.", 1.5);
            return;
        }

        await Task.Delay(50); // Krótkie opóźnienie dla płynności

        _generatorState = true;

    }

    private void HandleCancel(MouseEventArgs e)
    {
        _generatorState = false;
    }

    private void HandleWOCancel(MouseEventArgs e)
    {
        _constWlasciwosciOkna = false;
    }

    private async Task HandleZapis()
    {
        // Wywołanie zapisu w komponencie ZmienWymiaryOkna
        if(zmienWymiaryOknaRef == null) return;

        await zmienWymiaryOknaRef.ZapiszDoRodzica();

        _constWlasciwosciOkna = false; // zamknie modal
        await Task.Delay(50); // Krótkie opóźnienie dla płynności
        await ZmienWymiaryOkna();

    }
    // Odbiór zmienionych danych z dziecka
    private void PrzyjmijZmiany(ConstWlasciwosciOkna zmieniony)
    {
        constWlasciwosciOkna = zmieniony;
        Console.WriteLine("Zmieniono wymiary!");
        StateHasChanged();
    }

    [JSInvokable("UpdateCanvasSizeFromResize")]
    public async Task UpdateCanvasSizeFromResize()
    {
        if (_context == null || _disposed)
        {
            Console.WriteLine("❌ Brak kontekstu canvas");
            return;
        }

        await ApplyZoom(_currentScale);
    }

    private async Task ClearCanvas()
    {
        if (_context == null || !await JS.InvokeAsync<bool>("isCanvasValid"))
        {
            Console.WriteLine("❌ Brak kontekstu canvas (invalid or disposed)");
            return;
        }

        try
        {
            // Reset transformacji, aby czyścić w skali 1:1
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);

            // Wyczyść cały canvas
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Opcjonalnie białe tło
            await _context.SetFillStyleAsync("white");
            await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

            //await Task.Delay(50); // Krótkie opóźnienie dla płynności

            await _context.RestoreAsync();

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("❌ ClearCanvas błąd: " + ex.Message);
        }
    }


    private async Task UsunOstatniObiekt()
    {
        if (_generatorStates.Count == 0)
            return;

        var ostatni = _generatorStates.Keys.LastOrDefault();
        if (string.IsNullOrWhiteSpace(ostatni))
            return;

        if (_generatorStates.TryGetValue(ostatni, out var state) &&
            _generatory.TryGetValue(state.IdRegion, out var generator))
        {
            UsunOstatniKsztaltZGeneratora(state.IdRegion, generator);

            _generatorStates.Remove(ostatni);
            _generatory.Remove(state.IdRegion);

            _ksztaltyNaRegion.Remove(state.IdRegion);
            ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
        }


        await ClearCanvas();
        isTextureLoaded = false;

        await Task.Delay(100);
        // await RedrawCanvas();
        await DrawStructureAndRestrykcje();
        await ApplyZoom(_currentScale);

        StateHasChanged();
    }


    private async Task ZoomIn()
    {
        var newScale = _currentScale * 1.2;
        await ApplyZoom(newScale);
    }

    private async Task ZoomOut()
    {
        var newScale = _currentScale / 1.2;
        await ApplyZoom(Math.Max(newScale, 0.12));
    }

    private async Task ApplyZoom(double newScale)
    {

        if (CanvasWidth == 0 || CanvasHeight == 0)
            return;

        // 📌 Środek canvasu jako punkt odniesienia do zoomu
        _zoomCenterX = CanvasWidth / 2.0;
        _zoomCenterY = CanvasHeight / 2.0;

        Console.WriteLine($"🔍 ZOOM: nowa skala = {newScale:F2}, aktualna skala = {_currentScale:F2}");

        var ratio = 1 - (newScale / _currentScale);
        _panX += (_zoomCenterX - _panX) * ratio;
        _panY += (_zoomCenterY - _panY) * ratio;

        _currentScale = newScale;

        if (_context == null)
        {
            Console.WriteLine("♻️ Odtwarzam kontekst Canvas po zmianie DOM.");
            _context ??= await CanvasRef.CreateCanvas2DAsync();
        }

        // Rysuj wszystkie kształty w przeskalowanym kontekście
        if (_context != null && _shapes != null)
        {
            isTextureLoaded = false;

            await ClearCanvas();
            await DrawStructureAndRestrykcje();
            await RenderFrame();

            foreach (var shape in _shapes)
            {
                Console.WriteLine("Punkty figury:");

                if (shape?.Points == null || shape.Points.Count == 0)
                {
                    Console.WriteLine("  (brak punktów)");
                }
                else
                {
                    foreach (var p in shape.Points)
                        Console.WriteLine($"({p.X}, {p.Y})");
                }

                await shape.Draw(_context);
            }

            // await Task.Delay(50); // Krótkie opóźnienie dla płynności

            // StateHasChanged();
        }

    }

    private async Task FitToCanvas(IShapeDC targetShape, string idRegion, bool skalaAutomatyczna, List<XPoint> Wierzcholki, double klikX, double klikY)
    {

        Console.WriteLine($"🔍 FitToCanvas --> Dopasowano do shape: scale={_currentScale:F2}, panX={_panX:F2}, panY={_panY:F2}");

        // await DrawStructureAndRestrykcje(0);

        //await Task.Delay(250); // Krótkie opóźnienie dla płynności

        //if (await DodajWybranyKwadratOkna(idRegion, Wierzcholki) == false) return; // teraz z idRegion

        if(WybranyModel.Typ == "Słupek stały")
        {
            var WierzcholkiST = ObliczWierzcholkiSlupkaStalego(Wierzcholki);

            if (!await DodajWybranyKwadratOkna(idRegion, WierzcholkiST, klikX, klikY))
                return;
        }
        else
        {
            if (!await DodajWybranyKwadratOkna(idRegion, Wierzcholki, klikX, klikY))
                return;
        }


        await DrawStructureAndRestrykcje(0);

        isTextureLoaded = false;

        // await UpdateCanvasSizeFromDiv();
        // await RenderFrame();

    }

    private List<XPoint> ObliczWierzcholkiSlupkaStalego(List<XPoint> wierzcholki)
    {
        if (wierzcholki == null || wierzcholki.Count < 4)
        {
            Console.WriteLine("❌ Brak wystarczającej liczby punktów do wyszukania linii.");
            return new List<XPoint>();
        }

        // 🔸 Linia bazowa, dla której szukamy dopasowania
        var p1 = wierzcholki[0];
        var p2 = wierzcholki[3];

        // poprawny sposób utworzenia listy z dwoma punktami
        return new List<XPoint> { p1, p2 };
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (CanvasRef == null) return;

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa (uwzględnia marginesy i DPI)
        double relativeX = (e.ClientX - rect.Left) * rect.ScaleX;
        double relativeY = (e.ClientY - rect.Top) * rect.ScaleY;

        // Przeliczenie na współrzędne modelu
        double modelX = (relativeX - _offsetX) / _currentScale;
        double modelY = (relativeY - _offsetY) / _currentScale;

        // Ograniczenie do obszaru modelu
        modelX = Math.Clamp(modelX, 0, constWlasciwosciOkna.Szerokosc);
        modelY = Math.Clamp(modelY, 0, constWlasciwosciOkna.Wysokosc);

        mousePosition = $"X: {modelX:F0} mm, Y: {modelY:F0} mm (skala: {_currentScale:F2})";
    }


    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_context == null) return;

        if (CanvasRef == null)
        {
            Console.WriteLine("⚠️ Brak referencji do canvasu!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            await _message.Warning("Wybierz system okienny przed przeciągnięciem modelu.", 1.5);
            return;
        }

        if (WybranyModel == null)
        {
            await _message.Warning("Wybierz model z listy przed przeciągnięciem.", 1.0);
            return;
        }

        // Pobierz informacje o przeciąganym modelu
        var draggedInfo = await GetDraggedModelInfoAsync();
        if (draggedInfo != null && !string.IsNullOrEmpty(draggedInfo.Type))
        {
            SelectedModelType = draggedInfo.Type;
            SelectedRowIdType = draggedInfo.RowId;
        }

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa (uwzględnia marginesy i DPI)
        double relativeX = (e.ClientX - rect.Left) * rect.ScaleX;
        double relativeY = (e.ClientY - rect.Top) * rect.ScaleY;

        // Przeliczenie na współrzędne modelu
        double modelX = (relativeX - _offsetX) / _currentScale;
        double modelY = (relativeY - _offsetY) / _currentScale;

        // Ograniczenie do obszaru modelu
        modelX = Math.Clamp(modelX, 0, constWlasciwosciOkna.Szerokosc);
        modelY = Math.Clamp(modelY, 0, constWlasciwosciOkna.Wysokosc);


        Console.WriteLine($"🔧 relativeX: {relativeX}, relativeY: {relativeY}, Scale: {_currentScale}");
        Console.WriteLine($"📌 Pozycja w modelu: modelX={modelX}, modelY={modelY}");

        mousePosition = $"Wybrałeś: X: {modelX:F0} mm, Y: {modelY:F0} mm (skala: {_currentScale:F2}) {constWlasciwosciOkna.Szerokosc}x{constWlasciwosciOkna.Wysokosc}";

        // await Task.Delay(50);

        bool tylkoRama = false;

        if (SelectedModelType == "Rama") tylkoRama = true;

        // 🔍 Znajdź region, w który kliknięto
        var region = FindRegionAtPosition(modelX, modelY, tylkoRama);

        if (region == null)
        {
            await _message.Warning($"❌ Nie znaleziono regionu dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🔍 Znajdź shape wewnątrz regionu
        var shape = _shapes.FirstOrDefault(s =>
        {
            var bbox = s.GetBoundingBox();
            var testPoints = new[]
            {
            new XPoint(bbox.X, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y + bbox.Height),
            new XPoint(bbox.X, bbox.Y + bbox.Height),
            new XPoint(bbox.X + bbox.Width / 2, bbox.Y + bbox.Height / 2)
            };

            return testPoints.Any(p => IsPointInPolygon(region.Wierzcholki, p.X, p.Y));
        });

        if (shape == null)
        {
            await _message.Warning($"❌ Nie znaleziono kształtu w regionie {region.Id} dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🎯 Dopasuj widok do kształtu i regionu

        await FitToCanvas(shape, region.Id, false, region.Wierzcholki, modelX, modelY);

        await Task.Delay(50);

        foreach (var shapeX in _shapes)
        {
            // Console.WriteLine($"🖌️ Rysuję {shapeX.GetType().Name}");
            await shapeX.Draw(_context);
        }
        await _context.RestoreAsync();

        WybranyModel = null;

        // Resetuj kursor JS
        await JS.InvokeVoidAsync("ResetCursorGlobal");

    }

    private ShapeRegion? FindRegionAtPosition(double x, double y, bool tylkoRama)
    {
        if(WybranyModel == null)
        {
            Console.WriteLine($"🔍 Szukam regionu w pozycji (model): X={x:F2}, Y={y:F2} MODEL NIEZNANY");
        }
        else
        {
            Console.WriteLine($"🔍 Szukam regionu w pozycji (model): X={x:F2}, Y={y:F2} MODEL:{WybranyModel.Typ}");
        }

        if (_regionsDualRama == null || !_regionsDualRama.Any() || _regionsSkrzydlo == null || !_regionsSkrzydlo.Any())
        {
            Console.WriteLine("❌ Brak regionów do sprawdzenia!");
            return null;
        }

        if (tylkoRama)
        {
            foreach (var region in _regionsDualRama)
            {
                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsDualRama Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region DualRama {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }
        else
        {
            foreach (var region in _regionsSkrzydlo)
            {

                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsSkrzydlo Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region Skrzydło {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }

        Console.WriteLine("❌ Żaden region nie zawiera podanego punktu.");
        return null;
    }

    private bool IsPointInPolygon(List<XPoint> polygon, double x, double y)
    {
        bool inside = false;
        int n = polygon.Count;

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            var xi = polygon[i].X;
            var yi = polygon[i].Y;
            var xj = polygon[j].X;
            var yj = polygon[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi); // +epsilon by uniknąć dzielenia przez 0

            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private async Task OnlyRestrykcje()
    {

        if (!string.IsNullOrEmpty(SelectedModelType))
        {

            if (ListaModeli != null)
            {
                Console.WriteLine($"OnlyRestrykcje - Typ --> SelectedModelType: {SelectedModelType}");

                var _ListaModeliResrykcje = ListaModeli.FirstOrDefault(x => x.Typ == SelectedModelType);

                if (_ListaModeliResrykcje != null)
                {
                    if (infoObiekt == null)
                        infoObiekt = new List<WyrobWymiaryOpis>();

                    string restrykcje = "";

                    if (_ListaModeliResrykcje.KonstrMinSzer > constWlasciwosciOkna.Szerokosc)
                    {
                        restrykcje = "<#SYS> Konstrukcja nie spełnia warunku MIN szerokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMinWys > constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MAX wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < constWlasciwosciOkna.Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }

                    // ✅ Poprawione: Utwórz nowy obiekt przed ustawieniem właściwości

                    if(restrykcje != "")
                    {
                        WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc, SelectedModelType, restrykcje);

                        infoObiekt.Add(opisy);
                    }

                    infoBoom.Clear();// czyści listę przed dodaniem nowych elementów

                    foreach (var danedoboom in ksztalty)
                    {
                        WygenerowaneMaterialy opisySys = new WygenerowaneMaterialy(
                         danedoboom.RowIdElementu,
                         danedoboom.DlogoscNaGotowoElementu,
                         danedoboom.NazwaElementu ?? "",
                         danedoboom.IndeksElementu ?? "",
                         1,
                         ""
                         );

                        infoBoom.Add(opisySys);
                    }

                }

            }
        }

        await Task.CompletedTask;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        //Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private bool isTextureLoaded = false;

    private async Task DrawStructureAndRestrykcje(int isTextureLoadedNZ = 999)
    {

        if (isTextureLoadedNZ == 0) isTextureLoaded = false;

        try
        {
            // if (CanvasRef == null)
            // {
            //     Console.WriteLine("⚠️ Brak referencji do canvasu!");
            //     return;
            // }

            // _context ??= await CanvasRef.CreateCanvas2DAsync();

            if (!isTextureLoaded)
            {

                await OnlyRestrykcje();

                Console.WriteLine("DrawStructureAndRestrykcje.");

            }


        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas rysowania: {ex.Message}");
        }
    }

    public async Task<DraggedModelInfo> GetDraggedModelInfoAsync()
    {
        try
        {
            var info = await JS.InvokeAsync<DraggedModelInfo>("getDraggedModelInfo");
            await JS.InvokeVoidAsync("clearCurrentModel"); // Opcjonalne czyszczenie po odczycie
            return info;
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Błąd pobierania informacji o modelu: {ex.Message}");
            return null;
        }
    }

    [JSInvokable]
    public async Task OnDragError(string message)
    {
        await _message.Error(message);
        StateHasChanged();
    }

    public void Dispose()
    {
        if (_disposed) return;

        _disposed = true;

        try
        {
            // Najpierw ustaw flagę, żeby uniknąć kolejnych wywołań
            _ = JS.InvokeVoidAsync("clearDotNetHelper").AsTask();
            _dotNetHelper?.Dispose();
            // Nie ustawiaj JS na null, bo może być potrzebny do innych operacji?
            // JS = null;
            Console.WriteLine($"🧹 Dispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd Dispose: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        try
        {
            await JS.InvokeVoidAsync("cleanupEventListeners");
            await JS.InvokeVoidAsync("clearDotNetHelper");
            await JS.InvokeVoidAsync("clearCanvasRef");
            Console.WriteLine("✅ JavaScript cleanup completed");
            _dotNetHelper?.Dispose();
            Console.WriteLine($"🧹 AsyncDispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd AsyncDispose: {ex.Message}");
        }
        finally
        {
            // JS = null; // Można to zrobić, ale uważaj, bo może być używane w innych miejscach
            _dotNetHelper = null;
        }
    }

    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        try
        {
            isTextureLoaded = true;
            // Console.WriteLine("✅ Tekstura załadowana!");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ładowania tekstury: {ex.Message}");
        }
    }

    public async Task RozstawLinie(bool zmienWymOkna = true)
    {
        // 🟦 1. Funkcja pomocnicza – rozstaw linie w danej kolekcji
        void RozstawKolekcje(List<ShapeRegion> kolekcja, string nazwaKolekcji, double szerokosc, double wysokosc)
        {
            var linie = kolekcja
                .Where(r => r.TypKsztaltu?.ToLower().Contains("linia") == true && r.Wierzcholki?.Count == 2)
                .ToList();

            int liczbaLinii = linie.Count;
            if (liczbaLinii == 0)
            {
                Console.WriteLine($"❌ Brak regionów typu 'linia' w {nazwaKolekcji}");
                return;
            }

            Console.WriteLine($"📏 Rozstawianie {liczbaLinii} linii w kolekcji: {nazwaKolekcji}");

            // odstępy dla pionowych i poziomych
            double odstępX = szerokosc / (liczbaLinii + 1);
            double odstępY = wysokosc / (liczbaLinii + 1);

            for (int i = 0; i < liczbaLinii; i++)
            {
                var region = linie[i];
                var p1 = region.Wierzcholki[0];
                var p2 = region.Wierzcholki[1];

                bool jestPionowa = Math.Abs(p1.X - p2.X) < 0.001;
                bool jestPozioma = Math.Abs(p1.Y - p2.Y) < 0.001;

                if (jestPionowa)
                {
                    double nowaX = odstępX * (i + 1);
                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = nowaX, Y = p1.Y },
                    new XPoint { X = nowaX, Y = p2.Y }
                };
                }
                else if (jestPozioma)
                {
                    double nowaY = odstępY * (i + 1);
                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = p1.X, Y = nowaY },
                    new XPoint { X = p2.X, Y = nowaY }
                };
                }
                else
                {
                    // linie skośne – równoległe przesunięcie
                    double offsetX = odstępX * (i + 1);
                    double offsetY = odstępY * (i + 1) * 0.1; // delikatne przesunięcie dla wizualnego rozdziału

                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = p1.X + offsetX, Y = p1.Y + offsetY },
                    new XPoint { X = p2.X + offsetX, Y = p2.Y + offsetY }
                };
                }

                Console.WriteLine($"   🔹 {nazwaKolekcji} Linia #{i + 1}: " +
                    $"({region.Wierzcholki[0].X:F1},{region.Wierzcholki[0].Y:F1}) → " +
                    $"({region.Wierzcholki[1].X:F1},{region.Wierzcholki[1].Y:F1})");
            }
        }

        // 🟨 2. Rozstaw osobno linie z obu kolekcji
        RozstawKolekcje(_regionsDualRama, "DualRama", constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc);
        RozstawKolekcje(_regionsSkrzydlo, "Skrzydlo", constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc);

        await Task.CompletedTask;

        // if (zmienWymOkna) await ZmienWymiaryOkna(false);
    }

    private async Task ZmienWymiaryOkna()
    {
        if (_shapes == null || !_shapes.Any())
        {
            Console.WriteLine("❌ Brak kształtów do przeskalowania!");
            return;
        }

        // 🔍 Upewnij się, że punkty w ShapeService istnieją
        foreach (var shape in ShapeService.Shapes)
        {
            if (shape?.Points == null || !shape.Points.Any())
            {
                Console.WriteLine($"⚠️ Pominięto shape bez punktów: {shape?.GetType().Name}");
                continue;
            }
        }

        int _tmpSzerokosc = 0;
        int _tmpWysokosc = 0;

        // Tymczasowe przechowanie starych wymiarów
        if (_shapes != null && _shapes.Any())
        {
            Console.WriteLine($"🔍 Stare wymiary konstrukcji: Szerokość={_shapes.Max(s => s.Szerokosc)}, Wysokość={_shapes.Max(s => s.Wysokosc)}");
        }
        else
        {
            Console.WriteLine("❌ Brak kształtów do odczytania wymiarów [_shapes]!");
            return;
        }

        _tmpSzerokosc = (int)_shapes.Max(s => s.Szerokosc);
        _tmpWysokosc = (int)_shapes.Max(s => s.Wysokosc);

        if (constWlasciwosciOkna == null)
        {
            Console.WriteLine("❌ constWlasciwosciOkna jest puste, nie można kontynuować.");
            return;
        }

        Console.WriteLine($"🔍 Stare wymiary konstrukcji: Szerokość={_tmpSzerokosc}, Wysokość={_tmpWysokosc}");

        // 🔄 Aktualizujemy wymiary shape’ów bazowych
        foreach (var shape in ShapeService.Shapes)
        {
            shape.Szerokosc = constWlasciwosciOkna.Szerokosc;
            shape.Wysokosc = constWlasciwosciOkna.Wysokosc;
        }

        Console.WriteLine($"🔍 Nowe wymiary konstrukcji: Szerokość={ShapeService.Shapes.Max(s => s.Szerokosc)}, Wysokość={ShapeService.Shapes.Max(s => s.Wysokosc)}");

        // 🔄 Regeneracja regionów
        await GenerujObrysPozZmianieWymiarow(false);

        // // 🟦 Aktualizujemy regiony bez skalowania
        // var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo);

        // foreach (var region in wszystkieRegiony)
        // {
        //     EditElements(
        //         new List<ShapeRegion> { region },
        //         region.Id,
        //         (float)constWlasciwosciOkna.Szerokosc,
        //         (float)constWlasciwosciOkna.Wysokosc
        //     );

        //     Console.WriteLine($"🔍 PobierzGenerator wyszukuje region ID {region.Id} w generatorze.");

        //     var generator = PobierzGenerator(region.Id);

        //     if (generator != null)
        //     {
        //         ZapiszStanGeneratora(region.Id, generator);

        //         Console.WriteLine($"🔍 PobierzGenerator/ZapiszStanGeneratora: zaktualizowano generator regionu {region.Id}.");
        //     }
        //     else
        //     {
        //         Console.WriteLine($"❌ Brak generatora dla regionu ID {region.Id}");
        //     }

        // }

        // // ============================
        // // 3️⃣ OBLICZ DELTĘ ZMIANY
        // // ============================
        // double deltaWidth = constWlasciwosciOkna.Szerokosc - _tmpSzerokosc;
        // double deltaHeight = constWlasciwosciOkna.Wysokosc - _tmpWysokosc;

        // Console.WriteLine($"🔍 ΔW={deltaWidth}, ΔH={deltaHeight}");

        // // ============================
        // // 4️⃣ PRZESUŃ KSZTAŁTY *PRZED* GENERACJĄ REGIONÓW
        // // ============================
        // if (ksztalty != null && ksztalty.Any())
        // {
        //     foreach (var k in ksztalty)
        //     {
        //         Console.WriteLine($"✏️ Przetwarzanie kształtu: {k.NazwaElementu} / {k.ZIndex} / {k.Strona}");

        //         if (k?.Wierzcholki == null || k.Wierzcholki.Count < 2)
        //         {
        //             Console.WriteLine($"⚠️ Pominięto ksztalt bez wystarczającej liczby wierzchołków: {k?.NazwaElementu}");
        //             continue;
        //         }

        //         // =============================================
        //         // 1️⃣ PRZESUNIĘCIE ELEMENTU (kotwienie do lewego-górnego rogu)
        //         // =============================================
        //         if (k.Strona == "Prawo")
        //         {
        //             k.Wierzcholki = k.Wierzcholki
        //                 .Select(p => new XPoint(p.X + deltaWidth, p.Y))
        //                 .ToList();
        //         }
        //         else if (k.Strona == "Dół")
        //         {
        //             k.Wierzcholki = k.Wierzcholki
        //                 .Select(p => new XPoint(p.X, p.Y + deltaHeight))
        //                 .ToList();
        //         }

        //         // =============================================
        //         // 2️⃣ DOPIERO TERAZ WYDŁUŻAMY PROFIL
        //         // =============================================
        //         double minX = k.Wierzcholki.Min(p => p.X);
        //         double maxX = k.Wierzcholki.Max(p => p.X);
        //         double minY = k.Wierzcholki.Min(p => p.Y);
        //         double maxY = k.Wierzcholki.Max(p => p.Y);

        //         double width = maxX - minX;
        //         double height = maxY - minY;

        //         // Profil poziomy → wydłużamy na prawo
        //         if (width > height)
        //         {
        //             k.Wierzcholki = k.Wierzcholki.Select(p => new XPoint
        //             {
        //                 X = p.X + (p.X > minX + width / 2 ? deltaWidth : 0),
        //                 Y = p.Y
        //             }).ToList();

        //             k.DlogoscElementu += (float)deltaWidth;
        //             k.DlogoscNaGotowoElementu += (float)deltaWidth;
        //         }
        //         // Profil pionowy → wydłużamy w dół
        //         else
        //         {
        //             k.Wierzcholki = k.Wierzcholki.Select(p => new XPoint
        //             {
        //                 X = p.X,
        //                 Y = p.Y + (p.Y > minY + height / 2 ? deltaHeight : 0)
        //             }).ToList();

        //             k.DlogoscElementu += (float)deltaHeight;
        //             k.DlogoscNaGotowoElementu += (float)deltaHeight;
        //         }


        //         Console.WriteLine($"✅ Dopasowano: {k.NazwaElementu}");
        //     }
        // }

        //await RozstawLinie(false);
        await ApplyZoom(_currentScale);

        Console.WriteLine($"✅ Zmieniono wymiary konstrukcji: {constWlasciwosciOkna.Szerokosc}x{constWlasciwosciOkna.Wysokosc}");
    }

    private void EditElements(
    List<ShapeRegion> regions,
    string regionId,
    float newWidth,
    float newHeight)
    {
        if (regions == null || regions.Count == 0)
            return;

        var region = regions.FirstOrDefault(r => r.Id == regionId);

        if (region == null)
        {
            Console.WriteLine($"❌ EditElements: brak regionu o ID {regionId}");
            return;
        }

        if (region.Wierzcholki == null || region.Wierzcholki.Count < 3)
        {
            Console.WriteLine($"❌ EditElements: region ID {regionId} ma za mało punktów");
            return;
        }

        // 🧩 Stare wartości bounding box
        float minX = (float)region.Wierzcholki.Min(p => p.X);
        float maxX = (float)region.Wierzcholki.Max(p => p.X);
        float minY = (float)region.Wierzcholki.Min(p => p.Y);
        float maxY = (float)region.Wierzcholki.Max(p => p.Y);

        float oldWidth = maxX - minX;
        float oldHeight = maxY - minY;

        float deltaWidth = newWidth - oldWidth;
        float deltaHeight = newHeight - oldHeight;

        Console.WriteLine($"✏️ EditElements ΔW={deltaWidth}, ΔH={deltaHeight}");

        // 🧮 Modyfikacja BEZ SKALOWANIA
        var newPoints = region.Wierzcholki.Select(p =>
        {
            double newX = p.X;
            double newY = p.Y;

            // przesuwamy tylko punkty graniczne
            if (Math.Abs(p.X - maxX) < 0.01f)
                newX += deltaWidth;

            if (Math.Abs(p.Y - maxY) < 0.01f)
                newY += deltaHeight;

            return new XPoint(newX, newY);
        }).ToList();

        region.Wierzcholki = newPoints;

        Console.WriteLine($"✅ EditElements zakończone dla regionu {regionId}");
    }


    private async Task<bool> DodajWybranyKwadratOkna(string idRegion, List<XPoint> wierzcholki, double klikX, double klikY)
    {
        if (SelectedModelType == null || string.IsNullOrEmpty(SelectedModelType))
        {
            Console.WriteLine("❌ SelectedModelType jest puste, nie można kontynuować.");
            return false;
        }

        if (_generatorStates != null && _generatorStates.Count == 0)
        {
            if (SelectedModelType.Trim() != "Rama")
            {
                await _message.Info($"Wybierz konstrukcję typu rama!!!");
                return false;
            }
        }

        Console.WriteLine($"📦 -> DodajWybranyKwadratOkna wywołane z idRegion: {idRegion} SelectedRowIdType: {SelectedRowIdType} - konfmodeleelementy");

        var generator = new Generator
        {
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82
        };

        if (KonfiguracjeSystemu != null)
        {
            generator.KonfiguracjeSystemu = KonfiguracjeSystemu;
            generator.RowIdSystemu = Guid.Parse(SelectedSystemId);

            if (Guid.TryParse(SelectedRowIdType, out var rowIdModeluSzukaj))
            {
                generator.RowIdModelu = rowIdModeluSzukaj;

                var powiazanyModel = await Http.GetFromJsonAsync<MVCKonfModele>($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{SelectedRowIdType}");
                if (powiazanyModel != null)
                {
                    generator.MVCKonfModelu = powiazanyModel;

                    if (generator.MVCKonfModelu.KonfModele != null)
                        Console.WriteLine($"! Powiązany model: {generator.MVCKonfModelu.KonfModele[0].NazwaKonfiguracji} ile: {generator.MVCKonfModelu.KonfModele.Count()}");
                }
                else
                {
                    Console.WriteLine($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    await _message.Error($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    return false;
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                await _message.Error($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                return false;

            }
        }
        else
        {
            if (string.IsNullOrEmpty(SelectedSystemId))
            {
                Console.WriteLine("❌ KonfiguracjeSystemu jest puste, nie można kontynuować.");
                return false;
            }

            var kofiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");
            generator.KonfiguracjeSystemu = kofiguracjeSystemu;
        }

        generator.EdytowanyModel = WybranyModel;
        generator.TypKsztaltu = WybranyKsztalt;
        generator.Wierzcholki = wierzcholki;

        var regionReferencyjny = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .FirstOrDefault(r => r.Id == idRegion);

        if (regionReferencyjny == null || regionReferencyjny.Wierzcholki == null)
        {
            Console.WriteLine("❌ Brak regionu referencyjnego.");
            return false;
        }

        var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo);

        foreach (var r in wszystkieRegiony)
        {
            Console.WriteLine($"🔎 Region: {r.Id}, Typ: {r.TypKsztaltu}, Wierzcholki: {r.Wierzcholki?.Count} TypLiniiDzielacej: {r.TypLiniiDzielacej}");

            foreach (var linia in r.Wierzcholki)
            {
                Console.WriteLine($"🔎 Styczne linie w #1 - Wierzcholki: {(int)linia.X},{(int)linia.Y}");
            }
        }

        var zawarteRegiony = wszystkieRegiony
           .Where(r =>
               r.Wierzcholki != null &&
               r.Wierzcholki.Count >= 3 &&
               r.Wierzcholki.All(p => CzyPunktWNWielokacie(p, regionReferencyjny.Wierzcholki))
           )
           .ToList();

        foreach (var r in wszystkieRegiony)
        {
            Console.WriteLine($"🧩 Region: {r.Id} | Typ: {r.TypKsztaltu} | TypLiniiDzielacej: {r.TypLiniiDzielacej} | Wierzcholki: {r.Wierzcholki?.Count ?? 0}");

            if (r.Wierzcholki != null)
            {
                foreach (var p in r.Wierzcholki)
                    Console.WriteLine($"   Punkt: {p.X};{p.Y}");
            }
        }

        var wszystkieRegionyLinii = wszystkieRegiony
        .Select(r =>
        {
            if (r.Wierzcholki == null || r.Wierzcholki.Count < 2)
                return null;

            List<XPoint> punktyLinii;

            // Jeśli to prostokąt (4 punkty) — wyciągnij linię środkową
            if (r.Wierzcholki.Count >= 4)
            {
                var minX = r.Wierzcholki.Min(p => p.X);
                var maxX = r.Wierzcholki.Max(p => p.X);
                var minY = r.Wierzcholki.Min(p => p.Y);
                var maxY = r.Wierzcholki.Max(p => p.Y);

                // Jeśli wysokość > szerokości → linia pionowa
                if (Math.Abs(maxY - minY) > Math.Abs(maxX - minX))
                {
                    var midX = (minX + maxX) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = midX, Y = minY },
                    new XPoint { X = midX, Y = maxY }
                };
                }
                else // pozioma
                {
                    var midY = (minY + maxY) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = minX, Y = midY },
                    new XPoint { X = maxX, Y = midY }
                };
                }
            }
            else
            {
                punktyLinii = r.Wierzcholki;
            }

            return new ShapeRegion
            {
                Id = r.Id,
                TypKsztaltu = r.TypKsztaltu,
                TypLiniiDzielacej = r.TypLiniiDzielacej,
                Wierzcholki = punktyLinii
            };
        })
        .Where(r => r != null)
        .ToList();

        var styczneLinie = wszystkieRegionyLinii
            .Where(r =>
                r.Wierzcholki != null &&
                r.Wierzcholki.Count == 2 &&
                !CzyPunktyRowneSlupek(r.Wierzcholki[0], r.Wierzcholki[1])
            )
            .ToList();

        Console.WriteLine($"✅ Styczne linie: {styczneLinie.Count}");

        foreach (var linia in styczneLinie)
        {
            Console.WriteLine($"✅ Styczne linie: 🔹 Linia: {linia.Id}, {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
        }

        bool czyRegionZawieraSlupekRuchomy = false;
        bool stronaLewa = false;
        bool stronaPrawa = false;

        if (styczneLinie.Count() > 0)
            Console.WriteLine($"⚠️⚠️⚠️ styczneLinie region rama/skrzydło: {styczneLinie.Count()} zawarteRegiony: {zawarteRegiony.Count()} styczneLinie:{styczneLinie[styczneLinie.Count() - 1].TypKsztaltu}  ⚠️");


        if (styczneLinie.Any())
        {
            // 🔹 Grupowanie i usuwanie duplikatów słupków
            var slupkiRuchome = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek ruchomy")
                .GroupBy(x => string.Join("|", x.Wierzcholki.Select(p => $"{p.X:F3},{p.Y:F3}")))
                .Select(g => g.First())
                .ToList();

            var slupkiStale = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek stały" || x.TypLiniiDzielacej == "Podwójna rama")
                .GroupBy(x => string.Join("|", x.Wierzcholki.Select(p => $"{p.X:F3},{p.Y:F3}")))
                .Select(g => g.First())
                .ToList();

            czyRegionZawieraSlupekRuchomy = slupkiRuchome.Any();

            // double tolerancjaKlik = 0.05; // aby uniknąć efektu granicznego

            if (czyRegionZawieraSlupekRuchomy)
            {
                Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy w ilości: {slupkiRuchome.Count}.");

                // Obliczamy środki X wszystkich słupków ruchomych
                var srodkiRuchomych = slupkiRuchome
                    .Select(sl => (sl.Wierzcholki[0].X + sl.Wierzcholki[1].X) / 2)
                    .OrderBy(x => x)
                    .ToList();

                if (srodkiRuchomych.Count == 1)
                {
                    double srodekX = srodkiRuchomych.First();
                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2}, 1 słupek ruchomy");

                    if (klikX > srodekX)
                    {
                        stronaLewa = true;
                        Console.WriteLine("⬅️ Kliknięcie po prawej stronie słupka ruchomego → słupek po lewej stronie.");
                    }
                    else
                    {
                        stronaPrawa = true;
                        Console.WriteLine("➡️ Kliknięcie po lewej stronie słupka ruchomego → słupek po prawej stronie.");
                    }
                }
                else if (srodkiRuchomych.Count >= 2)
                {
                    // Dwa słupki ruchome – obliczamy środek między nimi
                    double srodekX = (srodkiRuchomych.First() + srodkiRuchomych.Last()) / 2;
                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2}, {srodkiRuchomych.Count} słupków ruchomych");

                    foreach (var sl in slupkiRuchome)
                    {
                        Console.WriteLine($"📐 Słupek ruchomy: {sl.Id} [{sl.Wierzcholki[0].X:F2},{sl.Wierzcholki[0].Y:F2}] → [{sl.Wierzcholki[1].X:F2},{sl.Wierzcholki[1].Y:F2}]");
                    }

                    // Domyślnie — słupki ruchome po obu stronach
                    stronaLewa = true;
                    stronaPrawa = true;

                    // Określamy kliknięcie względem środka
                    if (klikX > srodekX)
                    {
                        Console.WriteLine("⬅️ Kliknięcie po prawej stronie zestawu słupków → priorytet słupka ruchomego po lewej stronie.");
                    }
                    else
                    {
                        Console.WriteLine("➡️ Kliknięcie po lewej stronie zestawu słupków → priorytet słupka ruchomego po prawej stronie.");
                    }

                    // 🧱 Sprawdzamy, czy między słupkami ruchomymi znajduje się słupek stały
                    if (slupkiStale.Any())
                    {
                        var srodkiStalych = slupkiStale
                            .Select(sl => (sl.Wierzcholki[0].X + sl.Wierzcholki[1].X) / 2)
                            .OrderBy(x => x)
                            .ToList();

                        double minRuchomy = srodkiRuchomych.First();
                        double maxRuchomy = srodkiRuchomych.Last();

                        foreach (var stalyX in srodkiStalych)
                        {
                            Console.WriteLine($"🧱 Słupek stały X={stalyX:F2}, klikX={klikX:F2}");

                            // Jeśli słupek stały leży POMIĘDZY słupkami ruchomymi
                            if (stalyX > minRuchomy && stalyX < maxRuchomy)
                            {
                                // Jeśli klik po lewej stronie słupka stałego → zablokuj prawą stronę
                                if (klikX < stalyX)
                                {
                                    stronaPrawa = false;
                                    Console.WriteLine("🚫 Słupek stały po prawej stronie kliknięcia → wyłączam prawą stronę.");
                                }
                                // Jeśli klik po prawej stronie słupka stałego → zablokuj lewą stronę
                                else if (klikX > stalyX)
                                {
                                    stronaLewa = false;
                                    Console.WriteLine("🚫 Słupek stały po lewej stronie kliknięcia → wyłączam lewą stronę.");
                                }
                            }
                        }
                    }
                }
                else
                {
                    // W razie większej liczby słupków — obie strony aktywne
                    stronaLewa = true;
                    stronaPrawa = true;
                    Console.WriteLine("↔️ Słupek ruchomy po obu stronach.");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka ruchomego.");
            }

            if (slupkiStale.Any())
            {
                Console.WriteLine($"📏 Region {idRegion} zawiera {slupkiStale.Count} słupków stałych.");
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka stałego.");
            }

            Console.WriteLine($"✅ Ustawiono w generatorze: Lewa={generator.RuchomySlupekPoLewej}, Prawa={generator.RuchomySlupekPoPrawej}");
        }
        else
        {
            Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera linii stycznych.");
        }

        generator.RuchomySlupekPoLewej = stronaLewa;
        generator.RuchomySlupekPoPrawej = stronaPrawa;

        if (czyRegionZawieraSlupekRuchomy && SelectedModelType != "Rama" && SelectedModelType != "Słupek stały")
        {

            bool czyZawieraSlupekRuchomyWPowiazanymModelu = _generatory
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfModele != null &&
                     state.Value.MVCKonfModelu.KonfModele.Any(ks => ks.Typ == "Skrzydło z słupkiem ruchomym")
                 );

            Console.WriteLine($"✅✅✅ Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów. Model-Typ: {WybranyModel.Typ} czyZawieraSlupekRuchomyWPowiazanymModelu: {czyZawieraSlupekRuchomyWPowiazanymModelu}");

            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {

                if (WybranyModel.Typ != "Skrzydło z słupkiem ruchomym")
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj wcześniej słupek ruchomy do konstrukcji.",
                        2.0
                    );
                    return false;
                }

            }

        }

        int ileRegionWSkrzydleZawieraSlupekRuchomy = _regionsSkrzydlo.Where(x => x.TypLiniiDzielacej == "Słupek ruchomy").Count();

        int ileJestDodanychSlRuchWRegionach = _generatory
            .SelectMany(x => x.Value.Region) // spłaszczamy kolekcje regionów
            .Count(v => v.TypLiniiDzielacej == "Słupek ruchomy");

        if (generator.MVCKonfModelu == null || generator.MVCKonfModelu.KonfModele == null || generator == null) return false;

        int ileRegionDRZawieraSlupekRuchomy = generator.MVCKonfModelu.KonfModele.Where(x => x.Typ == "Skrzydło z słupkiem ruchomym").Count();

        if (WybranyModel == null)
        {
            await _message.Warning(
                "Błąd wyboru modelu!!!!",
                2.0
            );
            return false;
        }

        Console.WriteLine($"🟩 Ile regionów skrzydła zawiera słupek ruchomy: {ileRegionWSkrzydleZawieraSlupekRuchomy} - Ile regionów DR zawiera słupek ruchomy: {ileRegionDRZawieraSlupekRuchomy} - SelectedModelType: {SelectedModelType} -> ileJestDodanychSlRuchWRegionach: {ileJestDodanychSlRuchWRegionach} Wybrany typ {WybranyModel.Typ}");

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && ileRegionDRZawieraSlupekRuchomy == 0 && SelectedModelType != "Rama" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            Console.WriteLine($"🟩 Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego! SelectedModelType: {SelectedModelType}");

            await _message.Warning(
                "1# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;

        }

        //Sprawdzić czy to potrzebne ???
        // if (ileJestDodanychSlRuchWRegionach > ileRegionDRZawieraSlupekRuchomy && SelectedModelType != "Rama" && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        // {
        //     await _message.Warning(
        //         "W regionie skrzydła jest już dodany słupek ruchomy. Nie można dodać więcej słupków ruchomych do tej konstrukcji.",
        //         2.0
        //     );
        //     return false;
        // }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == ileJestDodanychSlRuchWRegionach && SelectedModelType != "Rama" && WybranyModel.Typ != "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            await _message.Warning(
                "2# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;
        }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym")
        {
            await _message.Warning(
                "Dodajesz konstrukcję z słupkiem ruchomym, W konstrukcji nie ma podzaiłu z słupkiem ruchomym",
                2.0
            );
            return false;
        }

        double minX = 0;
        double maxX = 0;
        double minY = 0;
        double maxY = 0;
        string linieDzielace = "";
        List<XPoint> WierzcholkiWartosciNominalne = new();

        WierzcholkiWartosciNominalne.AddRange(wierzcholki);

        Console.WriteLine($"📐📐📐 SelectedModelType  = {SelectedModelType} Ilość wierzchołków: {wierzcholki.Count()} 📐📐📐");

        generator.ElementLiniowy = SelectedModelType.Trim() == "Słupek stały";

        if (SelectedModelType.Trim() == "Rama")
        {

            var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionDualRama != null)
            {
                var regionPoints = wybranyRegionDualRama.Wierzcholki;

                if (regionPoints == null || regionPoints.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej ?? idRegion;
                linieDzielace = wybranyRegionDualRama.TypLiniiDzielacej ?? "Brak";

                minX = regionPoints.Min(p => p.X);
                maxX = regionPoints.Max(p => p.X);
                minY = regionPoints.Min(p => p.Y);
                maxY = regionPoints.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = 0;
                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej;

                Console.WriteLine($"📐📐📐 Region Zindeks = 0 ID: {wybranyRegionDualRama.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc} generator.Wierzcholki.Count():{generator.Wierzcholki.Count()}");

                // stronaLewa = false;
                //stronaPrawa = false;

                generator.RuchomySlupekPoLewej = false;
                generator.RuchomySlupekPoPrawej = false;

                generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);//Rama nie ma sąsiada dla tego null

            }
        }

        // Oblicz przesunięcia tylko dla skrzydeł
        double przesLewo = 0, przesPrawo = 0, przesGora = 0, przesDol = 0;

        // Przygotowanie stanu generatora
        var state = new GeneratorState
        {
            Id = _generatorStates.Count + 1,
            IdRegion = idRegion,
            ZIndeks = generator.Zindeks,
            RowIdSystemu = Guid.Parse(SelectedSystemId),
            RowIdModelu = Guid.TryParse(SelectedRowIdType, out var rowIdModelu) ? rowIdModelu : (Guid?)null,
            MVCKonfModelu = generator.MVCKonfModelu,
            WybranyModel = WybranyModel,
            WybranyKsztalt = WybranyKsztalt,
            IdRegionWarstwaNizej = generator.IdRegionuPonizej,
            Wierzcholki = generator.ElementyRamyRysowane.SelectMany(k => k.Wierzcholki ?? new List<XPoint>()).Distinct().ToList(),
            WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne,
            LinieDzielace = linieDzielace,
            SlupekRuchomyPoLewejStronie = stronaLewa,
            SlupekRuchomyPoPrawejStronie = stronaPrawa,
            ListaKwadratow = new List<DaneKwadratu>(),
            ElementLiniowy = generator.ElementLiniowy,
        };

        var linie = ExtractLinesFromSquare(WierzcholkiWartosciNominalne);

       //string idGenerator = $"{idRegion}_{Guid.NewGuid()}";

        // Zapisz stan generatora
       // _generatory[idGenerator] = generator;

       //ZapiszStanGeneratora(idGenerator, state);

        List<SasiadInfo> sasiedzi = new();

        Console.WriteLine($"🔎 DodajWybranyKwadratOkna wierzchołki dla słupka stałego: {string.Join(", ", state.Wierzcholki.Select(p => $"({p.X:F2},{p.Y:F2})"))} ExtractLinesFromSquare -> {linie.Count()} _generatorStates.Count: {_generatorStates.Values.ToList().Count()}");

        foreach (var linia in linie)
        {
            Console.WriteLine($"🔎 DodajWybranyKwadratOkna -> Przetwarzam linię z punktami: ({linia[0].X},{linia[0].Y}) -> ({linia[1].X},{linia[1].Y}) _generatorStates.Count: {_generatorStates.Values.ToList().Count()}");

            if (linia.Count != 2) continue;

            var katSzukaj = ObliczKatLinii(linia);

            Console.WriteLine($"🔎 DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° w stanie ID: {state.Id}, IdRegion: {state.IdRegion}, WybranyTyp: {state.WybranyKsztalt}");

            sasiedzi = await ZnajdzSasiada(
                linia,
                _generatorStates.Values.ToList(),
                katSzukaj,
                state.SlupekRuchomyPoLewejStronie,
                state.SlupekRuchomyPoPrawejStronie,
                state.IdRegion,
                state.Id,
                WybranyModel.Typ == "Skrzydło z słupkiem ruchomym",
                WybranyModel.Typ == "Słupek stały",
                0.5
            );

            /// -------------------------------------------------- Wyszukiwanie sąsiadów --------------------------------------------------

            Console.WriteLine($"   🔹 Sasiad: Funkcja ZnajdzSasiada wyszukała obiektów: {sasiedzi.Count()} kąt: {katSzukaj}°");

            foreach (var s in sasiedzi)
            {
                Console.WriteLine($"   🔹 Sasiad: WybranyTyp: {s.WybranyTyp} linia.Count:{linia.Count()} MaSlupekRuchomy: {s.MaSlupekRuchomy} RowIdElementu: {s.RowIdElementu} kąt: {katSzukaj}°");
            }

            foreach (var s in linia)
            {
                Console.WriteLine($"   🔹 Sasiad: WybranyTyp: X:{s.X} Y:{s.Y} kąt: {katSzukaj}°");
            }

            // przykład pobrania najlepszego sąsiada
            var najlepszySasiad = sasiedzi.FirstOrDefault();

            string wybranyTypSasiada = "BRAK-DANYCH";

            if (sasiedzi != null && sasiedzi.Any())
            {
                double minX1 = WierzcholkiWartosciNominalne.Min(p => p.X);
                double maxX1 = WierzcholkiWartosciNominalne.Max(p => p.X);
                double minY1 = WierzcholkiWartosciNominalne.Min(p => p.Y);
                double maxY1 = WierzcholkiWartosciNominalne.Max(p => p.Y);

                for (int i = 0; i < sasiedzi.Count; i++)
                {
                    var s = sasiedzi[i];
                    var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                    if (stan?.WierzcholkiWartosciNominalne == null) continue;

                    double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                    double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                    double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                    double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                    // różnica dopasowania
                    double roznicaDopasowania = Math.Abs(minX1 - stanMinX) +
                                               Math.Abs(maxX1 - stanMaxX) +
                                               Math.Abs(minY1 - stanMinY) +
                                               Math.Abs(maxY1 - stanMaxY);
                    // różnica dopasowania
                    double roznicaDopasowaniaX = Math.Abs(minX1 - stanMinX) +
                                               Math.Abs(maxX1 - stanMaxX);
                    // różnica dopasowania
                    double roznicaDopasowaniaY = Math.Abs(minY1 - stanMinY) +
                                               Math.Abs(maxY1 - stanMaxY);

                    Console.WriteLine(
                        $"   🔹 Sasiad {i + 1}: IdRegionu: {s.IdRegionu}, RowIdElementu: {s.RowIdElementu}, " +
                        $"Dopasowanie: {roznicaDopasowania:F4} X:{roznicaDopasowaniaX:F4} Y:{roznicaDopasowaniaY:F4}  ZIndeks: {s.ZIndeks} id:{s.Id} " +
                        $"WybranyTyp: {s.WybranyTyp} MaSlupekRuchomy: {s.MaSlupekRuchomy} katSzukaj: {katSzukaj} stan.WybranyModel.Typ: {stan.WybranyModel.Typ}");
                }


                // 🔹 1. Szukamy "Słupka ruchomego"
                Console.WriteLine("🔍 Szukam typ --> Słupek ruchomy");

                najlepszySasiad = sasiedzi
                    .Where(s => s.WybranyTyp == "Słupek ruchomy")
                    .OrderBy(s =>
                    {
                        var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                        if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                        double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                        double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                        double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                        double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                        return Math.Abs(minX1 - stanMinX) +
                               Math.Abs(maxX1 - stanMaxX) +
                               Math.Abs(minY1 - stanMinY) +
                               Math.Abs(maxY1 - stanMaxY);
                    })
                    .FirstOrDefault();

                // 🔹 3. Jeśli nie znaleziono → szukamy innych
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam typ który zawiera --> Słupek stały");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp == "Słupek stały")
                        .OrderBy(s =>
                        {
                            var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                            if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                            double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                            double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                            double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                            double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                            return Math.Abs(minX1 - stanMinX) +
                                   Math.Abs(maxX1 - stanMaxX) +
                                   Math.Abs(minY1 - stanMinY) +
                                   Math.Abs(maxY1 - stanMaxY);
                        })
                        .FirstOrDefault();
                }

                // 🔹 3. Jeśli nie znaleziono → szukamy innych
                if (najlepszySasiad == null)
                {
                    Console.WriteLine("🔍 Szukam typ który nie zawiera --> Słupek stały lub Słupek ruchomy");

                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp != "Słupek ruchomy" && s.WybranyTyp != "Słupek stały")
                        .OrderBy(s =>
                        {
                            var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                            if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                            double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                            double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                            double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                            double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                            return Math.Abs(minX1 - stanMinX) +
                                   Math.Abs(maxX1 - stanMaxX) +
                                   Math.Abs(minY1 - stanMinY) +
                                   Math.Abs(maxY1 - stanMaxY);
                        }).OrderBy(s => s.Id) // To sprawdzenia czy wustycrczy sotować aby poprawnie wyszukiwać region!!!!
                        .FirstOrDefault();
                }
            }

            if (najlepszySasiad != null) wybranyTypSasiada = najlepszySasiad.WybranyTyp;

            Console.WriteLine(
                $"🔎 DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° - " +
                $"Najlepszy sąsiad: {(najlepszySasiad != null ? najlepszySasiad.RowIdElementu : "NIE-ZNALEZIONO-ROWID")} Typ: {wybranyTypSasiada}"
            );

            /// ------------------------------------------------ Wyszukiwanie sąsiadów KONIEC ------------------------------------------------

            var rowId = ZnajdzKonfiguracjeDlaLinii(linia, state, stronaLewa, stronaPrawa, idRegion, "Słupek ruchomy");

            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = linia,
                RowIdElementu = rowId,
                RowIdSasiada = najlepszySasiad?.RowIdElementu ?? Guid.Empty,
                RowIdRegionuSasiada = najlepszySasiad?.IdRegionu ?? "",
                KatLinii = katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                Strona = StronaSzukaj(
                        katSzukaj,
                        linia,
                        WierzcholkiWartosciNominalne.Min(p => p.Y),
                        WierzcholkiWartosciNominalne.Max(p => p.Y),
                        WierzcholkiWartosciNominalne.Min(p => p.X),
                        WierzcholkiWartosciNominalne.Max(p => p.X)
                    )
            });

            //if (SelectedModelType.ToLower().Trim() == "słupek stały") break;

        }

        //--------------------------------------------------- Obsługa słupka stałego --------------------------------------------------

        if (SelectedModelType.ToLower().Trim() == "słupek stały")
        {

            if (!styczneLinie.Any())
            {
                Console.WriteLine($"✅ Region {idRegion} nie zawiera słupka stałego.");
                return false;
            }

            Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Znaleziono {styczneLinie.Count} potencjalnych linii dla słupka stałego");

            generator.Zindeks = 1;

            // 🔹 Spróbuj znaleźć linię typu „Słupek stały”
            var liniaStala = styczneLinie
                .Where(s =>
                    !string.IsNullOrWhiteSpace(s.TypLiniiDzielacej) &&
                    s.TypLiniiDzielacej.ToLower().Contains("słupek") &&
                    s.Wierzcholki != null &&
                    s.Wierzcholki.Count == 2)
                .GroupBy(s => new
                {
                    X1 = Math.Round(s.Wierzcholki[0].X, 2),
                    Y1 = Math.Round(s.Wierzcholki[0].Y, 2),
                    X2 = Math.Round(s.Wierzcholki[1].X, 2),
                    Y2 = Math.Round(s.Wierzcholki[1].Y, 2),
                    Typ = s.TypLiniiDzielacej
                })
                .Select(g => g.First()) // usuwa duplikaty
                .FirstOrDefault(s =>
                    Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) > 0.01 ||
                    Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01);

            foreach (var linia in styczneLinie)
            {
                Console.WriteLine($"🔹 Sprawdzana linia: {linia.Id}, TypLiniiDzielacej: '{linia.TypLiniiDzielacej}', Wierzcholki: {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
            }

            liniaStala = styczneLinie
            .Where(s =>
                s.Wierzcholki != null &&
                s.Wierzcholki.Count == 2 &&
                s.TypLiniiDzielacej == "Słupek stały" &&
                Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) < 0.01 &&  // linia pionowa
                Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01)    // nie pozioma
            .OrderBy(s => Math.Abs(s.Wierzcholki[0].X - klikX))              // najbliżej kliknięcia
            .FirstOrDefault();

            //}

            if (liniaStala == null)
            {
                Console.WriteLine($"⚠️ Nie znaleziono linii z TypLiniiDzielacej='Słupek stały'. Szukam pionowej linii jako zamiennika... klikX: {klikX}");

                liniaStala = styczneLinie
            .Where(s =>
                s.Wierzcholki != null &&
                s.Wierzcholki.Count == 2 &&
                s.TypLiniiDzielacej == "Słupek stały" &&
                Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) > 0.01 &&  // linia pozioma
                Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) < 0.01)    // nie pionowa
            .OrderBy(s => Math.Abs(s.Wierzcholki[0].Y - klikY))              // najbliżej kliknięcia
            .FirstOrDefault();
            }

            if (liniaStala == null)
            {
                Console.WriteLine($"⚠️ Nie znaleziono linii z TypLiniiDzielacej='Słupek stały'. Szukam poziomej linii jako zamiennika... klikY: {klikY}");
                _message.Warning("Nie znaleziono linii stycznych!!!");
                return false;
            }

            foreach (var linia in liniaStala.Wierzcholki)
            {
                Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Sprawdzana linia:  Wierzcholki: {linia.X},{linia.Y} 🔹🔹🔹🔹🔹🔹");
            }

            if (liniaStala == null)
            {
                Console.WriteLine("❌ Nadal nie znaleziono poprawnej linii słupka (brak dwóch różnych punktów lub pionowej linii).");
                return false;
            }

            // 🔹 Określ orientację
            bool pionowy = Math.Abs(liniaStala.Wierzcholki[0].X - liniaStala.Wierzcholki[1].X) < 0.01;
            bool poziomy = Math.Abs(liniaStala.Wierzcholki[0].Y - liniaStala.Wierzcholki[1].Y) < 0.01;

            var orientacja = pionowy ? "Pionowa" : poziomy ? "Pozioma" : "Skośna";
            Console.WriteLine($"📏 Rozpoznano linię: {orientacja} Ilość linii stycznych: {styczneLinie.Count()}");

            // 🔹 Oblicz kąt
            var katSzukaj = ObliczKatLinii(liniaStala.Wierzcholki);
            Console.WriteLine($"📐 Kąt słupka stałego: {katSzukaj:F2}° X0:{liniaStala.Wierzcholki[0].X} Y0:{liniaStala.Wierzcholki[0].Y} X1:{liniaStala.Wierzcholki[1].X} Y1:{liniaStala.Wierzcholki[1].Y}");

            generator.RowIdModelu = generator.MVCKonfModelu.KonfSystem.FirstOrDefault().RowId;// Pobieram RowIdModelu z konfiguracji systemu

            List<XPoint> liniaStalaWierzcholki = new List<XPoint>
                {
                    new XPoint { X = liniaStala.Wierzcholki[0].X, Y = liniaStala.Wierzcholki[0].Y },
                    new XPoint { X = liniaStala.Wierzcholki[1].X, Y = liniaStala.Wierzcholki[1].Y }
                };

            // 🔹 Wyszukaj najlepszego sąsiada
            var najlepszySasiadA = sasiedzi
                .Where(s =>
                    s.WybranyTyp != "Słupek ruchomy" && (s.WystepujeGora || s.WystepujeLewa))
                .FirstOrDefault();

            var najlepszySasiadB = sasiedzi
            .Where(s =>
                s.WybranyTyp != "Słupek ruchomy" && (s.WystepujeDol || s.WystepujePrawa))
            .OrderByDescending(sasiedzi => sasiedzi.WystepujeDol)
            .FirstOrDefault();

            // 🔹 Zapisz dane do stanu (jeśli znaleziono sąsiada)
            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = liniaStalaWierzcholki,
                RowIdElementu = generator.RowIdModelu,
                RowIdSasiada = najlepszySasiadA?.RowIdElementu ?? Guid.Empty,

                // 🔸 Strona A — jeśli sąsiad występuje od góry lub lewej
                RowIdSasiadaStronaA = najlepszySasiadA?.RowIdElementu ?? Guid.Empty,

                // 🔸 Strona B — jeśli sąsiad występuje od dołu lub prawej
                RowIdSasiadaStronaB = najlepszySasiadB?.RowIdElementu ?? Guid.Empty,

                RowIdRegionuSasiada = najlepszySasiadA?.IdRegionu ?? "",
                KatLinii = katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                Strona = "Środek",
                BoolElementLinia = true,
            });

            // 🔹 Aktualizacja stanu
            state.ZIndeks = generator.Zindeks;
            state.WierzcholkiWartosciNominalne = liniaStalaWierzcholki;
            generator.RuchomySlupekPoLewej = stronaLewa;
            generator.RuchomySlupekPoPrawej = stronaPrawa;
            generator.ElementLiniowy = true;

            Console.WriteLine($"✅ Rozpoczynam przekazywanie AddElements ID: {idRegion}");

            //   var regionLinia = wszystkieRegiony.
            foreach (var r in wszystkieRegiony)
            {
                Console.WriteLine($"🔹🔹🔹🔹🔹🔹 Sprawdzany region dla słupka stałego: ID: {r.Id} Wierzcholki.Count: {r.Wierzcholki.Count} X:{r.Wierzcholki[0].X} Y:{r.Wierzcholki[0].Y} TypLiniiDzielacej: {r.TypLiniiDzielacej}🔹🔹🔹🔹🔹🔹");
            }

            double tolerancjaKlikniecia = 55.0; // odległość w jednostkach np. pikselac

            var regionKlikniety = wszystkieRegiony
             .Select(r => new
             {
                 Region = r,
                 Odleglosc = OdlegloscPunktuOdOdcinka(
                     klikX, klikY,
                     r.Wierzcholki[0].X, r.Wierzcholki[0].Y,
                     r.Wierzcholki[1].X, r.Wierzcholki[1].Y)
             })
             .OrderBy(x => x.Odleglosc)
             .FirstOrDefault(x => x.Odleglosc < tolerancjaKlikniecia)?.Region;

            if (regionKlikniety != null)
            {
                generator.AddElements(
                    new List<ShapeRegion> { regionKlikniety },
                    idRegion,
                    _generatorStates,
                    _regionsDualRama,
                    state.ListaKwadratow
                );
            }

            Console.WriteLine($"📐📐📐 Słupek stały zakończony pomyślnie 📐📐📐");

        }

        //--------------------------------------------------- Obsługa skrzydła --------------------------------------------------
        if (SelectedModelType.Trim() == "Skrzydło" || SelectedModelType.Trim() == "Skrzydło z słupkiem ruchomym")
        {
            var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);
            linieDzielace = wybranyRegionSkrzydlo?.TypLiniiDzielacej ?? "Brak";

            if (wybranyRegionSkrzydlo != null)
            {
                var regionPointsSkrzydlo = wybranyRegionSkrzydlo.Wierzcholki;

                if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionSkrzydlo.IdRegionuPonizej ?? idRegion + "-BLAD";

                minX = regionPointsSkrzydlo.Min(p => p.X);
                maxX = regionPointsSkrzydlo.Max(p => p.X);
                minY = regionPointsSkrzydlo.Min(p => p.Y);
                maxY = regionPointsSkrzydlo.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = SelectedModelType == "Skrzydło z słupkiem ruchomym" ? 2 : 3;

                //luzy wynikahjące z przesunięcia

                // najpierw wczytujesz region i dodajesz jego dane
                var regionDoDodania = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

                if (regionDoDodania != null)
                {
                    // ✅ KOPIOWANIE punktów do regionu, na którym operuje AddElements
                    regionDoDodania.Wierzcholki = WierzcholkiWartosciNominalne
                        .Select(p => new XPoint { X = p.X, Y = p.Y })
                        .ToList();

                    // ✅ Najpierw przesuń punkty
                    await WyliczObszarSkrzydla(
                        state,
                        przesLewo, przesPrawo,
                        przesGora, przesDol,
                        stronaLewa, stronaPrawa,
                        generator, regionDoDodania
                    );
                    // 4. Zapisz do stanu
                    state.ZIndeks = generator.Zindeks;
                    state.Wierzcholki = regionDoDodania.Wierzcholki;
                    state.WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne;

                    generator.RuchomySlupekPoLewej = stronaLewa;
                    generator.RuchomySlupekPoPrawej = stronaPrawa;

                    // 5. Dodaj elementy
                    generator.AddElements(new List<ShapeRegion> { regionDoDodania }, idRegion, _generatorStates, _regionsSkrzydlo, state.ListaKwadratow);
                }
                else
                {
                    Console.WriteLine($"❌ Nie znaleziono regionu skrzydła o ID: {idRegion}");

                }

            }
            else
            {
                Console.WriteLine($"📐📐📐 wybranyRegionSkrzydlo == null");
            }
        }

        //   Console.WriteLine($"✅ ElementyRamyRysowane.Count: {generator.ElementyRamyRysowane.Count}");

        if (generator.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine("❌ Brak elementów do rysowania!");
            return false;
        }

        // Console.WriteLine($"📦📦📦 Generowanie elementów ListaKwadratow: {state.ListaKwadratow.Count}.");

        // Console.WriteLine($"📦📦📦 Dodano elementy do regionu {idRegion} o typie {SelectedModelType}. przesLewo:{przesLewo}, przesPrawo:{przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol} 📦📦📦");
        // Zapis do słownika i aktualizacja listy
        _ksztaltyNaRegion[idRegion + "-" + Guid.NewGuid().ToString()] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        Console.WriteLine($"📦📦📦 Generowanie elementów zarejetrowano ilość ksztalty: {ksztalty.Count}.");

        // string idGenerator = $"{idRegion}_{Guid.NewGuid()}";

        // // Zapisz stan generatora
        // _generatory[idGenerator] = generator;

        // ZapiszStanGeneratora(idGenerator, state);

        //await Task.CompletedTask;

      //  string idGenerator = $"{idRegion}_{Guid.NewGuid()}";
        state.IdRegion = $"{idRegion}_{DateTime.UtcNow.Ticks}";
        ZapiszStanGeneratora(state.IdRegion, state);

        await ApplyZoom(_currentScale);

        return true;
    }

    private static double OdlegloscPunktuOdOdcinka(double px, double py, double x1, double y1, double x2, double y2)
    {
        double A = px - x1;
        double B = py - y1;
        double C = x2 - x1;
        double D = y2 - y1;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = len_sq != 0 ? dot / len_sq : -1;

        double najblizszyX, najblizszyY;

        if (param < 0)
        {
            najblizszyX = x1;
            najblizszyY = y1;
        }
        else if (param > 1)
        {
            najblizszyX = x2;
            najblizszyY = y2;
        }
        else
        {
            najblizszyX = x1 + param * C;
            najblizszyY = y1 + param * D;
        }

        double dx = px - najblizszyX;
        double dy = py - najblizszyY;
        return Math.Sqrt(dx * dx + dy * dy);
    }


    private static bool CzyPunktyRowneSlupek(XPoint p1, XPoint p2, double epsilon = 0.001)
    {
        return Math.Abs(p1.X - p2.X) < epsilon && Math.Abs(p1.Y - p2.Y) < epsilon;
    }


    private async Task<ShapeRegion> WyliczObszarSkrzydla(
        GeneratorState state,
        double przesLewo, double przesPrawo, double przesGora, double przesDol,
        bool stronaLewa, bool stronaPrawa,
        Generator generator,
        ShapeRegion _regionsSkrzydlo)
    {
        if (_regionsSkrzydlo == null)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla -> Nie znaleziono regionu o podanym ID.");
            return null;
        }

        var regionPointsSkrzydlo = _regionsSkrzydlo.Wierzcholki;

        if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla -> Region ma za mało punktów.");
            return null;
        }

        // 🔹 Oblicz bounding box
        double minX = regionPointsSkrzydlo.Min(p => p.X);
        double maxX = regionPointsSkrzydlo.Max(p => p.X);
        double minY = regionPointsSkrzydlo.Min(p => p.Y);
        double maxY = regionPointsSkrzydlo.Max(p => p.Y);

        // 🔹 Pobierz przesunięcia z boków
        foreach (var bok in state.ListaKwadratow)
        {
            var polaczenieWartosci = await PobierzPolaczenia(bok.RowIdSasiada, bok.RowIdElementu, bok.Strona ?? "NaN");
            var spolaczenieStrona = polaczenieWartosci.FirstOrDefault();

            double przesY = spolaczenieStrona != null
                ? Math.Abs(spolaczenieStrona.PrzesuniecieY)
                : 0;

            Console.WriteLine($"📦 WyliczObszarSkrzydla -> Sprawdzam bok: {bok.RowIdElementu}, Strona: {bok.Strona}, przesY: {przesY}");

            switch (bok.Strona.ToLower())
            {
                case "lewa": przesLewo = przesY; break;
                case "prawa": przesPrawo = przesY; break;
                case "góra": przesGora = przesY; break;
                case "dół": przesDol = przesY; break;
            }

            // fallback tylko gdy brak sąsiada
            if (bok.RowIdSasiada == Guid.Empty)
            {
                var konf = generator.KonfiguracjeSystemu
                    .FirstOrDefault(s => s.RowId == bok.RowIdElementu);

                if (konf != null)
                {
                    double fallback = -((konf.PoziomDol ?? 0) - (konf.PoziomOsSymetrii ?? 0));

                    Console.WriteLine($"📦 WyliczObszarSkrzydla -> bok.RowIdElementu: {bok.RowIdElementu}, fallback: {fallback}");

                    switch (bok.Strona.ToLower())
                    {
                        case "lewa": if (stronaLewa) przesLewo = fallback; break;
                        case "prawa": if (stronaPrawa) przesPrawo = fallback; break;
                        case "góra": przesGora = fallback; break;
                        case "dół": przesDol = fallback; break;
                    }
                }
            }
        }

        // 🔧 Przesuń punkty konturu — teraz po normalnych do krawędzi (obsługuje trapezy)
        var nowePunkty = new List<XPoint>();

        for (int i = 0; i < regionPointsSkrzydlo.Count; i++)
        {
            var prev = regionPointsSkrzydlo[(i - 1 + regionPointsSkrzydlo.Count) % regionPointsSkrzydlo.Count];
            var curr = regionPointsSkrzydlo[i];
            var next = regionPointsSkrzydlo[(i + 1) % regionPointsSkrzydlo.Count];

            // Wektor poprzedniej i następnej krawędzi
            var dir1 = new XPoint(curr.X - prev.X, curr.Y - prev.Y);
            var dir2 = new XPoint(next.X - curr.X, next.Y - curr.Y);

            // Normalizuj
            double len1 = Math.Sqrt(dir1.X * dir1.X + dir1.Y * dir1.Y);
            double len2 = Math.Sqrt(dir2.X * dir2.X + dir2.Y * dir2.Y);
            if (len1 < 0.0001 || len2 < 0.0001)
            {
                nowePunkty.Add(curr);
                continue;
            }
            dir1.X /= len1; dir1.Y /= len1;
            dir2.X /= len2; dir2.Y /= len2;

            // Wektory normalne (prostopadłe)
            var n1 = new XPoint(-dir1.Y, dir1.X);
            var n2 = new XPoint(-dir2.Y, dir2.X);

            // Kąty normalnych
            double kat1 = (Math.Atan2(n1.Y, n1.X) * 180.0 / Math.PI + 360) % 360;
            double kat2 = (Math.Atan2(n2.Y, n2.X) * 180.0 / Math.PI + 360) % 360;

            // Wybór przesunięcia na podstawie kierunku
            double offset1 = (kat1 >= 315 || kat1 < 45) ? przesLewo :
                             (kat1 >= 45 && kat1 < 135) ? przesGora  :
                             (kat1 >= 135 && kat1 < 225) ? przesPrawo :
                             przesDol;

            double offset2 = (kat2 >= 315 || kat2 < 45) ? przesLewo :
                             (kat2 >= 45 && kat2 < 135) ? przesGora :
                             (kat2 >= 135 && kat2 < 225) ? przesPrawo :
                             przesDol;

            // Przesuń obie linie wzdłuż ich normalnych
            var p1a = new XPoint(prev.X + n1.X * offset1, prev.Y + n1.Y * offset1);
            var p1b = new XPoint(curr.X + n1.X * offset1, curr.Y + n1.Y * offset1);

            var p2a = new XPoint(curr.X + n2.X * offset2, curr.Y + n2.Y * offset2);
            var p2b = new XPoint(next.X + n2.X * offset2, next.Y + n2.Y * offset2);

            // Oblicz przecięcie przesuniętych linii (czyli nowy wierzchołek)

            var nowy = PrzeciecieLinii(p1a, p1b, p2a, p2b);
            nowePunkty.Add(nowy ?? new XPoint(curr.X, curr.Y));
        }

        regionPointsSkrzydlo = nowePunkty;

        double minXSPRAWDZENIE = regionPointsSkrzydlo.Min(p => p.X);
        Console.WriteLine($"📦📦📦 WyliczObszarSkrzydla -> Po przesunięciu minX: {minXSPRAWDZENIE}, przesLewo: {przesLewo}, przesPrawo: {przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol}");

        // 🔹 Zaktualizuj offsety w stanie
        if (state != null && state.ListaKwadratow.Count() > 0)
        {
            state.ListaKwadratow[^1].OffsetLeft = przesLewo;
            state.ListaKwadratow[^1].OffsetRight = przesPrawo;
            state.ListaKwadratow[^1].OffsetTop = przesGora;
            state.ListaKwadratow[^1].OffsetBottom = przesDol;
        }

        _regionsSkrzydlo.Wierzcholki = regionPointsSkrzydlo;
        return _regionsSkrzydlo;
    }

    private XPoint? PrzeciecieLinii(XPoint p1, XPoint p2, XPoint p3, XPoint p4)
    {
        double A1 = p2.Y - p1.Y;
        double B1 = p1.X - p2.X;
        double C1 = A1 * p1.X + B1 * p1.Y;

        double A2 = p4.Y - p3.Y;
        double B2 = p3.X - p4.X;
        double C2 = A2 * p3.X + B2 * p3.Y;

        double det = A1 * B2 - A2 * B1;
        if (Math.Abs(det) < 0.0001)
            return null; // teraz poprawnie, bo typ jest XPoint?

        double x = (B2 * C1 - B1 * C2) / det;
        double y = (A1 * C2 - A2 * C1) / det;
        return new XPoint(x, y);
    }


    private void UsunOstatniKsztaltZGeneratora(string idRegion, Generator generator)
    {
        if (string.IsNullOrWhiteSpace(idRegion))
        {
            Console.WriteLine("⚠️ UsunOstatniKsztaltZGeneratora-> IdRegion nie został podany");
            return;
        }

        if (generator?.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine($"ℹ️ UsunOstatniKsztaltZGeneratora-> Brak kształtów do usunięcia w regionie {idRegion}");
            return;
        }

        // Usuń ostatni kształt
        var ostatni = generator.ElementyRamyRysowane.Last();
        generator.ElementyRamyRysowane.Remove(ostatni);

        Console.WriteLine($"🗑️ UsunOstatniKsztaltZGeneratora-> Usunięto ostatni kształt z regionu {idRegion}");

        // Aktualizacja mapy regionów
        if (generator.ElementyRamyRysowane.Count == 0 && _ksztaltyNaRegion.ContainsKey(idRegion))
        {
            _ksztaltyNaRegion.Remove(idRegion);
            Console.WriteLine($"📭 UsunOstatniKsztaltZGeneratora-> Usunięto wpis z _ksztaltyNaRegion dla {idRegion}");
        }
        else
        {
            _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        }

        // Odświeżenie listy globalnej
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
    }

    private async Task<List<PrzesuniecieDto>> PobierzPolaczenia(Guid zewId, Guid wewId, string strona)
    {
        if (zewId == Guid.Empty || wewId == Guid.Empty || string.IsNullOrWhiteSpace(strona))
        {
            if (infoObiekt == null)
            {
                infoObiekt = new List<WyrobWymiaryOpis>();
            }

            if(string.IsNullOrWhiteSpace(strona))
            {
                strona = "NaN";
            }

            WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc, SelectedModelType ?? "", $"Nie wyszukano indesku elementu dla strony: {strona}");
            infoObiekt.Add(opisy);

            return new List<PrzesuniecieDto>();
        }

        try
        {
            Console.WriteLine($"📦 PobierzPolaczenia-> Pobieram przesunięcia zewnątrz: {zewId} wewnątrz: {wewId} strona: {strona}");

            var response = await Http.GetAsync($"api/konfpolaczenie/find-shifts/{zewId}/{wewId}/{strona}");

            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<PrzesuniecieDto>>();

                if(lista != null && lista.Count() > 0)
                {
                    foreach (var item in lista)
                    {
                        Console.WriteLine($"📦 PobierzPolaczenia-> : PrzesuniecieX: {item.PrzesuniecieX}, PrzesuniecieY: {item.PrzesuniecieY}");
                    }
                }

                return lista ?? new List<PrzesuniecieDto>();
            }
            else
            {
                Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {ex.Message}");
        }

        return new List<PrzesuniecieDto>();
    }


    private async Task<List<KonfPolaczenie>> PobierzPolaczeniaAll(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 Pobieram dane połączeń z: {zewId} w: {wewId} strona: {strona}");
            var response = await Http.GetAsync($"api/konfpolaczenie/find-by-elements-all/{zewId}/{wewId}");
            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>();
                return lista ?? new List<KonfPolaczenie>();
            }
            else
            {
                Console.WriteLine($"❌ Błąd podczas pobierania połączeń: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd podczas pobierania połączenia: {ex.Message}");
        }

        return new List<KonfPolaczenie>();
    }

    public static string StronaSzukaj(double kat, List<XPoint> linia, double regionMinY, double regionMaxY, double regionMinX, double regionMaxX)
    {
        // Normalizacja kąta
        kat = (kat + 360) % 360;

        // Przybliżenie kąta do jednej z głównych orientacji
        int katZnormalizowany;
        if (kat >= 315 || kat < 45)
            katZnormalizowany = 0;
        else if (kat >= 45 && kat < 135)
            katZnormalizowany = 90;
        else if (kat >= 135 && kat < 225)
            katZnormalizowany = 180;
        else
            katZnormalizowany = 270;

        string strona = "";
        double tol = 0.15; // zwiększona tolerancja

        double x1 = linia[0].X;
        double y1 = linia[0].Y;
        double x2 = linia[1].X;
        double y2 = linia[1].Y;

        if (katZnormalizowany == 0 || katZnormalizowany == 180)
        {
            // Linie poziome – porównujemy po Y
            if (Math.Abs(y1 - regionMinY) < tol || Math.Abs(y2 - regionMinY) < tol)
                strona = "góra";
            else if (Math.Abs(y1 - regionMaxY) < tol || Math.Abs(y2 - regionMaxY) < tol)
                strona = "dół";
        }
        else if (katZnormalizowany == 90 || katZnormalizowany == 270)
        {
            // Linie pionowe – porównujemy po X
            if (Math.Abs(x1 - regionMinX) < tol || Math.Abs(x2 - regionMinX) < tol)
                strona = "lewa";
            else if (Math.Abs(x1 - regionMaxX) < tol || Math.Abs(x2 - regionMaxX) < tol)
                strona = "prawa";
        }

        Console.WriteLine($"📐 StronaSzukaj → kat={kat:F1}° ({katZnormalizowany}°) → strona={strona} (X1={x1:F2}, X2={x2:F2}, minX={regionMinX:F2}, maxX={regionMaxX:F2})");
        return strona;
    }


    public static int ObliczKatLinii(List<XPoint> linia)
    {
        if (linia == null || linia.Count != 2)
            return 0;

        var p1 = linia[0];
        var p2 = linia[1];

        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;

        double angleRadians = Math.Atan2(dy, dx); // uwzględnia znak
        double angleDegrees = angleRadians * (180.0 / Math.PI);

        if (angleDegrees < 0)
            angleDegrees += 360; // zakres 0–360

        Console.WriteLine($"📐 ObliczKatLinii -> Kąt linii między punktami ({p1.X},{p1.Y}) i ({p2.X},{p2.Y}) wynosi {angleDegrees}°");

        return (int)Math.Round(angleDegrees);
    }

    public static Guid ZnajdzKonfiguracjeDlaLinii(
        List<XPoint> linia,
        GeneratorState stan,
        bool slRuchStroLewa,
        bool slRuchStroPrawa,
        string obecnyRegionId,
        string typSlupka)
    {
        if (linia == null || linia.Count != 2)
            return Guid.Empty;

        var p1 = linia[0];
        var p2 = linia[1];

        // bool jestPionowa = Math.Abs(p1.X - p2.X) < 0.01;
        // bool jestPozioma = Math.Abs(p1.Y - p2.Y) < 0.01;


        // Oblicz orientację linii
        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;
        double katLinii = Math.Atan2(dy, dx) * 180.0 / Math.PI;
        katLinii = (katLinii + 360) % 180;

        // Ustal tolerancję kierunku
        const double katTolerancja = 15.0;
        bool jestPionowa = Math.Abs(katLinii - 90.0) <= katTolerancja;
        bool jestPozioma = katLinii <= katTolerancja || Math.Abs(katLinii - 180.0) <= katTolerancja;

        double minX = stan.WierzcholkiWartosciNominalne.Min(v => v.X);
        double maxX = stan.WierzcholkiWartosciNominalne.Max(v => v.X);
        double minY = stan.WierzcholkiWartosciNominalne.Min(v => v.Y);
        double maxY = stan.WierzcholkiWartosciNominalne.Max(v => v.Y);
        double tolerancja = 1.0; // np. 1 mm


        if (stan?.MVCKonfModelu?.KonfSystem == null)
            return Guid.Empty;

        string slLewa = slRuchStroLewa ? typSlupka : "";
        string slPrawa = slRuchStroPrawa ? typSlupka : "";

        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> typ: {typSlupka}" +
                          $" jestPionowa: {jestPionowa}, jestPozioma: {jestPozioma}, " +
                          $"slLewa: {slLewa}, slPrawa: {slPrawa}");

        Guid znaleziony = Guid.Empty;

        // 1️⃣ Najpierw próba z uwzględnieniem słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> typ: {konf.Typ} - wartość w pętli");

            if (jestPionowa )
            {
                if (Math.Abs(p1.X - minX) < tolerancja && konf.WystepujeLewa &&
                    !string.IsNullOrEmpty(slLewa) && konf.Typ.Contains(slLewa))
                {
                    Console.WriteLine($"✅ [Słupkowy] Lewa -> {konf.RowId} Typ:{konf.Typ} Nazwa:{konf.Nazwa}");
                    return konf.RowId;
                }

                if (Math.Abs(p1.X - maxX) < tolerancja && konf.WystepujePrawa &&
                    !string.IsNullOrEmpty(slPrawa) && konf.Typ.Contains(slPrawa))
                {
                    Console.WriteLine($"✅ [Słupkowy] Prawa -> {konf.RowId} Typ:{konf.Typ} Nazwa:{konf.Nazwa}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Słupkowy] Góra -> {konf.RowId} Typ:{konf.Typ} Nazwa:{konf.Nazwa}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Słupkowy] Dół -> {konf.RowId} Typ:{konf.Typ} Nazwa:{konf.Nazwa}");
                    return konf.RowId;
                }
            }
        }

        // 2️⃣ Jeśli nie znaleziono — próba bez słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa &&
                    (string.IsNullOrEmpty(slLewa) || !konf.Typ.Contains(typSlupka)))
                {
                    Console.WriteLine($"✅ [Bez słupka] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.X > 85 && konf.WystepujePrawa &&
                    (string.IsNullOrEmpty(slPrawa) || !konf.Typ.Contains(typSlupka)))
                {
                    Console.WriteLine($"✅ [Bez słupka] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Bez słupka] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Bez słupka] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        // 3️⃣ Jeśli dalej nic — bierzemy pierwszą pasującą stronę
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa)
                {
                    Console.WriteLine($"✅ [Fallback] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.X > 85 && konf.WystepujePrawa)
                {
                    Console.WriteLine($"✅ [Fallback] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Fallback] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Fallback] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        Console.WriteLine("❌ ZnajdzKonfiguracjeDlaLinii -> Nie znaleziono konfiguracji.");
        return znaleziony;
    }

    public async Task<List<SasiadInfo>> ZnajdzSasiada(
        List<XPoint> linia,
        List<GeneratorState> wszystkieStany,
        int kat,
        bool ruchomySlupekPoLewej,
        bool ruchomySlupekPoPrawej,
        string obecnyRegionId,
        int id,
        bool czyModelMaSlupekRuchomy,
        bool szukajNieRownoleglych,
        double tolerancja)
    {
        var pasujace = new List<SasiadInfo>();

        // 🔹 Walidacja wejścia
        if (linia == null || linia.Count != 2)
        {
            return new List<SasiadInfo>
        {
            new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = "",
                ZIndeks = -1,
                MaSlupekRuchomy = false,
                Id = 0,
                WybranyTyp = "LINIA NIE SPEŁNIA WARUNKÓW"
            }
        };
        }

        var p1 = linia[0];
        var p2 = linia[1];

        // Obliczamy różnicę współrzędnych
        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;

        // Kąt linii względem osi X
        double katLinii = Math.Atan2(dy, dx) * 180.0 / Math.PI;
        katLinii = (katLinii + 360) % 180; // normalizacja do 0–180°

        double tmpkat = (kat + 360) % 360;

        int katLiniiPionPoziom;

        if (tmpkat >= 0 && tmpkat < 45)
        {
            katLiniiPionPoziom = 0;
        }
        else if (tmpkat >= 45 && tmpkat < 135)
        {
            katLiniiPionPoziom = 90;
        }
        else if (tmpkat >= 135 && tmpkat < 225)
        {
            katLiniiPionPoziom = 180;
        }
        else if (tmpkat >= 225 && tmpkat < 315)
        {
            katLiniiPionPoziom = 270;
        }
        else // kat >= 315
        {
            katLiniiPionPoziom = 0;
        }

        Console.WriteLine($"📐 ZnajdzSasiada -> Kąt linii: {katLinii}°, Zaokrąglony do pion/poziom: {katLiniiPionPoziom}° kat: {kat}");

        const double katTolerancja = 15.0; // możesz dopasować np. 10–20 stopni

        bool jestPionowa = Math.Abs(katLinii - 90.0) <= katTolerancja;
        bool jestPozioma = katLinii <= katTolerancja || Math.Abs(katLinii - 180.0) <= katTolerancja;


        var ileModelMaSlupkowStalych = wszystkieStany.SelectMany(s => s.ListaKwadratow.FindAll(x=>x.BoolElementLinia)).Count();

        Console.WriteLine($"🔍 ZnajdzSasiada -> Szukam sąsiada dla linii o kącie {kat}° w regionie {obecnyRegionId} oraz wszystkieStany.Count: {wszystkieStany.Count()} ileModelMaSlupkowStalych: {ileModelMaSlupkowStalych} ruchomySlupekPoLewej: {ruchomySlupekPoLewej} ruchomySlupekPoPrawej: {ruchomySlupekPoPrawej}");


        var stanyDoPrzeszukania = wszystkieStany
            .Where(s => s.WierzcholkiWartosciNominalne != null && s.Id != id)// sprwdź słupki stałe  && !s.IdRegion.Contains(obecnyRegionId)
            .OrderByDescending(s => s.Id)
            .ToList();

        foreach (var stan in stanyDoPrzeszukania)
        {
            Console.WriteLine($"🔍 ZnajdzSasiada -> Wyszuakne stanyDoPrzeszukania pozycja kąt: {kat} IdRegion: {stan.IdRegion}, Id: {stan.Id} ElementLiniowy: {stan.ElementLiniowy} WybranyModel.NazwaKonfiguracji: {stan.WybranyModel.NazwaKonfiguracji}");
        } 

        Console.WriteLine($"🔍 ZnajdzSasiada -> Szukam stanyDoPrzeszukania.Count: {stanyDoPrzeszukania.Count()} ileModelMaSlupkowStalych: {ileModelMaSlupkowStalych}");

        foreach (var stan in stanyDoPrzeszukania)
        {

            Console.WriteLine($"🔍 ZnajdzSasiada -> Sprawdzam stan IdRegion: {stan.IdRegion}, Id: {stan.Id} ElementLiniowy: {stan.ElementLiniowy}");

            var wierzcholki = stan.WierzcholkiWartosciNominalne!;
            var linieStanu = ExtractLinesFromSquare(wierzcholki);

            double stanMinX = wierzcholki.Min(p => p.X);
            double stanMaxX = wierzcholki.Max(p => p.X);
            double stanMinY = wierzcholki.Min(p => p.Y);
            double stanMaxY = wierzcholki.Max(p => p.Y);

            foreach (var innaLinia in linieStanu)
            {
                if (innaLinia.Count != 2) continue;
                var q1 = innaLinia[0];
                var q2 = innaLinia[1];

                // 🔹 Obliczamy kąt sąsiada
                double katSasiada = Math.Atan2(q2.Y - q1.Y, q2.X - q1.X) * 180.0 / Math.PI;
                double katNormalny = ((katSasiada % 180) + 180) % 180;
                double katLinia = ((kat % 180) + 180) % 180;

                Console.WriteLine($"🔍 ZnajdzSasiada -> #1 ({katNormalny} - {katLinia}) < 44.0");
                // 🔹 Odrzuć równoległe jeśli szukamy nie równoległych
                if (szukajNieRownoleglych && Math.Abs(katNormalny - katLinia) < 44.0)
                    continue;

                bool przecinajaSie = false;
                bool nakladaja = false;

                if (szukajNieRownoleglych)
                {
                    // ✅ Szukamy tylko przecięć
                    przecinajaSie = CzyPrzecinajaSie(p1, p2, q1, q2, tolerancja);
                    if (!przecinajaSie)
                        continue;

                    Console.WriteLine($"🔍 ZnajdzSasiada -> #1 przecinajaSie z regionem {stan.IdRegion} katSasiada: {katSasiada} katNormalny: {katNormalny} katLinia: {katLinia}");
                }
                else
                {
                    // ✅ Klasyczny przypadek – równoległe linie
                    nakladaja = CzyNakladajaSieDowolne(p1, p2, q1, q2, tolerancja, kat);
                    if (!nakladaja)
                        continue;

                    Console.WriteLine($"🔍 ZnajdzSasiada -> #1 nakładają się z regionem {stan.IdRegion} katSasiada: {katSasiada} katNormalny: {katNormalny} katLinia: {katLinia} jestPionowa: {jestPionowa} szukajNieRownoleglych: {szukajNieRownoleglych}");
                }

                // 🔹 Jeśli doszliśmy tutaj, to mamy sąsiada
                var konfLista = stan.MVCKonfModelu?.KonfSystem;
                if (konfLista == null)
                {
                    Console.WriteLine($"🔍 ZnajdzSasiada -> #1 Brak konfiguracji systemu dla stanu IdRegion: {stan.IdRegion}, Id: {stan.Id}");
                    continue; 
                }

                foreach (var konf in konfLista)
                {
                    if (jestPionowa)
                    {
                        double srodekRegionuX = (stanMinX + stanMaxX) / 2;

                        if (szukajNieRownoleglych)
                        {
                            // 👇 W trybie przecinających dodajemy niezależnie od X
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada, 
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });

                            Console.WriteLine($"✅ Dodano przecinającego sąsiada pionowego w regionie {stan.IdRegion}");
                        }
                        else
                        {
                            // 🔹 Standardowe sprawdzenie równoległych
                            if (katLiniiPionPoziom == 270 && konf.WystepujeLewa)
                            {
                                pasujace.Add(new SasiadInfo
                                {
                                    RowIdElementu = konf.RowId,
                                    IdRegionu = stan.IdRegion,
                                    ZIndeks = stan.ZIndeks,
                                    MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                    Id = stan.Id,
                                    WybranyTyp = konf.Typ ?? "BRAK",
                                    KatSasiada = (int)katSasiada,
                                    WystepujeGora = konf.WystepujeGora,
                                    WystepujeDol = konf.WystepujeDol,
                                    WystepujeLewa = konf.WystepujeLewa,
                                    WystepujePrawa = konf.WystepujePrawa
                                });
                            }

                            Console.WriteLine($"🔍 ZnajdzSasiada #1 -> Sprawdzam prawą stronę p1.X: {p1.X} stanMaxX: {stanMaxX} tolerancja: {tolerancja} konf.WystepujePrawa: {konf.WystepujePrawa} katNormalny: {katNormalny} katLinia: {katLinia}");

                            if (katLiniiPionPoziom == 90 && konf.WystepujePrawa)
                            {
                                pasujace.Add(new SasiadInfo
                                {
                                    RowIdElementu = konf.RowId,
                                    IdRegionu = stan.IdRegion,
                                    ZIndeks = stan.ZIndeks,
                                    MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                    Id = stan.Id,
                                    WybranyTyp = konf.Typ ?? "BRAK",
                                    KatSasiada = (int)katSasiada,
                                    WystepujeGora = konf.WystepujeGora,
                                    WystepujeDol = konf.WystepujeDol,
                                    WystepujeLewa = konf.WystepujeLewa,
                                    WystepujePrawa = konf.WystepujePrawa
                                });
                            }
                        }
                    }
                    else if (jestPozioma)
                    {
                        if (szukajNieRownoleglych)
                        {
                            // 👇 W trybie przecinających dodajemy niezależnie od Y
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK",
                                KatSasiada = (int)katSasiada,
                                WystepujeGora = konf.WystepujeGora,
                                WystepujeDol = konf.WystepujeDol,
                                WystepujeLewa = konf.WystepujeLewa,
                                WystepujePrawa = konf.WystepujePrawa
                            });
                            Console.WriteLine($"✅ Dodano przecinającego sąsiada poziomego w regionie {stan.IdRegion}");
                        }
                        else
                        {
                            // 🔹 Standardowe sprawdzenie równoległych
                            if (katLiniiPionPoziom == 0 && konf.WystepujeGora)
                            {
                                pasujace.Add(new SasiadInfo
                                {
                                    RowIdElementu = konf.RowId,
                                    IdRegionu = stan.IdRegion,
                                    ZIndeks = stan.ZIndeks,
                                    MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                    Id = stan.Id,
                                    WybranyTyp = konf.Typ ?? "BRAK",
                                    KatSasiada = (int)katSasiada,
                                    WystepujeGora = konf.WystepujeGora,
                                    WystepujeDol = konf.WystepujeDol,
                                    WystepujeLewa = konf.WystepujeLewa,
                                    WystepujePrawa = konf.WystepujePrawa
                                });
                            }

                            if (katLiniiPionPoziom == 180 && konf.WystepujeDol)
                            {
                                pasujace.Add(new SasiadInfo
                                {
                                    RowIdElementu = konf.RowId,
                                    IdRegionu = stan.IdRegion,
                                    ZIndeks = stan.ZIndeks,
                                    MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                    Id = stan.Id,
                                    WybranyTyp = konf.Typ ?? "BRAK",
                                    KatSasiada = (int)katSasiada,
                                    WystepujeGora = konf.WystepujeGora,
                                    WystepujeDol = konf.WystepujeDol,
                                    WystepujeLewa = konf.WystepujeLewa,
                                    WystepujePrawa = konf.WystepujePrawa
                                });
                            }
                        }
                    }
                }
            }

        }

        // 🔹 Zwracanie wyniku


        List<SasiadInfo> wynik = pasujace.OrderBy(p => p.Id).ToList();

        if (wynik.Count > 1 && wynik.Any(x => x.ZIndeks == 1) && wynik.Any(x => x.KatSasiada == kat))
        {
            // 🔹 Wyszukiwanie pierwszeństwo słupek stały ZIndeks == 1
            var wybrany = wynik.First(x => x.ZIndeks == 1);
            wynik = new List<SasiadInfo> { wybrany };
            Console.WriteLine($"🔍 ZnajdzSasiada -> Wybrano sąsiada ze ZIndeks == 1 w regionie {wybrany.IdRegionu} Kąt: {kat}");
        }

        if (!wynik.Any())
        {
            wynik.Add(new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = Guid.Empty.ToString(),
                ZIndeks = -1,
                Id = 0,
                MaSlupekRuchomy = false,
                WybranyTyp = "BRAK-PASUJACEGO-SASIADA",
                KatSasiada = kat
            });

            if(SelectedModelType != "Rama")//Rama nie ma sąsiadów
            {
                if (infoObiekt == null)
                {
                    infoObiekt = new List<WyrobWymiaryOpis>();
                }

                WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(constWlasciwosciOkna.Szerokosc, constWlasciwosciOkna.Wysokosc, SelectedModelType ?? "", $"Nie wyszukano połączenia dla ementów w pozycji (kąt elementu): {kat}°");
                infoObiekt.Add(opisy);
            }

        }

        foreach (var sasiad in wynik)
        {
            Console.WriteLine($"🔍 ZnajdzSasiada -> Wynik: Znaleziono sąsiada: IdRegionu={sasiad.IdRegionu}, RowId={sasiad.RowIdElementu}, ZIndeks={sasiad.ZIndeks}, Typ={sasiad.WybranyTyp} Kąt sąsiada: {sasiad.KatSasiada} sasiad.WystepujeGora:{sasiad.WystepujeGora} sasiad.WystepujeDol: {sasiad.WystepujeDol}");
        }

        await Task.CompletedTask;

        return wynik;

    }

    private bool CzyPunktyRowne(XPoint p1, XPoint p2, double tolerancja)
    {
        return Math.Abs(p1.X - p2.X) < tolerancja && Math.Abs(p1.Y - p2.Y) < tolerancja;
    }

    private double DlugoscWspolna(XPoint a1, XPoint a2, XPoint b1, XPoint b2)
    {
        if (Math.Abs(a1.X - a2.X) < 0.01) // pionowa
        {
            var minY1 = Math.Min(a1.Y, a2.Y);
            var maxY1 = Math.Max(a1.Y, a2.Y);
            var minY2 = Math.Min(b1.Y, b2.Y);
            var maxY2 = Math.Max(b1.Y, b2.Y);
            return Math.Max(0, Math.Min(maxY1, maxY2) - Math.Max(minY1, minY2));
        }
        else if (Math.Abs(a1.Y - a2.Y) < 0.01) // pozioma
        {
            var minX1 = Math.Min(a1.X, a2.X);
            var maxX1 = Math.Max(a1.X, a2.X);
            var minX2 = Math.Min(b1.X, b2.X);
            var maxX2 = Math.Max(b1.X, b2.X);
            return Math.Max(0, Math.Min(maxX1, maxX2) - Math.Max(minX1, minX2));
        }

        return 0;
    }

    // 🔹 Sprawdza, czy dwie linie się przecinają
    private bool CzyPrzecinajaSie(XPoint p1, XPoint p2, XPoint q1, XPoint q2, double tolerancja)
    {
        double d1 = ObliczKierunek(q1, q2, p1);
        double d2 = ObliczKierunek(q1, q2, p2);
        double d3 = ObliczKierunek(p1, p2, q1);
        double d4 = ObliczKierunek(p1, p2, q2);

        // 🔹 Klasyczne przecięcie (krzyżowanie się)
        bool krzyzujaSie = ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                           ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0));

        if (krzyzujaSie)
            return true;

        // 🔹 Dodatkowo: traktujemy jako "przecinają się" jeśli styka się końcami lub jest w tolerancji
        if (Math.Abs(d1) < tolerancja && PunktNaOdcinku(p1, q1, q2, tolerancja)) return true;
        if (Math.Abs(d2) < tolerancja && PunktNaOdcinku(p2, q1, q2, tolerancja)) return true;
        if (Math.Abs(d3) < tolerancja && PunktNaOdcinku(q1, p1, p2, tolerancja)) return true;
        if (Math.Abs(d4) < tolerancja && PunktNaOdcinku(q2, p1, p2, tolerancja)) return true;

        // 🔹 Nowość: jeśli którykolwiek koniec jest "blisko" drugiego odcinka, też uznajemy za styczność
        if (OdlegloscPunktuOdOdcinka(p1, q1, q2) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(p2, q1, q2) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(q1, p1, p2) < tolerancja) return true;
        if (OdlegloscPunktuOdOdcinka(q2, p1, p2) < tolerancja) return true;

        return false;
    }

    // 🔹 Pomocnicza funkcja do obliczania odległości punktu od odcinka
    private double OdlegloscPunktuOdOdcinka(XPoint p, XPoint a, XPoint b)
    {
        double A = p.X - a.X;
        double B = p.Y - a.Y;
        double C = b.X - a.X;
        double D = b.Y - a.Y;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = (len_sq != 0) ? dot / len_sq : -1;

        double xx, yy;

        if (param < 0)
        {
            xx = a.X;
            yy = a.Y;
        }
        else if (param > 1)
        {
            xx = b.X;
            yy = b.Y;
        }
        else
        {
            xx = a.X + param * C;
            yy = a.Y + param * D;
        }

        double dx = p.X - xx;
        double dy = p.Y - yy;
        return Math.Sqrt(dx * dx + dy * dy);
    }


    // 🔹 Pomocnicza funkcja obliczająca kierunek (iloczyn wektorowy)
    private double ObliczKierunek(XPoint a, XPoint b, XPoint c)
    {
        return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);
    }

    // 🔹 Sprawdza, czy punkt leży na odcinku
    private bool PunktNaOdcinku(XPoint p, XPoint a, XPoint b, double tolerancja)
    {
        return p.X <= Math.Max(a.X, b.X) + tolerancja &&
               p.X >= Math.Min(a.X, b.X) - tolerancja &&
               p.Y <= Math.Max(a.Y, b.Y) + tolerancja &&
               p.Y >= Math.Min(a.Y, b.Y) - tolerancja;
    }

    private static bool CzyNakladajaSieDowolne(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol = 0.02, int kat = 0)
    {
        // 🔹 Wektor kierunkowy pierwszej linii
        double dxA = a2.X - a1.X;
        double dyA = a2.Y - a1.Y;
        double dlugoscA = Math.Sqrt(dxA * dxA + dyA * dyA);

        // 🔹 Normalizacja
        double ux = dxA / dlugoscA;
        double uy = dyA / dlugoscA;

        // 🔹 Wektor kierunkowy drugiej linii
        double dxB = b2.X - b1.X;
        double dyB = b2.Y - b1.Y;
        double dlugoscB = Math.Sqrt(dxB * dxB + dyB * dyB);

        // 🔹 Oblicz kąt między liniami (równoległość)
        double cosTheta = (dxA * dxB + dyA * dyB) / (dlugoscA * dlugoscB);
        double katMiedzy = Math.Acos(Math.Min(1, Math.Max(-1, cosTheta))) * 180.0 / Math.PI;

        // Jeśli linie są zbyt skośne względem siebie → nie traktuj jako nakładające się
        if (katMiedzy > 10.0 && katMiedzy < 170.0)
        {
            Console.WriteLine($"🚫 Linie nie są równoległe (Δkat={katMiedzy:F1}°)");
            return false;
        }

        // 🔹 Rzutujemy punkty B na kierunek linii A (sprawdzamy nakładanie się)
        double aMin = 0;
        double aMax = dlugoscA;

        // odległość między punktami wzdłuż linii A
        double projB1 = ((b1.X - a1.X) * ux + (b1.Y - a1.Y) * uy);
        double projB2 = ((b2.X - a1.X) * ux + (b2.Y - a1.Y) * uy);
        double bMin = Math.Min(projB1, projB2);
        double bMax = Math.Max(projB1, projB2);

        // 🔹 Odległość prostopadła między liniami (czy leżą blisko)
        double odleglosc = Math.Abs((b1.X - a1.X) * (-uy) + (b1.Y - a1.Y) * ux);
        if (odleglosc > tol * 10) // większa tolerancja, bo kąty skośne
        {
            Console.WriteLine($"🚫 Linie równoległe, ale odległość={odleglosc:F3} > tol={tol}");
            return false;
        }

        // 🔹 Sprawdź nakładanie projekcji
        bool nakladaja = aMax >= bMin - tol && bMax >= aMin - tol;

        Console.WriteLine($"🔍 CzyNakladajaSieDowolne -> Δkat={katMiedzy:F1}°, odległość={odleglosc:F3}, nakładają={nakladaja}");
        return nakladaja;
    }

    private readonly struct Vector2D
    {
        public readonly double X;
        public readonly double Y;

        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }

        public double Length => Math.Sqrt(X * X + Y * Y);

        public Vector2D Normalize()
        {
            var len = Length;
            return len > 0 ? new Vector2D(X / len, Y / len) : new Vector2D(0, 0);
        }

        public static double Cross(Vector2D a, Vector2D b) => a.X * b.Y - a.Y * b.X;

        public double Dot(Vector2D other) => X * other.X + Y * other.Y;
    }


    public static List<List<XPoint>> ExtractLinesFromSquare(List<XPoint> wierzcholki)
    {
        var linie = new List<List<XPoint>>();

        if (wierzcholki == null || wierzcholki.Count < 2)
            return linie; // brak linii

        for (int i = 0; i < wierzcholki.Count; i++)
        {
            var start = wierzcholki[i];
            var end = (i == wierzcholki.Count - 1) ? wierzcholki[0] : wierzcholki[i + 1]; // zamknięcie figury

            linie.Add(new List<XPoint> { start, end });
        }

        return linie;
    }

    private void ZapiszStanGeneratora(string regionId, GeneratorState state)
    {
        // nie tworzymy nowego klucza – nadpisujemy stary
        state.IdRegion = regionId;

        _generatorStates[regionId] = state;

        Console.WriteLine($"💾 Nadpisano stan generatora dla regionu: {regionId}");
        Console.WriteLine($"📦 Liczba wpisów w _generatorStates: {_generatorStates.Count}");

        _ = InvokeAsync(StateHasChanged);
    }


    private GeneratorState? PobierzGenerator(string regionId)
    {
        if (_generatorStates.TryGetValue(regionId, out var state))
            return state;

        return null;
    }


    private bool CzyPunktLezyNaKrawedzi(XPoint punkt, List<XPoint> wielokat)
    {
        const double eps = 0.001; // tolerancja błędu
        for (int i = 0; i < wielokat.Count; i++)
        {
            var a = wielokat[i];
            var b = wielokat[(i + 1) % wielokat.Count];

            double cross = (punkt.Y - a.Y) * (b.X - a.X) - (punkt.X - a.X) * (b.Y - a.Y);
            if (Math.Abs(cross) > eps) continue;

            double dot = (punkt.X - a.X) * (b.X - a.X) + (punkt.Y - a.Y) * (b.Y - a.Y);
            if (dot < 0) continue;

            double squaredLen = (b.X - a.X) * (b.X - a.X) + (b.Y - a.Y) * (b.Y - a.Y);
            if (dot > squaredLen) continue;

            return true;
        }
        return false;
    }


    private double Odleglosc(XPoint a, XPoint b)
    {
        return Math.Sqrt(Math.Pow(a.X - b.X, 2) + Math.Pow(a.Y - b.Y, 2));
    }

    private bool CzyPunktWNWielokacie(XPoint punkt, List<XPoint> wielokat)
    {
        int j = wielokat.Count - 1;
        bool inside = false;

        for (int i = 0; i < wielokat.Count; j = i++)
        {
            if (((wielokat[i].Y > punkt.Y) != (wielokat[j].Y > punkt.Y)) &&
                (punkt.X < (wielokat[j].X - wielokat[i].X) * (punkt.Y - wielokat[i].Y) / (wielokat[j].Y - wielokat[i].Y) + wielokat[i].X))
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private bool CzyLiniaPrzecinaRegion(List<XPoint> linia, List<XPoint> wielokat)
    {
        var a = linia[0];
        var b = linia[1];

        // 1. klasyczne przecięcie
        for (int i = 0; i < wielokat.Count; i++)
        {
            var c = wielokat[i];
            var d = wielokat[(i + 1) % wielokat.Count];

            if (CzyPrzecinajaSie(a, b, c, d, 0.02))
                return true;
        }

        // 2. jeden koniec linii wewnątrz regionu
        if (CzyPunktWNWielokacie(a, wielokat) || CzyPunktWNWielokacie(b, wielokat))
            return true;

        // 3. jeden koniec linii na krawędzi regionu
        if (CzyPunktLezyNaKrawedzi(a, wielokat) || CzyPunktLezyNaKrawedzi(b, wielokat))
            return true;

        return false;
    }

    private bool PunktNaOdcinku(XPoint p, XPoint a, XPoint b)
    {
        return p.X <= Math.Max(a.X, b.X) && p.X >= Math.Min(a.X, b.X) &&
               p.Y <= Math.Max(a.Y, b.Y) && p.Y >= Math.Min(a.Y, b.Y);
    }


    private double Kierunek(XPoint a, XPoint b, XPoint c)
    {
        return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);
    }


    private async Task GenerujElementyDlaRegionu(string idRegion, float szerokosc, float wysokosc)
    {
        if (!_generatorStates.TryGetValue(idRegion, out var state))
        {
            await GenerujObrysPozZmianieWymiarow(false);

            Console.WriteLine($"❌ Brak stanu generatora dla regionu {idRegion}, żeden model nie został dodany!");
            return;
        }
        else
        {
            await GenerujObrysPozZmianieWymiarow(false);
        }

        var generator = new Generator
        {
            //KonfiguracjeSystemu = state.PowiazaneModele,
            RowIdSystemu = state.RowIdSystemu,
            MVCKonfModelu = state.MVCKonfModelu,
            TypKsztaltu = state.WybranyKsztalt,
            EdytowanyModel = state.WybranyModel,
            ElementLiniowy = state.ElementLiniowy,
        };


        var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);
        var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

        // Sprawdź, czy region skrzydła ma linię dzielącą z ruchomym słupkiem
        bool czyRegionZawieraSlupekRuchomy = _regionsSkrzydlo?.Any(x => x.TypLiniiDzielacej == "Słupek ruchomy") == true;

        bool czyRegionZawieraSlupekStaly = _regionsDualRama?.Any(x => x.TypLiniiDzielacej == "Słupek stały") == true;

        Console.WriteLine($"✅ czyRegionZawieraSlupekStaly: {czyRegionZawieraSlupekStaly}");

        if (czyRegionZawieraSlupekRuchomy)
        {
            Console.WriteLine($"✅ GenerujElementyDlaRegionu-> Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów.");

            // Sprawdź, czy istnieje "Słupek ruchomy" w jakimkolwiek PowiazanymModelu (lista)
            bool czyZawieraSlupekRuchomyWPowiazanymModelu = StateContainer.States
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfSystem != null &&
                     state.Value.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy")
                 );


            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {
                // Sprawdź, czy istnieje "Słupek ruchomy" w pojedynczym PowiazanymModelu (np. generator)
                bool czySlupekRuchomyWPojedynczymModelu = generator.MVCKonfModelu != null &&
                    generator.MVCKonfModelu.KonfSystem != null &&
                    generator.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy");

                if (!czySlupekRuchomyWPojedynczymModelu)
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj słupek ruchomy do systemu.",
                        2.0
                    );
                    return;
                }
            }
        }

        double minX = 0, maxX = 0, minY = 0, maxY = 0;

        if (wybranyRegionDualRama != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionDualRama.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 0;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);
        }
        else if (wybranyRegionSkrzydlo != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionSkrzydlo.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 1;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion, _generatorStates, _regionsSkrzydlo, null);
        }
        else
        {
            Console.WriteLine($"❌ GenerujElementyDlaRegionu-> Nie znaleziono regionu o ID {idRegion}");
            return;
        }

        // Skalowanie i przesunięcie jeśli zmieniasz szerokość/wysokość
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }

            }
        }


        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();


        // Console.WriteLine($"✅ Wygenerowano elementy dla regionu {idRegion} po skalowaniu.");
        await Task.CompletedTask;
    }

    private async Task RenderFrame(bool calculate = true)
    {
        try
        {
            if (_context == null || _disposed)
                return;

            // W rysowaniu:
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            await _context.TranslateAsync(_offsetX, _offsetY);
            await _context.ScaleAsync(_currentScale, _currentScale);

            Console.WriteLine($"RenderFrame _currentScale: {_currentScale}");

            if (ksztalty == null || !ksztalty.Any())
                return;

            // Przygotowanie tekstury
            var baseUrl = Navigation.BaseUri;
            var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

            // Rysowanie każdego kształtu
            foreach (var ksztalt in ksztalty)
            {
                //Console.WriteLine($"Rysuję kształt: {ksztalt.TypKsztaltu}");
                if (ksztalt.Wierzcholki == null || ksztalt.Wierzcholki.Count < 3)
                    continue;

                Console.WriteLine($"*********** >>>>>> IndeksElementu: {ksztalt.IndeksElementu} Grupa: {ksztalt.Grupa} DlogoscElementu: {ksztalt.DlogoscElementu}");

                await DrawShapeWithVariableOffset(_context, ksztalt, imageUrl, calculate);
                await DrawSingleContourTextOnly(_context, ksztalt.Wierzcholki, $"{ksztalt.IndeksElementu.ToString()} [{ksztalt.Kat.ToString()}/{ksztalt.Strona}]"); // Tekst z ID i kątem na profilu
            }

            await _context.RestoreAsync();

           // await Task.Delay(50); // Krótkie opóźnienie dla płynności

           // StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd renderowania: {ex.Message}\n{ex.StackTrace}");
        }
    }

    private async Task DrawShapeWithVariableOffset(Canvas2DContext context, KsztaltElementu ksztalt, string textureUrl, bool calculate)
    {
        try
        {
            var outerPoints = ksztalt.Wierzcholki;
            var offsets = GetOffsetsForGroup(ksztalt.Grupa);

            await DrawSingleContour(context, outerPoints);

            // Sprawdź, czy _dotNetHelper nie jest null i czy komponent nie został usunięty
            if (_dotNetHelper != null && !_disposed)
            {
                try
                {
                    await JS.InvokeVoidAsync("loadAndDrawTexture",
                        CanvasRef.CanvasReference,
                        textureUrl,
                        _dotNetHelper
                    );
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ Błąd podczas ładowania tekstury: {ex.Message}");
                    // Możesz tutaj podjąć decyzję, czy chcesz kontynuować bez tekstury, czy coś innego
                }
            }

            await context.SetStrokeStyleAsync("#000000");
            await context.SetLineWidthAsync(1.5f);
            await context.StrokeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd w DrawShapeWithVariableOffset: {ex.Message}");
        }
    }

    private (float left, float right, float top, float bottom) GetOffsetsForGroup(string grupa)
    {
        // Domyślne wartości (można dostosować)
        float grLewo = 82;
        float grPrawo = 82;
        float grGora = 82;
        float grDol = 92;

        return grupa switch
        {
            "Lewo" => (grLewo, 0, 0, 0),
            "Prawo" => (0, grPrawo, 0, 0),
            "Gora" => (0, 0, grGora, 0),
            "Dol" => (0, 0, 0, grDol),
            _ => (grLewo, grPrawo, grGora, grDol) // Domyślne dla innych przypadków
        };
    }

    private async Task DrawSingleContour(Canvas2DContext context, List<XPoint> outerPoints)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Rysuj pojedynczy kontur zewnętrzny
        await context.BeginPathAsync();

        // Rozpocznij od pierwszego punktu
        await context.MoveToAsync(outerPoints[0].X, outerPoints[0].Y);

        // Rysuj linie do kolejnych punktów
        for (int i = 1; i < outerPoints.Count; i++)
        {
            await context.LineToAsync(outerPoints[i].X, outerPoints[i].Y);
        }

        // Zamknij kształt
        await context.ClosePathAsync();

        // Opcjonalne stylowanie
        await context.SetStrokeStyleAsync("black");
        await context.SetLineWidthAsync(2);
        await context.StrokeAsync();
    }

    private async Task DrawSingleContourTextOnly(Canvas2DContext context, List<XPoint> outerPoints, string tekst)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Oblicz środek figury
        double centerX = outerPoints.Average(p => p.X);
        double centerY = outerPoints.Average(p => p.Y);

        // Sprawdź proporcje
        double width = outerPoints.Max(p => p.X) - outerPoints.Min(p => p.X);
        double height = outerPoints.Max(p => p.Y) - outerPoints.Min(p => p.Y);
        bool rotate = height > width;

        // Rysowanie tekstu
        await context.SaveAsync();
        await context.SetFontAsync($"30px Arial");
        await context.SetFillStyleAsync("black");
        await context.SetTextAlignAsync(TextAlign.Center);
        await context.SetTextBaselineAsync(TextBaseline.Middle);

        if (rotate)
        {
            await context.TranslateAsync(centerX, centerY);
            await context.RotateAsync((float)Math.PI / 2); // 90 stopni
            await context.FillTextAsync(tekst, 0, 0);
        }
        else
        {
            await context.FillTextAsync(tekst, centerX, centerY);
        }

        await context.RestoreAsync();
    }


    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task GoCAD()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        NavigationManager.NavigateTo($"/DrawCAD");

        await Task.CompletedTask;
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                //Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    public class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }

        public double ScaleX { get; set; }
        public double ScaleY { get; set; }
    }

    private class PointClassification
    {
        public bool IsLeft { get; set; }
        public bool IsRight { get; set; }
        public bool IsTop { get; set; }
        public bool IsBottom { get; set; }
    }

    public class DraggedModelInfo
    {
        public string? Type { get; set; }
        public string? RowId { get; set; }
    }

    private class DomSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    public class SasiadInfo
    {
        public Guid RowIdElementu { get; set; }// RowId elementu sąsiada równoległego
        public string? IdRegionu { get; set; }
        public int ZIndeks { get; set; }
        public bool MaSlupekRuchomy { get; set; }
        public int Id { get; set; }
        public string? WybranyTyp { get; set; }
        public int KatSasiada { get; set; }
        public bool WystepujeDol { get; set; } = false;
        public bool WystepujeLewa { get; set; } = false;
        public bool WystepujeGora { get; set; } = false;
        public bool WystepujePrawa { get; set; } = false;
    }

    public class PrzesuniecieDto
    {
        public double PrzesuniecieX { get; set; }
        public double PrzesuniecieY { get; set; }
    }

}
