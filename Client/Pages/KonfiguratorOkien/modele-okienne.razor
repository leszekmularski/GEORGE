@page "/Modele-okienne"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D

<!DOCTYPE html>
<html lang="pl">
<head>

    <script>
        // Rejestracja Blazor w JavaScript
        window.initializeBlazor = (dotNetHelper) => {
            window.dotNetHelper = dotNetHelper;
            console.log("✅ Blazor zarejestrowany w JS!");
        };

               // Przenieś funkcję na poziom główny i przypisz do window
        window.loadAndDrawTexture = async (canvasElement, imageUrl, dotNetHelper) => {
            console.log("🖼️ Próba załadowania tekstury:", imageUrl);

            if (!canvasElement) {
                console.error("❌ Nie znaleziono elementu canvas!");
                return;
            }

            const ctx = canvasElement.getContext('2d');
            const img = new Image();

            // Tymczasowo wyłącz cache busting
            img.src = imageUrl;
            img.crossOrigin = "anonymous";

            img.onload = async () => {
                console.log("✅ Tekstura załadowana poprawnie!");
                const pattern = ctx.createPattern(img, 'repeat');
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                await dotNetHelper.invokeMethodAsync('OnTextureLoaded');
            };

            img.onerror = async (err) => {
                console.error("❌ Błąd ładowania tekstury:", err);
                ctx.fillStyle = "#deb887";
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                await dotNetHelper.invokeMethodAsync('OnTextureLoaded');
            };
        };

        // Nowa implementacja obsługi zdarzeń myszy
        window.initializeCanvasEvents = (canvasElement) => {
            if (!canvasElement) {
                console.error("❌ Nie znaleziono elementu canvas!");
                return;
            }

            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let currentModelType = null;

            // Funkcja pomocnicza do obliczania pozycji względem canvas
            const getCanvasPosition = (clientX, clientY) => {
                const rect = canvasElement.getBoundingClientRect();
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            };

            // Obsługa zdarzenia rozpoczęcia przeciągania
            document.querySelectorAll('[data-model-type]').forEach(item => {
                item.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    currentModelType = e.target.dataset.modelType;
                    const pos = getCanvasPosition(e.clientX, e.clientY);
                    startX = pos.x;
                    startY = pos.y;
                    window.dotNetHelper.invokeMethodAsync('StartDrag', pos.x, pos.y, currentModelType);
                });
            });

            // Obsługa ruchu myszy
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const pos = getCanvasPosition(e.clientX, e.clientY);
                window.dotNetHelper.invokeMethodAsync('DragAvatar', pos.x, pos.y);
            });

            // Obsługa zakończenia przeciągania
            document.addEventListener('mouseup', (e) => {
                if (!isDragging) return;

                isDragging = false;
                const pos = getCanvasPosition(e.clientX, e.clientY);
                window.dotNetHelper.invokeMethodAsync('StopDrag', pos.x, pos.y, currentModelType);
                currentModelType = null;
            });

            console.log("✅ Nowy system zdarzeń myszy zainicjalizowany!");
        };

        // Zaktualizowana funkcja rysowania obrazu
        window.drawImageOnCanvas = (imageSrc, x, y, width, height) => {
            const canvas = document.querySelector('canvas');
            if (!canvas) {
                console.error("❌ Canvas nie znaleziony!");
                return;
            }

            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = () => {
                // Najpierw wyczyść obszar przed narysowaniem
                ctx.clearRect(x - 5, y - 5, width + 10, height + 10);
                ctx.drawImage(img, x, y, width, height);
                console.log(`✅ Obraz narysowany na [${x}, ${y}]`);
            };

            img.onerror = () => console.error("❌ Błąd ładowania obrazu");
            img.src = imageSrc;
        };

        // Pozostałe funkcje pozostają bez zmian...
    </script>

    <style>

        /* Globalne ustawienia */
        html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
        }

        /* Kontener główny */
        .window-model-container {
        display: flex;
        height: 70vh;
        background-color: #fff;
        padding: 10px;
        box-sizing: border-box;
        }

        /* Panel boczny z modelami */
        .wing-model-container {
        flex: 0 0 250px; /* Zmniejszenie szerokości */
        height: 100%;
        overflow-y: auto;
        border-right: 2px solid #ddd;
        padding: 10px;
        background: #f8f9fa;
        }

        /* Tabela modeli */
        .wing-model-container table {
        font-size: 13px;
        width: 100%;
        border-collapse: collapse;
        }

        .wing-model-container th, .wing-model-container td {
        padding: 6px;
        text-align: center;
        }

        .wing-model-container th {
        background-color: #007bff;
        color: white;
        }

        .wing-model-container tr:hover {
        background-color: rgba(0, 123, 255, 0.1);
        }

        /* Miniatury modeli */
        .wing-model-container img {
        width: 45px;
        height: 45px;
        object-fit: contain;
        cursor: grab;
        pointer-events: auto; /* Umożliwia przeciąganie */
        transition: transform 0.2s ease-in-out;
        }

        .wing-model-container img:hover {
        transform: scale(1.1);
        }

        /* Główne okno wyświetlania */
        .display-window {
        flex-grow: 1;
        height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        position: relative;
        }

        /* Kontener canvas - dopasowany do okna */
        .canvas-container {
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ukrywa przewijanie */
        position: relative;
        }

        /* Canvas - dynamiczne skalowanie */
        canvas {
        display: block;
        max-width: 100%;
        max-height: 100%;
        background-color: transparent;
        }

        /* Paski przewijania */
        .wing-model-container::-webkit-scrollbar {
        width: 8px;
        }

        .wing-model-container::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 5px;
        }

        .wing-model-container::-webkit-scrollbar-thumb:hover {
        background: #0056b3;
        }

        /* 🔹 Toolbar z przyciskami */
        .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        justify-content: center;
        padding: 10px;
        background: #fff;
        }

        /* Styl dla przycisków */
        .toolbar .btn {
        flex: 1;
        min-width: 90px;
        font-size: 13px;
        padding: 6px 8px;
        transition: all 0.2s ease-in-out;
        }

        .toolbar .btn:hover {
        transform: scale(1.05);
        }

    </style>

</head>

<body @onmousemove="MouseMove">
    <!-- Nagłówek -->
    <div class="d-flex justify-content-between align-items-center mt-2 mb-2">
        <h3 class="mb-0">Modele Okienne</h3>
        <button class="btn btn-primary" @onclick="GoBack">
            <i class="fas fa-arrow-left"></i> Wróć
        </button>
    </div>
    <!-- 🔹 Wybór systemu -->
    <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
        <div class="d-flex">
            @if (Systemy != null && Systemy.Any())
            {
                <select class="form-select me-2" @onchange="@(async (args) => await OnSystemSelected(args))">
                    <option value="" disabled selected>-- Wybierz system --</option>
                    @foreach (var system in Systemy)
                    {
                        <option value="@system.RowId">@system.Nazwa_Systemu</option>
                    }
                </select>
            }
        </div>
    </Tooltip>

    <Collapse Animation>
        <Panel Header="Ustawienia" Key="1">

            <!-- Toolbar z przyciskami -->
            <div class="toolbar">
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("prostokat"))">🟥 Prostokąt</button>
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("trojkat"))">🔺 Trójkąt</button>
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("okrag"))">⚫ Okrąg</button>
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("trapez"))">🔷 Trapez</button>
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("romb"))">♦ Romb</button>
                <button class="btn btn-outline-primary" @onclick="@(() => WybierzKsztalt("piksel"))">🟧 Piksel</button>
            </div>

            <!-- Wprowadzenie wartości -->
            <div class="form-group mt-3">
                <label>Szerokość:</label>
                <input type="number" class="form-control" @bind="Szerokosc" />

                <label>Wysokość:</label>
                <input type="number" class="form-control" @bind="Wysokosc" />

                <label>Kolor:</label>
                <input type="color" class="form-control" @bind="Kolor" />

                <button class="btn btn-success mt-2 w-100" @onclick="DodajKsztalt">Dodaj kształt</button>

            </div>
        </Panel>
    </Collapse>

    <!-- Kontener na modele i canvas -->
    <div class="window-model-container">
        <!-- Panel boczny z modelami -->
        <div class="wing-model-container">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Typ</th>
                        <th>Wymiary</th>
                        <th>Miniaturka</th>
                    </tr>
                </thead>
                <tbody>
                    @if (ListaModeli != null)
                    {
                        @foreach (var model in ListaModeli ?? new List<KonfModele>())
                        {
                            <tr>
                                <td>@model.Typ</td>
                                <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                                <td>
                                    @if (model.Rysunek != null && model.Rysunek.Length > 0)
                                    {
                                        <div style="position: relative; display: inline-block;">
                                            <img id="@($"wing-{model.Typ}")"
                                            src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                            ondragstart="startDragJS(event, '@model.Typ')"
                                            ondragend="endDragJS(event)"
                                            draggable="true"
                                            style="position: relative; cursor: grab; width: auto; height: auto; max-width: 50px; max-height: 50px;" />
                                        </div>
                                    }
                                    else
                                    {
                                        <span class="text-muted">Brak</span>
                                    }
                                </td>
                            </tr>
                        }
                    }
                </tbody>
            </table>
        </div>

        <!-- Główne okno wyświetlania -->
        <div class="display-window">

            <!-- Główne okno wyświetlania -->
            <div class="canvas-container" style="overflow: auto;">
                @if (hasCanvasError)
                {
                    <p style="color: red;">❌ Błąd: Nie udało się załadować canvasu! Spróbuj odświeżyć stronę.</p>
                }
                else
                {
                    <BECanvas id="background-layer" @ref="BackgroundCanvas" Width="800" Height="600"></BECanvas>
                    <BECanvas id="interactive-layer" @ref="InteractiveCanvas" Width="800" Height="600"></BECanvas>
                }
            </div>


        </div>
    </div>
</body>

</html>

@code {
    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private string WybranyKsztalt = "prostokat";
    private int X = 0, Y = 0, Szerokosc = 1000, Wysokosc = 1000;
    private string Kolor = "#ff0000"; // Domyślny czerwony

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef;
    private Canvas2DContext? _context;
    private BECanvasComponent? BackgroundCanvas;
    private BECanvasComponent? InteractiveCanvas;
    private Canvas2DContext? _backgroundContext;
    private Canvas2DContext? _interactiveContext;

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private bool isTextureLoaded = false;

    private bool isDragging = false;
    private double startX, startY;
    private KonfModele? draggedModel;

    private double avatarX = 0; // Jeśli to ma być tylko zmienna typu double
    private double avatarY = 0; // Początkowa pozycja
    private string avatarImage = "data:image/png;base64,..."; // Tu wstaw Base64 awatara

    private string? draggedModelType = null;

    protected override async Task OnInitializedAsync()
    {
        await Laduj_Uprawnienia();

        Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _context = await CanvasRef.CreateCanvas2DAsync();

                // Poprawna ścieżka do tekstury
                var imageUrl = $"{Navigation.BaseUri}Images/wood.jpg";
                Console.WriteLine($"🕵️ Ścieżka do tekstury: {imageUrl}");

                await JS.InvokeVoidAsync(
                    "loadAndDrawTexture",
                    CanvasRef.CanvasReference,
                    imageUrl,
                    DotNetObjectReference.Create(this)
                );
            }
            catch (Exception ex)
            {
                Console.WriteLine($"💥 Błąd inicjalizacji: {ex.Message}");
                hasCanvasError = true;
                StateHasChanged();
            }
        }
    }

    private async Task RetryInit()
    {
        hasCanvasError = false;
        StateHasChanged();
        await Task.Delay(100);
        await OnAfterRenderAsync(true);
    }

    [JSInvokable]
    public async Task StartDrag(double x, double y, string modelType)
    {
        Console.WriteLine($"🚀 Rozpoczęto przeciąganie: {modelType} na [{x}, {y}]");

        avatarX = x;
        avatarY = y;
        draggedModelType = modelType;
        isDragging = true;

        // Natychmiastowa aktualizacja UI
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task StopDrag(double x, double y, string modelType)
    {
        Console.WriteLine($"🛑 Zatrzymano przeciąganie: {modelType} na [{x}, {y}]");

        isDragging = false;
        avatarX = x;
        avatarY = y;

        // Końcowe renderowanie z pełnym odświeżeniem
        await RenderFrame();
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnModelDropped(string modelType, double x, double y)
    {
        Console.WriteLine($"Model dropped: {modelType} at X:{x}, Y:{y}");

        // Aktualizacja zmiennych
        draggedModelType = modelType;
        avatarX = x;
        avatarY = y;

        // Debugowanie, aby sprawdzić, czy model istnieje
        var model = ListaModeli?.FirstOrDefault(m => m.Typ == modelType);
        if (model == null)
        {
            Console.WriteLine($"❌ Nie znaleziono modelu {modelType} w ListaModeli!");
            return;
        }

        Console.WriteLine($"✅ Znaleziono model {modelType}, rysowanie na canvasie.");

        await RenderFrame();
    }


    [JSInvokable]
    public async Task DragAvatar(double x, double y)
    {
        if (!isDragging) return;

        // Aktualizuj pozycję z ograniczeniami
        avatarX = Math.Clamp(x, 0, 800 - 50);
        avatarY = Math.Clamp(y, 0, 600 - 50);

        // Częściowe odświeżanie
        await RenderFrame();
    }



    private async Task MouseMove(MouseEventArgs e)
    {
        if (!isDragging || draggedModel == null) return;

        double deltaX = e.ClientX - startX;
        double deltaY = e.ClientY - startY;

        startX = e.ClientX;
        startY = e.ClientY;

        // Aktualizacja pozycji modelu (jeśli używasz modelu z pozycją)
        Console.WriteLine($"🚀 Przesunięcie: ΔX={deltaX}, ΔY={deltaY}");

        await InvokeAsync(StateHasChanged); // Odświeżenie UI
    }


    private async Task DrawImageOnCanvas(string imageSrc, double x, double y, double width, double height)
    {
        if (CanvasRef == null)
        {
            Console.WriteLine("❌ CanvasRef jest null, nie można rysować!");
            return;
        }

        Console.WriteLine($"🖼️ Rysowanie obrazka na {x}, {y} (Rozmiar: {width}x{height})");

        //await JS.InvokeVoidAsync("drawImageOnCanvas", "final-window", imageSrc, x, y, width, height);
        await JS.InvokeVoidAsync("drawImageOnCanvas", imageSrc, x, y, width, height);

    }


    private string GetImageBase64(string modelType)
    {
        // Zwróć Base64 dla odpowiedniego modelu na podstawie modelType
        return "data:image/png;base64,..."; // przykładowe dane
    }

    private async Task DrawStructure()
    {
        if (_context == null) return;

        // Rysowanie ramki
        await _context.ClearRectAsync(0, 0, 800, 600);

        if (isDragging)
        {
            // Rysowanie ikony na podstawie współrzędnych avatarX, avatarY
            var imageSrc = GetImageBase64(draggedModelType);
            await DrawImageOnCanvas(imageSrc, avatarX, avatarY, 50, 50);
        }
    }

    private async Task DodajKsztalt()
    {
        await RenderShapeAsync(WybranyKsztalt, Szerokosc, Wysokosc, Kolor, false);
    }

    private void WybierzKsztalt(string ksztalt)
    {
        WybranyKsztalt = ksztalt;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIN_DROWID/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private async Task RenderFrame()
    {
        if (_context == null) return;

        // 1. Tło jest renderowane tylko raz w OnTextureLoaded
        //    - Nie czyścimy całego canvasu, tylko obszar modelu

        // 2. Wyczyść poprzednią pozycję modelu
        await _context.ClearRectAsync(
            Math.Max(0, avatarX - 1),
            Math.Max(0, avatarY - 1),
            50 + 2,
            50 + 2
        );

        // 3. Narysuj nową pozycję modelu
        if (draggedModel != null && isDragging)
        {
            var imageSrc = RysunekToBase64(draggedModel.Rysunek);
            await DrawImageOnCanvas(imageSrc, avatarX, avatarY, 50, 50);
        }

        Console.WriteLine($"🔄 Zaktualizowano model na pozycji [{avatarX}, {avatarY}]");
    }

    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        // Renderuj tło tylko raz
        if (_context == null) return;

        await _context.SetFillStyleAsync("wood-pattern");
        await _context.FillRectAsync(0, 0, 800, 600);

        Console.WriteLine("✅ Tło zostało zrenderowane");
        isTextureLoaded = true;
        StateHasChanged();
    }

    private async Task RenderShapeAsync(string shape, double width, double height, string color, bool isFilled)
    {
        if (_context == null) return;

        // Automatyczne dopasowanie rozmiaru (80% dostępnej przestrzeni)
        double maxWidth = 800 * 0.8;
        double maxHeight = 600 * 0.8;
        width = Math.Min(width, maxWidth);
        height = Math.Min(height, maxHeight);

        // Obliczenie środka canvas
        double x = (800 - width) / 2;
        double y = (600 - height) / 2;

        await _context.SetStrokeStyleAsync(color);
        await _context.SetLineWidthAsync(3);
        if (isFilled)
            await _context.SetFillStyleAsync(color);
        else
            await _context.SetFillStyleAsync("transparent");

        switch (shape.ToLower())
        {
            case "prostokat":
                if (isFilled) await _context.FillRectAsync(x, y, width, height);
                await _context.StrokeRectAsync(x, y, width, height);
                break;

            case "trojkat":
                await _context.BeginPathAsync();
                await _context.MoveToAsync(x + width / 2, y);
                await _context.LineToAsync(x + width, y + height);
                await _context.LineToAsync(x, y + height);
                await _context.ClosePathAsync();
                if (isFilled) await _context.FillAsync();
                await _context.StrokeAsync();
                break;

            case "okrag":
                await _context.BeginPathAsync();
                await _context.ArcAsync(400, 300, width / 2, 0, Math.PI * 2);
                if (isFilled) await _context.FillAsync();
                await _context.StrokeAsync();
                break;

            case "trapez":
                await _context.BeginPathAsync();
                await _context.MoveToAsync(x + width * 0.2, y);
                await _context.LineToAsync(x + width * 0.8, y);
                await _context.LineToAsync(x + width, y + height);
                await _context.LineToAsync(x, y + height);
                await _context.ClosePathAsync();
                if (isFilled) await _context.FillAsync();
                await _context.StrokeAsync();
                break;

            case "romb":
                await _context.BeginPathAsync();
                await _context.MoveToAsync(x + width / 2, y);
                await _context.LineToAsync(x + width, y + height / 2);
                await _context.LineToAsync(x + width / 2, y + height);
                await _context.LineToAsync(x, y + height / 2);
                await _context.ClosePathAsync();
                if (isFilled) await _context.FillAsync();
                await _context.StrokeAsync();
                break;

            case "piksel":
                await _context.FillRectAsync(400, 300, 1, 1);
                break;
        }
    }

    private string RysunekToBase64(byte[]? imageData)
    {
        if (imageData == null || imageData.Length == 0)
        {
            return "data:image/png;base64,"; // Zapobiega błędom
        }

        return $"data:image/png;base64,{Convert.ToBase64String(imageData)}";
    }

    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("history.back");
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    public class BoundingClientRect
    {
        public double Top { get; set; }
        public double Left { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }


}