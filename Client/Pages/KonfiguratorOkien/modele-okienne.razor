@page "/Modele-okienne"
@using AntDesign
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@using GEORGE.Shared.ViewModels;
@using GEORGE.Client.Pages.Utils
@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@using System.Globalization
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation
@inject NavigationManager NavigationManager
@inject ShapeTransferService ShapeService

@using System.IO;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.Formats.Png;

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using GEORGE.Client.Pages.Models
@using GEORGE.Client.Pages.Okna

@inject GeneratorStateContainer StateContainer

@implements IDisposable

<script>
        (() => {
        // Inicjalizacja globalnych zmiennych
        const _originalInvoke = DotNet.invokeMethodAsync;
        DotNet.invokeMethodAsync = function (assemblyName, methodName, ...args) {
            console.log(`🔍 DotNet.invokeMethodAsync intercepted: ${assemblyName}.${methodName}`, args);
            return _originalInvoke(assemblyName, methodName, ...args)
                .catch(err => {
                    console.warn("❌ Intercepted DotNet.invokeMethodAsync error:", err);
                    throw err;
                });
        };

        window._dragListenersInitialized = window._dragListenersInitialized || false;

        window.currentDraggedModel = null;
        window.currentDraggedType = null;
        window.isDragging = false;
        window.blazorCanvas = null;

        // Ustawienie referencji do canvasu
        window.setCanvasRef = (canvasRef) => {
        if (!canvasRef) {
        console.error("❌ Blazor przekazał null do setCanvasRef!");
        return;
        }
        window.blazorCanvas = canvasRef;
       // console.log("✅ Canvas ustawiony!", canvasRef);
        };

        // Ustawienie referencji do .NET
        window.setDotNetHelper = (dotNetHelper) => {
        window.dotNetHelper = dotNetHelper;
        //console.log("✅ DotNetHelper ustawiony!");
        };

        // Funkcja rozpoczynająca przeciąganie
        window.startDrag = (modelType, event) => {
        if (event.button !== 0) return; // Obsługa tylko lewego przycisku myszy

        event.preventDefault();
        window.isDragging = true;
        window.currentDraggedType = modelType;

        // Pobranie obrazka do ustawienia jako kursor
        const img = document.getElementById(`wing-${modelType}`);
        if (!img) {
        console.error(`❌ Nie znaleziono obrazka dla modelu: ${modelType}`);
        return;
        }

        // Tworzymy nowy obrazek, który będzie podążał za kursorem
        const cursorImg = new Image();
        cursorImg.src = img.src;
        cursorImg.style.position = "absolute";
        cursorImg.style.pointerEvents = "none";
        cursorImg.style.width = "50px";
        cursorImg.style.height = "50px";
        cursorImg.style.opacity = "0.8";
        cursorImg.id = "dragCursorImage";

        document.body.appendChild(cursorImg);
        window.currentDraggedImage = cursorImg;

        // Aktualizacja pozycji obrazka pod kursorem
        window.updateCursorImagePosition(event);
        };

        //     // Aktualizacja pozycji obrazka kursora
        // window.updateCursorImagePosition = (event) => {
        //         if (!window.isDragging || !window.currentDraggedImage) return;
        //         window.currentDraggedImage.style.left = `${event.pageX - 25}px`;
        //         window.currentDraggedImage.style.top = `${event.pageY - 25}px`;
        //     };

        // Funkcja kończąca przeciąganie

        if (!window._stopDragDefined) {
            window.stopDrag = async function (event) {
                if (!window.isDragging) return;

                window.isDragging = false;

                if (window.currentDraggedImage) {
                    document.body.removeChild(window.currentDraggedImage);
                    window.currentDraggedImage = null;
                }

                if (!window.blazorCanvas) {
                    console.error("❌ Brak referencji do canvasu!");
                    return;
                }

                const rect = window.blazorCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                console.log(`🛑 Upuszczono model: ${window.currentDraggedType} na (${x}, ${y})`);

                if (window.dotNetHelper) {
                    try {
                        await window.dotNetHelper.invokeMethodAsync('OnDragEnd', window.currentDraggedType, x, y);
                    } catch (err) {
                        console.warn("❌ invokeMethodAsync (OnDragEnd) nie powiodło się:", err);
                        window.dotNetHelper = null;
                    }
                }

                window.currentDraggedType = null;
            };

            document.addEventListener("mouseup", window.stopDrag);
            window._stopDragDefined = true;
        }


        // Obsługa aktualizacji kursora
        document.addEventListener("mousemove", window.updateCursorImagePosition);

        // Obsługa upuszczenia obrazka
       if (!window._dragListenersInitialized) {
        document.addEventListener("mouseup", window.stopDrag);
        document.addEventListener("mousemove", window.updateCursorImagePosition);
        window._dragListenersInitialized = true;
        }



        window.SetCustomCursor = (base64Image) => {
        //console.log("🔵 Ustawiam kursor na Base64!");

        const cursorUrl = `data:image/png;base64,${base64Image}`;
        document.body.style.cursor = `url(${cursorUrl}) 8 8, auto`;

        // console.log(`🖱 Kursor ustawiony globalnie: ${cursorUrl}`);
        };

        window.ResetCursor = () => {
        //console.log("🔄 Resetowanie kursora");
        document.querySelector(".canvas-container").style.cursor = "default";
        document.querySelector("canvas").style.cursor = "default";
        };

        // JavaScript
        window.AddCanvasHoverListener = (canvasElement) => {
        canvasElement.addEventListener('mousemove', () => {
        // Wymusza aktualizację kursora, jeśli został już ustawiony
        if (document.body.style.cursor.includes('url')) {
        document.body.style.cursor = document.body.style.cursor;
        }
        });
        };

        // Funkcja do ładowania tekstury
        window.loadAndDrawTexture = async (canvasElement, imageUrl, dotNetHelper) => {
        const ctx = canvasElement.getContext('2d');
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imageUrl;

        await new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = reject;
        //console.log("🔍 dotNetHelper:", dotNetHelper);
        });

        const pattern = ctx.createPattern(img, 'repeat');
        ctx.fillStyle = pattern;

        // ❗ Dodaj tę linię, aby wypełnić aktualną ścieżkę!
        ctx.fill("evenodd");

        ctx.canvas.dataset.pattern = "wood-pattern";

        if (dotNetHelper) {
            try {
                await dotNetHelper.invokeMethodAsync('OnTextureLoaded');
            } catch (err) {
                console.warn("❌ OnTextureLoaded invoke failed", err);
            }
        }
        };

        // Globalny reset kursora z obsługą wszystkich przeglądarek
        window.ResetCursorGlobal = () => {
        // Reset dla wszystkich możliwych elementów
        document.documentElement.style.cursor = 'default';
        document.body.style.cursor = 'default';
        document.querySelector('.canvas-container').style.cursor = 'default';

        // Wymuś natychmiastowe odświeżenie
        const style = document.createElement('style');
        style.innerHTML = '*{cursor: default !important;}';
        document.head.appendChild(style);
        setTimeout(() => document.head.removeChild(style), 100);
        };

        let currentModel = null;

        window.SetCurrentModel = (modelType, modelRowId) => {
        currentModel = modelType;
        window.currentDraggedModel = {
        type: modelType,
        rowId: modelRowId
        };

        document.documentElement.setAttribute('data-current-model', modelType);
        document.documentElement.setAttribute('data-model-row-id', modelRowId);
        console.log(`📦 Ustawiono model: ${modelType}, ID: ${modelRowId}`);
        };

        window.getDraggedModelInfo = () => {
        if (!window.currentDraggedModel) {
        console.warn("⚠️ currentDraggedModel is not set.");
        return null;
        }

        return {
        type: window.currentDraggedModel.type,
        rowId: window.currentDraggedModel.rowId
        };
        };


        window.clearCurrentModel = () => {
        currentModel = null;
        document.documentElement.removeAttribute('data-current-model');
        };

        // Blokuj domyślne zachowanie przeglądarki
        document.addEventListener('dragover', (e) => {
        e.preventDefault();
        });

        window.getCanvasBoundingRect = function (canvasElement) {
            if (!canvasElement) {
                console.warn("❌ Canvas element is null in JS.");
                return null;
            }

            const rect = canvasElement.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
            };
        };

        })();

    window.clearDotNetHelper = () => {
        console.log("🧹 Czyszczenie dotNetHelper. Stary:", window.dotNetHelper);
        window.dotNetHelper = null;
    };

    window.getElementSize = (selector) => {
        const el = document.querySelector(selector);
        if (!el) return null;

        const rect = el.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height
        };
    };

    window.registerResizeCallback = (dotnetHelper) => {
        window.addEventListener("resize", () => {
            dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
        });
    };

        window.registerResizeHandler = function (dotnetHelper) {
            window.addEventListener("resize", () => {
                dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
            });
        };

    // Sprawdza, czy canvas jest poprawny i w DOM
    window.isCanvasValid = () => {
        const isValid = !!window.blazorCanvas && document.contains(window.blazorCanvas);
        //console.log(`✅ Canvas valid: ${isValid}`);
        return isValid;
    };

    // Czyści referencję do canvas (wywoływane z C# przy usuwaniu komponentu)
    window.clearCanvasRef = () => {
        console.log("🧹 Czyszczenie referencji do canvas");
        window.blazorCanvas = null;
    };
</script>

<style>
    /* Globalne ustawienia */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
    }

    /* Specjalna klasa dla resetu */
    .cursor-reset * {
        cursor: default !important;
        pointer-events: auto !important;
    }

    /* Kontener główny */
    .window-model-container {
        display: flex;
        height: 70vh;
        background-color: #fff;
        padding: 10px;
        box-sizing: border-box;
    }

    /* Panel boczny z modelami */
    .wing-model-container {
        flex: 0 0 250px; /* Szerokość panelu bocznego */
        height: 100%;
        overflow-y: auto;
        border-right: 2px solid #ddd;
        padding: 10px;
        background: #f8f9fa;
    }

        /* Tabela modeli */
        .wing-model-container table {
            font-size: 13px;
            width: 100%;
            border-collapse: collapse;
        }

        .wing-model-container th, .wing-model-container td {
            padding: 6px;
            text-align: center;
        }

        .wing-model-container th {
            background-color: #007bff;
            color: white;
        }

        .wing-model-container tr:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        /* Miniatury modeli */
        .wing-model-container img {
            width: 45px;
            height: 45px;
            object-fit: contain;
            cursor: -webkit-grab; /* Obsługa w Safari */
            cursor: grab;
            transition: transform 0.2s ease-in-out;
        }

            .wing-model-container img:hover {
                transform: scale(1.1);
            }

    /* Główne okno wyświetlania */
    .display-window {
        flex-grow: 1;
        height: 100%;
        min-height: 400px; /* Zapewnienie minimalnej wysokości */
        border: 2px solid #ddd;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        position: relative;
        overflow: hidden;
        cursor: crosshair;
    }

    .container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .canvas-container {
        width: @(CanvasWidth + "px");
        height: @(CanvasHeight + "px");
        pointer-events: none; /* Wyłącz interakcje z canvasem */
        max-width: 100%;
        max-height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ukrywa przewijanie */
        position: relative;
    }

    canvas {
        pointer-events: none; /* Kontynuuj ignorowanie zdarzeń */
        display: block;
        max-width: 100%;
        max-height: 100%;
        background-color: transparent;
    }

    .interactive-layer {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2; /* Warstwa NAD canvasem */
        pointer-events: auto; /* Włącz interakcje */
    }
    /* Paski przewijania */
    .wing-model-container::-webkit-scrollbar {
        width: 8px;
    }

    .wing-model-container::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 5px;
    }

        .wing-model-container::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }

    /* 🔹 Toolbar z przyciskami */
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        justify-content: center;
        padding: 10px;
        background: #fff;
    }

        /* Styl dla przycisków */
        .toolbar .btn {
            flex: 1;
            min-width: 90px;
            font-size: 13px;
            padding: 6px 8px;
            transition: all 0.2s ease-in-out;
        }

            .toolbar .btn:hover {
                transform: scale(1.05);
            }

    .zoom-controls {
        position: absolute;
        top: 170px; /* Ustawienie 10px od góry */
        right: 10px; /* Ustawienie 10px od prawej */
        display: flex;
        gap: 10px; /* Odstęp między przyciskami */
        z-index: 1000; /* Upewnia się, że są na wierzchu */
    }

    .btn-zoom {
        width: 40px;
        height: 40px;
        font-size: 20px;
        border-radius: 50%; /* Okrągłe przyciski */
        border: none;
        background-color: #007bff; /* Niebieski, możesz zmienić */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Delikatny cień */
        transition: background-color 0.3s ease;
    }

        .btn-zoom:hover {
            background-color: #0056b3; /* Ciemniejszy niebieski przy najechaniu */
        }

    /* Panel zajmuje pełną szerokość */
    .scrollable-panel {
        width: 100%;
        max-height: 400px; /* Możesz zmienić na więcej, np. 600px */
        overflow-y: auto; /* Włącza przewijanie w pionie */
    }

    /* Sider zajmuje całą szerokość */
    .info-panel {
        background-color: #222;
        color: #ffeb99;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
        width: 500px; /* Pełna szerokość */
        max-width: 1000px;
    }

    /* Lista informacji */
    .info-list {
        list-style: none;
        padding: 0;
        width: 760px;
    }

    /* Każdy element ma własne miejsce */
    .info-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 760px;
    }

        /* Tekst jasnożółty */
        .info-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .info-item strong {
            color: #ffcc00;
        }

    /* Obsługa braku danych */
    .no-data {
        color: red;
        text-align: center;
        font-style: italic;
    }

    /* Lista materiałów */
    .materials-list {
        list-style: none;
        padding: 0;
        width: 100%;
    }

    /* Pojedynczy materiał */
    .material-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
    }

        /* Kolor jasny dla tekstu */
        .material-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .material-item strong {
            color: #ffcc00;
        }
</style>

<!-- Nagłówek -->

<div class="d-flex justify-content-between align-items-center mt-2 mb-2">
    <h3 class="mb-0">Modele Okienne</h3>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoCAD">
        OKN-CAD
    </Button>
    &nbsp;&nbsp;
    <button class="btn btn-primary" @onclick="GoBack">
        <i class="fas fa-arrow-left"></i> Wróć do poprzednej strony
    </button>

</div>

<Collapse Animation>
    <Panel Header="Wymiary, kolory itp. Okien" Key="1">
        <div class="form-group mt-3">
            <label>Szerokość:</label>
            <input type="number" class="form-control" @bind="Szerokosc" />

            <label>Wysokość:</label>
            <input type="number" class="form-control" @bind="Wysokosc" />

            <label>Kolor:</label>
            <input type="color" class="form-control" @bind="Kolor" />
        </div>
        <Button OnClick="() => ZmienWymiaryOkna()">Zmień wymiary</Button>
        <Button OnClick="() => RozstawLinie()">Podziały ustaw symetrycznie</Button>
    </Panel>

    <Panel Header="Informacja o wyrobie restrykcje" Key="2" class="scrollable-panel">
        <Sider class="info-panel">
            <h4 style="color:aquamarine;">🛠️ Informacja o wyrobie:</h4>

            @if (infoObiekt != null && infoObiekt.Any())
            {
                <p class="entries-count"> 📌 Liczba wpisów: <strong>@infoObiekt.Count()</strong></p>
                <ul class="info-list">
                    @foreach (var wymiar in infoObiekt)
                    {
                        <li class="info-item">
                            <span><strong>📏 Szerokość:</strong> @wymiar.Szerokosc mm</span>
                            <span><strong>📐 Wysokość:</strong> @wymiar.Wysokosc mm</span>
                            <span><strong>🏗️ Wyrób:</strong> @wymiar.RodzajObiektu</span>
                            <span><strong>⚠️ Restrykcje:</strong> @wymiar.Restrykcja</span>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p class="no-data">❌ Brak danych o wyrobie.</p>
            }
        </Sider>
    </Panel>
    <Panel Header="Materiały" Key="3" class="scrollable-panel">
        @if (infoBoom != null && infoBoom.Any())
        {
            <p class="entries-count">📌 Liczba materiałów: <strong>@infoBoom.Count()</strong></p>
            <ul class="materials-list">
                @foreach (var material in infoBoom)
                {
                    <li class="material-item">
                        <span><strong>📏 Długość:</strong> @material.Dlugosc mm</span>
                        <span><strong>🏷️ Nazwa:</strong> @material.Nazwa</span>
                        <span><strong title="@material.RowIdIndeksu">🔢 Indeks:</strong> @material.Indeks</span>
                        <span><strong>📦 Ilość sztuk:</strong> @material.IloscSztuk</span>
                        <span><strong>⚠️ Restrykcje:</strong> @material.Restrykcja</span>
                    </li>
                }
            </ul>
        }
        else
        {
            <p class="no-data">❌ Brak użytych materiałów.</p>
        }
    </Panel>

</Collapse>


<!-- Kontener na modele i canvas -->
<div class="window-model-container">
    <!-- Kontener na przyciski -->
    <div class="zoom-controls">
        <label>@mousePosition skala: @((int)(_currentScale * 100))</label>
        <button @onclick="UsunOstatniObiekt" class="btn-zoom">🗑️</button>
        <button @onclick="ZoomIn" class="btn-zoom">➕</button>
        <button @onclick="ZoomOut" class="btn-zoom">➖</button>
        <button @onclick="PokazModal" class="btn-zoom">💎</button>
        <button class="btn btn-zoom" @onclick="OtworzPrzeglad">🔍</button>
    </div>
    <!-- Panel boczny z modelami -->
    <div class="wing-model-container">
        <!-- 🔹 Wybór systemu -->
        <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
            <div class="d-flex">
                @if (Systemy != null && Systemy.Any())
                {
                    <select class="form-select me-2" style="width:100%" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                }
            </div>
        </Tooltip>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Typ</th>
                    <th>Wymiary</th>
                    <th>Miniaturka</th>
                </tr>
            </thead>
            <tbody>
                @if (ListaModeli != null)
                {
                    @foreach (var model in ListaModeli)
                    {
                        <tr>
                            <td>@model.Typ</td>
                            <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                            <td>
                                @if (model.Rysunek != null && model.Ikona32x32.Length > 0)
                                {
                                    <img id="@($"wing-{model.Typ}")"
                                         src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                         @onclick='@(() => WybierzModel(model))'
                                         @ondragstart='@(e => JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId))'
                                         @onmouseout='@(e => JS.InvokeVoidAsync("ResetCursor"))'
                                         draggable="true"
                                         style="cursor: grab;
                                                                width: auto;
                                                                height: auto;
                                                                max-width: 50px;
                                                                max-height: 50px;
                                                                border: @(model == WybranyModel ? "4px solid #007bff" : "none")" />

                                }
                                else
                                {
                                    <span class="text-muted">Brak</span>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <!-- Główne okno wyświetlania -->
    <div class="display-window" @onmouseup="OnMouseUp" @onmousemove="OnMouseMove"
         style="position: relative; /* Wymagane dla warstw */
            overflow: visible; /* Zapobiega przycinaniu kursora */
            cursor: inherit; /* Dziedziczy kursor z JS */">

        <!-- Tutaj elementy reagujące na kursor (np. przyciski) -->
        @if (hasCanvasError)
        {
            <p style="color: red; position: relative; z-index: 100;">❌ Błąd: Nie udało się załadować canvasu!</p>
        }
        else
        {
            <!-- Canvas -->
            <div class="canvas-container" style="padding:0px;background-color: transparent;border: 0px;">
                <BECanvas @ref="CanvasRef" Width="@CanvasWidth" Height="@CanvasHeight" />
            </div>
        }
    </div>
</div>

<div class="modal fade @classShowTWZ" tabindex="-1"
     style="display: @displayTWZ; margin: auto; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; width: 80%;">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Punkty elementów okien</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal"></button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto; font-size: 0.85rem; font-family: Consolas, monospace;">
                @if (ksztalty is not null && ksztalty.Any())
                {

                    @foreach (var ksztalt in ksztalty)
                    {
                        <div class="card my-2 shadow-sm">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>Typ:</strong> @ksztalt.TypKsztaltu &nbsp;|&nbsp;
                                    <strong>Grupa:</strong> @ksztalt.Grupa &nbsp;|&nbsp;
                                    <strong>ZIndex:</strong> @ksztalt.ZIndex &nbsp;|&nbsp;
                                    <strong>RowIdElementu:</strong> @ksztalt.RowIdElementu
                                    <strong>Kąt:</strong> @ksztalt.Kat
                                    <br />
                                    <strong>IdRegion:</strong> @ksztalt.IdRegion
                                </div>
                                <button class="btn btn-sm btn-primary" @onclick="@(() => EdytujKsztalt(ksztalt.Id))">Edytuj</button>
                            </div>
                            <div class="card-body">
                                @if (edytowanyId == ksztalt.Id)
                                {
                                    <div class="mb-2">
                                        <label>Typ kształtu</label>
                                        <input class="form-control" @bind="ksztalt.TypKsztaltu" />
                                    </div>
                                    <!-- Pozostałe inputy jak wcześniej... -->

                                    <div class="mb-2">
                                        <label><strong>Wierzchołki (X, Y):</strong></label>
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var punkt = ksztalt.Wierzcholki[i];
                                            var lokalnyIndex = i;  // 👈 to jest klucz

                                            <div class="d-flex align-items-center mb-1" @key="punkt">
                                                <span class="me-2">[@lokalnyIndex]</span>
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                       @oninput="@(e => ZmienX(ksztalt, lokalnyIndex, e))" placeholder="X" />
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                       @oninput="@(e => ZmienY(ksztalt, lokalnyIndex, e))" placeholder="Y" />
                                            </div>
                                        }
                                    </div>

                                    <button class="btn btn-success btn-sm" @onclick="@ZapiszKsztalt">Zapisz</button>
                                    <button class="btn btn-secondary btn-sm ms-2" @onclick="@AnulujEdycje">Anuluj</button>
                                }
                                else
                                {
                                    <p><strong>Wypełnienie wewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieWewnetrzne">@ksztalt.WypelnienieWewnetrzne</span></p>
                                    <p><strong>Wypełnienie zewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieZewnetrzne">@ksztalt.WypelnienieZewnetrzne</span></p>
                                    <p><strong>Grubość obramowania:</strong> @ksztalt.GruboscObramowania px</p>
                                    <p><strong>Czy zawiera otwór:</strong> @(ksztalt.CzyZawieraOtwor ? "Tak" : "Nie")</p>
                                    <p><strong>Widoczny:</strong> @(ksztalt.Widoczny ? "Tak" : "Nie")</p>
                                    <p><strong>Długość: @ksztalt.DlogoscElementu</strong></p>
                                    <p><strong>Kąt: @ksztalt.Kat</strong></p>
                                    <p><strong>Wierzchołki:</strong></p>

                                    <ul class="list-group list-group-flush">
                                        @foreach (var p in ksztalt.Wierzcholki)
                                        {
                                            <li class="list-group-item">
                                                X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                            </li>
                                        }
                                    </ul>
                                }
                            </div>
                        </div>
                    }

                    <hr>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>

                }
                else
                {
                    <p class="text-muted">Brak danych do wyświetlenia 😔 nie wygenerowano okien</p>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @p.X, Y: @p.Y
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>
                }
            </div>
        </div>
    </div>
</div>

<Modal Title="Podgląd danych wygenerowanych "
       Visible="@_generatorState"
       OnOk="@HandleCancel"
       OnCancel="@HandleCancel"
       Maximizable="@true"
       Centered="@true"
       DefaultMaximized="@true">
    <Generator_state_viewer StateContainer="StateContainer"></Generator_state_viewer>
</Modal>


@code {

    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private KonfModele? WybranyModel { get; set; }

    private string WybranyKsztalt = "prostokat";
    private int Szerokosc = 1000, Wysokosc = 1000;
    private string Kolor = "#ff0000"; // Domyślny czerwony

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef; // Referencja do komponentu BECanvas
    private Canvas2DContext? _context;
    private DotNetObjectReference<Modele_okienne>? _dotNetHelper;

    // Dodaj nowe pola w sekcji @code
    private string? SelectedModelType { get; set; }
    private string? SelectedRowIdType { get; set; }
    // private double DropX { get; set; }
    // private double DropY { get; set; }
    private ElementReference canvasElement;

    private double _currentScale = 1.0;
    private const double ScaleFactor = 1.1;
    private double _panX = 0;
    private double _panY = 0;

    private long CanvasWidth { get; set; } = 900;
    private long CanvasHeight { get; set; } = 600;

    private double _zoomCenterX = 450; // Środek canvasu
    private double _zoomCenterY = 300;

    private List<WyrobWymiaryOpis>? infoObiekt;

    private List<WygenerowaneMaterialy> infoBoom = new List<WygenerowaneMaterialy>();

    private List<IShapeDC> _shapes = new List<IShapeDC>();

    private List<ShapeRegion> _regionsDualRama = new();
    private List<ShapeRegion> _regionsSkrzydlo = new();

    private double _offsetX = 0;
    private double _offsetY = 0;


    private string woodPatternName = "sosna.jpg"; // Nazwa pliku do wzoru drewna meranti.jpg wood.jpg

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private string classShowTWZ = "";
    private string displayTWZ = "none";
    private string edytowanyId = "";

    private string edytowanyIdshape = "";

    private string mousePosition = "X: 0, Y: 0";

    private string? edytowanyRegionId;

    private Dictionary<string, List<KsztaltElementu>> _ksztaltyNaRegion = new();
    private List<KsztaltElementu> ksztalty = new();

    private Dictionary<string, GeneratorState> _generatorStates = new();
    private readonly Dictionary<string, Generator> _generatory = new();

    private bool _generatorState = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {

            _shapes = ShapeService.Shapes;

            if (_shapes != null && _shapes.Count() > 0)
            {

                double maxWysokosc = _shapes.Max(s => s.Wysokosc);
                double maxSzerokosc = _shapes.Max(s => s.Szerokosc);

                if (maxWysokosc > 0 && maxSzerokosc > 0)
                {
                    Wysokosc = (int)maxWysokosc;
                    Szerokosc = (int)maxSzerokosc;
                }

                // Generuj regiony po transformacji
                //  _regions = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)CanvasWidth, (int)CanvasHeight);
                _regionsDualRama = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, true);
                _regionsSkrzydlo = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, false); // ostatni parametr nie wiem czy potrzeby do sprawdzenia (czy rama true/falsa)

                // foreach(var rdr in _regionsDualRama)
                // {
                //     // foreach (var rds in rdr.Wierzcholki)
                //     //{
                //     Console.WriteLine($"🔷 Region ramy: Id={rdr.Id}, Typ={rdr.TypKsztaltu}, Wierzchołki={string.Join(" | ", rdr.Wierzcholki.Select(p => $"({p.X},{p.Y})"))}");
                //     //   }
                // }
                // foreach (var rdr in _regionsSkrzydlo)
                // {
                //     // foreach (var rds in rdr.Wierzcholki)
                //     //{
                //     Console.WriteLine($"🔷 Region skrzydło: Id={rdr.Id}, Typ={rdr.TypKsztaltu}, Wierzchołki={string.Join(" | ", rdr.Wierzcholki.Select(p => $"({p.X},{p.Y})"))}");
                //     //   }
                // }

                //    await RozstawLinie(false); // Dodaj ten wiersz, aby wywołać metodę  RozstawLinie podczas inicjalizacji

                foreach (var rds in _regionsSkrzydlo)
                {
                    var center = GeometryUtils.ObliczCentroid(rds.Wierzcholki);

                    foreach (var rdr in _regionsDualRama)
                    {
                        if (GeometryUtils.CzyPunktWielokacie(center, rdr.Wierzcholki))
                        {
                            rds.IdRegionuPonizej = rdr.Id;
                            // Console.WriteLine($"🔗 Region skrzydła {rds.Id} przypisany do regionu ramy {rdr.Id}");
                            break; // Przypisz tylko pierwszą pasującą ramę
                        }
                    }
                }

                // 2. Oblicz skalę z zachowaniem proporcji tak, by dopasować do docelowych wymiarów
                double scaleX = Szerokosc / CanvasWidth;
                double scaleY = Wysokosc / CanvasHeight;
                double scale = Math.Min(scaleX, scaleY) / 2;

                scale = scale * 0.9;

                double minX = 0;
                double minY = 0;
                double maxX = Szerokosc;
                double maxY = Wysokosc;

                double contentWidth = maxX - minX;
                double contentHeight = maxY - minY;

                double centerX = CanvasWidth / 2;
                double centerY = CanvasHeight / 2;

                double contentCenterX = (minX + maxX) / 2;
                double contentCenterY = (minY + maxY) / 2;

                _panX = centerX - contentCenterX * scale;
                _panY = centerY - contentCenterY * scale;

                Console.WriteLine($"🔍 OnInitializedAsync --> Przeskalowano kształty: skala={scale} CanvasWidth: {CanvasWidth} CanvasHeight: {CanvasHeight}");

                await ApplyZoom(scale);

                Console.WriteLine($"Odebrano dane _shapes: {_shapes.Count()}");

                _context = null;
                // await RedrawCanvas();

            }
            else
            {
                Console.WriteLine($"Odebrano dane _shapes: null");
            }

            Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

            if (_dotNetHelper == null)
            {
                _dotNetHelper = DotNetObjectReference.Create(this);
                await Task.Delay(25); // Krótkie opóźnienie dla płynności
                await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
                // await Task.Delay(25); // Krótkie opóźnienie dla płynności
                //Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
            }

            // Sprawdź, czy skrypt JS został poprawnie załadowany
            var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
            if (!isScriptLoaded)
            {
                throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");

                // await JS.InvokeVoidAsync("AddCanvasHoverListener", CanvasRef);

            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas inicjalizacji: {ex.Message}");
        }

        await Laduj_Uprawnienia();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {

            if (firstRender && CanvasRef != null)
            {
                Console.WriteLine("🖌️ Inicjalizacja canvasu...");

                var isFunctionDefined = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
                if (!isFunctionDefined)
                    throw new Exception("⚠️ Funkcja setCanvasRef nie jest zdefiniowana!");

                await JS.InvokeVoidAsync("setCanvasRef", CanvasRef.CanvasReference);
                Console.WriteLine("✅ Canvas ustawiony!");

                // 👇 TU DODAJ
                _context ??= await CanvasRef.CreateCanvas2DAsync();

                await JS.InvokeVoidAsync("registerResizeCallback", DotNetObjectReference.Create(this));

                // // Możesz od razu wywołać rysowanie
                if (_shapes?.Any() == true)
                    await RedrawCanvas();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Krytyczny błąd: {ex.Message}");
            hasCanvasError = true;
            StateHasChanged();
        }
    }

    private void WybierzModel(KonfModele model)
    {
        WybranyModel = model;
        // Dodatkowe akcje przy wyborze modelu
        JS.InvokeVoidAsync("SetCustomCursor", Convert.ToBase64String(model.Ikona32x32));
        JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId);
    }

    private void ZmienX(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienX wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newX))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.X = newX;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newX}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienX: {ex.Message}");
        }
    }

    private void ZmienY(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienY wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newY))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.Y = newY;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienY: indeks {index}, nowa wartość Y: {newY}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienY: {ex.Message}");
        }
    }


    private async Task EdytujKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        edytowanyId = id;
        Console.WriteLine($"edytowanyId: {edytowanyId}");
    }

    private async Task ZapiszKsztalt()
    {
        // Nie zmieniaj listy ksztalty – dane są już w niej zaktualizowane przez binding
        edytowanyId = "";
        await RenderFrame(false);
    }


    private void AnulujEdycje()
    {
        edytowanyId = "";
    }

    private void ZmienXRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var x))
        {
            var punkt = region.Wierzcholki[index];
            punkt.X = x;// / _currentScale;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private void ZmienYRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var y))
        {
            var punkt = region.Wierzcholki[index];
            punkt.Y = y;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private async Task ZapiszRegion()
    {
        edytowanyRegionId = null;
        await RedrawCanvas();
        //StateHasChanged(); // aby odświeżyć widok
    }


    private void ZamknijModal()
    {
        classShowTWZ = "";
        displayTWZ = "none";
    }

    private async Task PokazModal()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowTWZ = "show";
        displayTWZ = "block";
    }

    private async Task OtworzPrzeglad()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        StateContainer.States = _generatorStates;

        if (_generatorStates.Count == 0)
        {
            await _message.Warning("Brak zapisanych stanów generatora.", 1.5);
            return;
        }

        await Task.Delay(50); // Krótkie opóźnienie dla płynności

        _generatorState = true;

    }

    private void HandleCancel(MouseEventArgs e)
    {
        _generatorState = false;
    }

    [JSInvokable("UpdateCanvasSizeFromResize")]
    public async Task UpdateCanvasSizeFromResize()
    {
        if (_context == null)
        {
            Console.WriteLine("❌ Brak kontekstu canvas");
            return;
        }

        await ApplyZoom(_currentScale);
    }

    private async Task RedrawCanvas()
    {
        if (_context is null)
            return;
        try
        {
            await ClearCanvas();

            await _context.SaveAsync();
            await _context.ScaleAsync(_currentScale, _currentScale);

            foreach (var shape in _shapes)
                await shape.Draw(_context);

            await _context.RestoreAsync();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("❌ RedrawCanvas błąd: " + ex.Message);
        }
    }

    private async Task ClearCanvas()
    {
        if (_context == null || !await JS.InvokeAsync<bool>("isCanvasValid"))
        {
            Console.WriteLine("❌ Brak kontekstu canvas (invalid or disposed)");
            return;
        }

        try
        {
            // Reset transformacji, aby czyścić w skali 1:1
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);

            // Wyczyść cały canvas
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);

            // Opcjonalnie białe tło
            await _context.SetFillStyleAsync("white");
            await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("❌ ClearCanvas błąd: " + ex.Message);
        }
    }


    private async Task UsunOstatniObiekt()
    {
        if (_generatorStates.Count == 0)
            return;

        var ostatni = _generatorStates.Keys.LastOrDefault();
        if (string.IsNullOrWhiteSpace(ostatni))
            return;

        if (_generatorStates.TryGetValue(ostatni, out var state) &&
            _generatory.TryGetValue(state.IdRegion, out var generator))
        {
            UsunOstatniKsztaltZGeneratora(state.IdRegion, generator);

            _generatorStates.Remove(ostatni);
            _generatory.Remove(state.IdRegion);

            _ksztaltyNaRegion.Remove(state.IdRegion);
            ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
        }


        await ClearCanvas();
        isTextureLoaded = false;

        await Task.Delay(100);
        await RedrawCanvas();
        await DrawStructureAndRestrykcje();
        await RenderFrame();

        StateHasChanged();
    }


    private async Task ZoomIn()
    {
        var newScale = _currentScale * 1.2;
        await ApplyZoom(newScale);
    }

    private async Task ZoomOut()
    {
        var newScale = _currentScale / 1.2;
        await ApplyZoom(Math.Max(newScale, 0.12));
    }

    private async Task ApplyZoom(double newScale)
    {
        if (CanvasWidth == 0 || CanvasHeight == 0)
            return;

        // 📌 Środek canvasu jako punkt odniesienia do zoomu
        _zoomCenterX = CanvasWidth / 2.0;
        _zoomCenterY = CanvasHeight / 2.0;

        Console.WriteLine($"🔍 ZOOM: nowa skala = {newScale:F2}, aktualna skala = {_currentScale:F2}");

        var ratio = 1 - (newScale / _currentScale);
        _panX += (_zoomCenterX - _panX) * ratio;
        _panY += (_zoomCenterY - _panY) * ratio;

        _currentScale = newScale;

        // Rysuj wszystkie kształty w przeskalowanym kontekście
        if (_context != null && _shapes != null)
        {
            isTextureLoaded = false;

            await RedrawCanvas();
            await DrawStructureAndRestrykcje();
            await RenderFrame();

            foreach (var shape in _shapes)
            {
                await shape.Draw(_context);
            }

            StateHasChanged();
        }

    }

    private async Task FitToCanvas(IShapeDC targetShape, string idRegion, bool skalaAutomatyczna, List<XPoint> Wierzcholki, double klikX, double klikY)
    {

        Console.WriteLine($"🔍 FitToCanvas --> Dopasowano do shape: scale={_currentScale:F2}, panX={_panX:F2}, panY={_panY:F2}");

        // await DrawStructureAndRestrykcje(0);

        //await Task.Delay(250); // Krótkie opóźnienie dla płynności

        //if (await DodajWybranyKwadratOkna(idRegion, Wierzcholki) == false) return; // teraz z idRegion

        if (!await DodajWybranyKwadratOkna(idRegion, Wierzcholki, klikX, klikY))
            return;

        await DrawStructureAndRestrykcje(0);

        isTextureLoaded = false;

        // await UpdateCanvasSizeFromDiv();
        await RenderFrame();

    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (CanvasRef == null) return;

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa w pikselach
        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na współrzędne modelu w mm (uwzględniając przesunięcie i skalę)
        double modelX = (relativeX - _offsetX) / (_currentScale * 0.745);
        double modelY = (relativeY - _offsetY) / (_currentScale * 0.745);

        // Ograniczenie do wymiarów obiektu (prostokąta o rozmiarach Szerokosc x Wysokosc)
        modelX = Math.Clamp(modelX, 0, Szerokosc);
        modelY = Math.Clamp(modelY, 0, Wysokosc);

        // Wyświetlenie pozycji w mm i skali
        mousePosition = $"X: {modelX:F0} mm, Y: {modelY:F0} mm (skala: {_currentScale:F2}) {Szerokosc}x{Wysokosc}";
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_context == null) return;

        if (CanvasRef == null)
        {
            Console.WriteLine("⚠️ Brak referencji do canvasu!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            await _message.Warning("Wybierz system okienny przed przeciągnięciem modelu.", 1.5);
            return;
        }



        if (WybranyModel == null)
        {
            await _message.Warning("Wybierz model z listy przed przeciągnięciem.", 1.0);
            return;
        }

        // Pobierz informacje o przeciąganym modelu
        var draggedInfo = await GetDraggedModelInfoAsync();
        if (draggedInfo != null && !string.IsNullOrEmpty(draggedInfo.Type))
        {
            SelectedModelType = draggedInfo.Type;
            SelectedRowIdType = draggedInfo.RowId;
        }

        //await Task.Delay(25);

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        // Pozycja kursora względem canvasa w pikselach
        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na współrzędne modelu w mm (uwzględniając przesunięcie i skalę)
        double modelX = (relativeX - _offsetX) / (_currentScale * 0.745);
        double modelY = (relativeY - _offsetY) / (_currentScale * 0.745);

        // Ograniczenie do wymiarów obiektu (prostokąta o rozmiarach Szerokosc x Wysokosc)
        modelX = Math.Clamp(modelX, 0, Szerokosc);
        modelY = Math.Clamp(modelY, 0, Wysokosc);

        Console.WriteLine($"🔧 relativeX: {relativeX}, relativeY: {relativeY}, Scale: {_currentScale}");
        Console.WriteLine($"📌 Pozycja w modelu: modelX={modelX}, modelY={modelY}");

        mousePosition = $"Wybrałeś: X: {modelX:F0} mm, Y: {modelY:F0} mm (skala: {_currentScale:F2}) {Szerokosc}x{Wysokosc}";

        // await Task.Delay(50);

        bool tylkoRama = false;

        if (SelectedModelType == "Rama") tylkoRama = true;

        // 🔍 Znajdź region, w który kliknięto
        var region = FindRegionAtPosition(modelX, modelY, tylkoRama);

        if (region == null)
        {
            await _message.Warning($"❌ Nie znaleziono regionu dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🔍 Znajdź shape wewnątrz regionu
        var shape = _shapes.FirstOrDefault(s =>
        {
            var bbox = s.GetBoundingBox();
            var testPoints = new[]
            {
            new XPoint(bbox.X, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y + bbox.Height),
            new XPoint(bbox.X, bbox.Y + bbox.Height),
            new XPoint(bbox.X + bbox.Width / 2, bbox.Y + bbox.Height / 2)
            };

            return testPoints.Any(p => IsPointInPolygon(region.Wierzcholki, p.X, p.Y));
        });

        if (shape == null)
        {
            await _message.Warning($"❌ Nie znaleziono kształtu w regionie {region.Id} dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🎯 Dopasuj widok do kształtu i regionu
        await FitToCanvas(shape, region.Id, false, region.Wierzcholki, modelX, modelY);

        await Task.Delay(50);

        foreach (var shapeX in _shapes)
        {
            // Console.WriteLine($"🖌️ Rysuję {shapeX.GetType().Name}");
            await shapeX.Draw(_context);
        }
        await _context.RestoreAsync();

        WybranyModel = null;

        // Resetuj kursor JS
        await JS.InvokeVoidAsync("ResetCursorGlobal");

    }

    private ShapeRegion? FindRegionAtPosition(double x, double y, bool tylkoRama)
    {
        Console.WriteLine($"🔍 Szukam regionu w pozycji (model): X={x:F2}, Y={y:F2}");

        if (_regionsDualRama == null || !_regionsDualRama.Any() || _regionsSkrzydlo == null || !_regionsSkrzydlo.Any())
        {
            Console.WriteLine("❌ Brak regionów do sprawdzenia!");
            return null;
        }

        if (tylkoRama)
        {
            foreach (var region in _regionsDualRama)
            {
                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsDualRama Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region DualRama {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }
        else
        {
            foreach (var region in _regionsSkrzydlo)
            {

                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsSkrzydlo Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region Skrzydło {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }

        Console.WriteLine("❌ Żaden region nie zawiera podanego punktu.");
        return null;
    }

    private bool IsPointInPolygon(List<XPoint> polygon, double x, double y)
    {
        bool inside = false;
        int n = polygon.Count;

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            var xi = polygon[i].X;
            var yi = polygon[i].Y;
            var xj = polygon[j].X;
            var yj = polygon[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi); // +epsilon by uniknąć dzielenia przez 0

            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private async Task OnlyRestrykcje()
    {

        if (!string.IsNullOrEmpty(SelectedModelType))
        {

            if (ListaModeli != null)
            {
                Console.WriteLine($"OnlyRestrykcje - Typ --> SelectedModelType: {SelectedModelType}");

                var _ListaModeliResrykcje = ListaModeli.FirstOrDefault(x => x.Typ == SelectedModelType);

                if (_ListaModeliResrykcje != null)
                {
                    infoObiekt = new List<WyrobWymiaryOpis>();

                    string restrykcje = "Brak restrykcji :)";

                    if (_ListaModeliResrykcje.KonstrMinSzer > Szerokosc)
                    {
                        restrykcje = "<#SYS> Konstrukcja nie spełnia warunku MIN szerokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMinWys > Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MAX wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }

                    // ✅ Poprawione: Utwórz nowy obiekt przed ustawieniem właściwości
                    WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(Szerokosc, Wysokosc, SelectedModelType, restrykcje);

                    infoObiekt.Add(opisy);

                    infoBoom.Clear();// czyści listę przed dodaniem nowych elementów

                    foreach (var danedoboom in ksztalty)
                    {
                        WygenerowaneMaterialy opisySys = new WygenerowaneMaterialy(
                         danedoboom.RowIdElementu,
                         danedoboom.DlogoscNaGotowoElementu,
                         danedoboom.NazwaElementu ?? "",
                         danedoboom.IndeksElementu ?? "",
                         1,
                         ""
                         );

                        infoBoom.Add(opisySys);
                    }

                }

            }
        }

        await Task.CompletedTask;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        //Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private bool isTextureLoaded = false;

    private async Task DrawStructureAndRestrykcje(int isTextureLoadedNZ = 999)
    {
        if (isTextureLoadedNZ == 0) isTextureLoaded = false;

        try
        {
            if (CanvasRef == null)
            {
                Console.WriteLine("⚠️ Brak referencji do canvasu!");
                return;
            }

            _context ??= await CanvasRef.CreateCanvas2DAsync();

            if (!isTextureLoaded)
            {
                // var baseUrl = Navigation.BaseUri;
                // var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

                // await JS.InvokeVoidAsync("loadAndDrawTexture",
                //     CanvasRef.CanvasReference,
                //     imageUrl,
                //     _dotNetHelper
                // );

                await OnlyRestrykcje();

                // StateHasChanged();
                // return;
            }

            //await RenderFrame();

            // Reszta kodu do rysowania...
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas rysowania: {ex.Message}");
        }
    }

    public async Task<DraggedModelInfo> GetDraggedModelInfoAsync()
    {
        try
        {
            var info = await JS.InvokeAsync<DraggedModelInfo>("getDraggedModelInfo");
            await JS.InvokeVoidAsync("clearCurrentModel"); // Opcjonalne czyszczenie po odczycie
            return info;
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Błąd pobierania informacji o modelu: {ex.Message}");
            return null;
        }
    }

    [JSInvokable]
    public async Task OnDragError(string message)
    {
        await _message.Error(message);
        StateHasChanged();
    }

    public void Dispose()
    {
        try
        {
            //JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper?.Dispose();
            _dotNetHelper = null;
            Console.WriteLine($"🧹 Dispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd Dispose: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("clearDotNetHelper");
        _dotNetHelper?.Dispose();
        _dotNetHelper = null;
        Console.WriteLine($"🧹 AsyncDispose wywołany. Obiekt: {this.GetHashCode()}");
    }


    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        try
        {
            isTextureLoaded = true;
            // Console.WriteLine("✅ Tekstura załadowana!");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ładowania tekstury: {ex.Message}");
        }
    }

    public async Task RozstawLinie(bool zmienWymOkna = true)
    {
        // 🟦 1. Funkcja pomocnicza – rozstaw linie w danej kolekcji
        void RozstawKolekcje(List<ShapeRegion> kolekcja, string nazwaKolekcji, double szerokosc, double wysokosc)
        {
            var linie = kolekcja
                .Where(r => r.TypKsztaltu?.ToLower().Contains("linia") == true && r.Wierzcholki?.Count == 2)
                .ToList();

            int liczbaLinii = linie.Count;
            if (liczbaLinii == 0)
            {
                Console.WriteLine($"❌ Brak regionów typu 'linia' w {nazwaKolekcji}");
                return;
            }

            Console.WriteLine($"📏 Rozstawianie {liczbaLinii} linii w kolekcji: {nazwaKolekcji}");

            // odstępy dla pionowych i poziomych
            double odstępX = szerokosc / (liczbaLinii + 1);
            double odstępY = wysokosc / (liczbaLinii + 1);

            for (int i = 0; i < liczbaLinii; i++)
            {
                var region = linie[i];
                var p1 = region.Wierzcholki[0];
                var p2 = region.Wierzcholki[1];

                bool jestPionowa = Math.Abs(p1.X - p2.X) < 0.001;
                bool jestPozioma = Math.Abs(p1.Y - p2.Y) < 0.001;

                if (jestPionowa)
                {
                    double nowaX = odstępX * (i + 1);
                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = nowaX, Y = p1.Y },
                    new XPoint { X = nowaX, Y = p2.Y }
                };
                }
                else if (jestPozioma)
                {
                    double nowaY = odstępY * (i + 1);
                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = p1.X, Y = nowaY },
                    new XPoint { X = p2.X, Y = nowaY }
                };
                }
                else
                {
                    // linie skośne – równoległe przesunięcie
                    double offsetX = odstępX * (i + 1);
                    double offsetY = odstępY * (i + 1) * 0.1; // delikatne przesunięcie dla wizualnego rozdziału

                    region.Wierzcholki = new List<XPoint>
                {
                    new XPoint { X = p1.X + offsetX, Y = p1.Y + offsetY },
                    new XPoint { X = p2.X + offsetX, Y = p2.Y + offsetY }
                };
                }

                Console.WriteLine($"   🔹 {nazwaKolekcji} Linia #{i + 1}: " +
                    $"({region.Wierzcholki[0].X:F1},{region.Wierzcholki[0].Y:F1}) → " +
                    $"({region.Wierzcholki[1].X:F1},{region.Wierzcholki[1].Y:F1})");
            }
        }

        // 🟨 2. Rozstaw osobno linie z obu kolekcji
        RozstawKolekcje(_regionsDualRama, "DualRama", Szerokosc, Wysokosc);
        RozstawKolekcje(_regionsSkrzydlo, "Skrzydlo", Szerokosc, Wysokosc);

        await Task.CompletedTask;

        // if (zmienWymOkna) await ZmienWymiaryOkna(false);
    }

    private async Task ZmienWymiaryOkna()
    {
        if (_shapes == null || !_shapes.Any())
        {
            Console.WriteLine("❌ Brak kształtów do przeskalowania!");
            return;
        }

        // 1) Znajdź ramę przed zmianą (przyjmuję, że rama jest w _regionsDualRama i ma flagę Rama=true lub typ)
        var ramaBefore = _regionsDualRama?.FirstOrDefault(r => r.Rama)
                         ?? _regionsDualRama?.FirstOrDefault();

        if (ramaBefore == null)
        {
            Console.WriteLine("❌ Nie znaleziono regionu ramy.");
            return;
        }

        // zrób kopię ramy przed (potrzebna do obliczeń skrzydeł)
        var ramaBeforeCopy = GeometryUtils.CloneRegion(ramaBefore, _currentScale);

        // 2) Oblicz współczynnik skalowania ramy i utwórz 'ramaAfter' (przeskalowaną kopię)
        double oldMinX = ramaBeforeCopy.Wierzcholki.Min(p => p.X);
        double oldMinY = ramaBeforeCopy.Wierzcholki.Min(p => p.Y);
        double oldMaxX = ramaBeforeCopy.Wierzcholki.Max(p => p.X);
        double oldMaxY = ramaBeforeCopy.Wierzcholki.Max(p => p.Y);
        double oldWidth = oldMaxX - oldMinX;
        double oldHeight = oldMaxY - oldMinY;
        if (oldWidth <= 0 || oldHeight <= 0)
        {
            Console.WriteLine("❌ Nieprawidłowa rama (zerowy wymiar).");
            return;
        }

        // nowy wymiar ramy w jednostkach (Szerokosc/Wysokosc) - zakładamy, że rama ma zająć te wymiary
        double newWidth = Szerokosc;
        double newHeight = Wysokosc;

        double frameScaleX = newWidth / oldWidth;
        double frameScaleY = newHeight / oldHeight;

        // stwórz ramaAfter — przeskalowana kopia
        var ramaAfter = GeometryUtils.CloneRegion(ramaBeforeCopy, _currentScale);
        for (int i = 0; i < ramaAfter.Wierzcholki.Count; i++)
        {
            var p = ramaAfter.Wierzcholki[i];
            double newX = oldMinX + (p.X - oldMinX) * frameScaleX;
            double newY = oldMinY + (p.Y - oldMinY) * frameScaleY;
            ramaAfter.Wierzcholki[i] = new XPoint { X = newX, Y = newY };
        }

        // 3) Zastąp starą ramę w kolekcji regionów (żeby później regeneracja korzystała z aktualnej ramy)
        for (int i = 0; i < _regionsDualRama.Count; i++)
        {
            if (_regionsDualRama[i].Id == ramaBeforeCopy.Id)
            {
                _regionsDualRama[i] = ramaAfter;
                break;
            }
        }

        // 4) Skaluj skrzydła względem ramy przed/po
        _regionsSkrzydlo = GeometryUtils.SkalujSkrzydlaDoRamy(_regionsSkrzydlo, ramaBeforeCopy, ramaAfter);

        // 5) Dla każdego skrzydła -> zregeneruj elementy (użyj Twojej istniejącej logiki)
        //    Jeśli masz metodę GenerujElementyDlaRegionu, użyj jej; jeśli nie, użyj generator.AddElements tak jak w DodajWybranyKwadratOkna.
        foreach (var skrzydlo in _regionsSkrzydlo)
        {
            if (skrzydlo == null || string.IsNullOrEmpty(skrzydlo.Id)) continue;

            // jeśli masz generator dla tego regionu -> użyj AddElements
            if (_generatory != null && _generatory.TryGetValue(skrzydlo.Id, out var gen))
            {
                // upewnij się, że gen ma aktualne wymiary (przyda się w jego logice)
                var bb = skrzydlo.GetBoundingBox();
                gen.Szerokosc = (float)bb.Width;
                gen.Wysokosc = (float)bb.Height;

                gen.ElementyRamyRysowane?.Clear();
                gen.AddElements(new List<ShapeRegion> { skrzydlo }, skrzydlo.Id, _generatorStates, _regionsSkrzydlo, null);

                // aktualizuj _ksztaltyNaRegion
                _ksztaltyNaRegion[skrzydlo.Id] = new List<KsztaltElementu>(gen.ElementyRamyRysowane ?? Enumerable.Empty<KsztaltElementu>());
            }
            else
            {
                // fallback: jeżeli masz async GenerujElementyDlaRegionu(regionId, width, height)
                try
                {
                    await GenerujElementyDlaRegionu(skrzydlo.Id, (float)Szerokosc, (float)Wysokosc);
                }
                catch
                {
                    // brak implementacji - tylko log
                    Console.WriteLine($"⚠️ Nie znaleziono generatora dla regionu {skrzydlo.Id} i GenerujElementyDlaRegionu nie powiodło się.");
                }
            }
        }

        // 6) (opcjonalnie) zregeneruj elementy dla ramy również jeśli masz generator powiązany z ramą
        if (_generatory != null && _generatory.TryGetValue(ramaAfter.Id, out var genRama))
        {
            var bbRama = ramaAfter.GetBoundingBox();
            genRama.Szerokosc = (float)bbRama.Width;
            genRama.Wysokosc = (float)bbRama.Height;
            genRama.ElementyRamyRysowane?.Clear();
            genRama.AddElements(new List<ShapeRegion> { ramaAfter }, ramaAfter.Id, _generatorStates, _regionsSkrzydlo, null);
            _ksztaltyNaRegion[ramaAfter.Id] = new List<KsztaltElementu>(genRama.ElementyRamyRysowane ?? Enumerable.Empty<KsztaltElementu>());
        }

        // 7) Zbierz ksztalty i odśwież widok
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();

        // ustaw skalę canvas i pan (tak jak wcześniej)
        double canvasScaleX = Szerokosc / CanvasWidth;
        double canvasScaleY = Wysokosc / CanvasHeight;
        double canvasScale = Math.Min(canvasScaleX, canvasScaleY) * 0.9;
        _currentScale = canvasScale;
        _panX = (CanvasWidth / 2.0) - (Szerokosc / 2.0 * _currentScale);
        _panY = (CanvasHeight / 2.0) - (Wysokosc / 2.0 * _currentScale);

        _shapes = _shapes.Select(s =>
        {
            var bbox = s.GetBoundingBox();
            double scaleX = Szerokosc / bbox.Width;
            double scaleY = Wysokosc / bbox.Height;
            double scale = Math.Min(scaleX, scaleY);

            s.Scale(scale);
            return s;
        }).ToList();

        // Obliczamy nowy współczynnik skalowania względem aktualnego rozmiaru
        var bbox = _shapes
            .Select(s => s.GetBoundingBox())
            .Aggregate((b1, b2) => BoundingBox.Union(b1, b2));

        double scaleX = Szerokosc / bbox.Width;
        double scaleY = Wysokosc / bbox.Height;
        double scale = Math.Min(scaleX, scaleY); // zachowanie proporcji

        // Skalujemy wszystkie kształty
        foreach (var shape in _shapes)
        {
            shape.Szerokosc = Szerokosc;
            shape.Wysokosc = Wysokosc;

            shape.UpdatePoints(shape.Points.Select(p => new XPoint
            {
                X = p.X * scale,
                Y = p.Y * scale
            }).ToList());
        }


        await RedrawCanvas();
        await ApplyZoom(_currentScale);
        await RozstawLinie(false);

        Console.WriteLine($"✅ Zmieniono wymiary i dopasowano skrzydła do nowej ramy: {Szerokosc}x{Wysokosc}");
    }


    private async Task NormalizeGeneratedElements(ShapeRegion region, float nowaSzerokosc, float nowaWysokosc)
    {
        if (region == null || string.IsNullOrEmpty(region.Id))
        {
            Console.WriteLine("⚠️ Nieprawidłowy region.");
            return;
        }

        if (!_ksztaltyNaRegion.TryGetValue(region.Id, out var ksztaltyRegionu) || ksztaltyRegionu == null || ksztaltyRegionu.Count == 0)
        {
            Console.WriteLine($"⚠️ Brak wygenerowanych kształtów dla regionu {region.Id}.");
            return;
        }

        var regionPoints = region.Wierzcholki;
        if (regionPoints == null || regionPoints.Count < 3)
        {
            Console.WriteLine($"⚠️ Region {region.Id} ma za mało punktów.");
            return;
        }
        await GenerujElementyDlaRegionu(region.Id, nowaSzerokosc, nowaWysokosc);

        await Task.CompletedTask;
    }

    private async Task<bool> DodajWybranyKwadratOkna(string idRegion, List<XPoint> wierzcholki, double klikX, double klikY)
    {
        if (SelectedModelType == null || string.IsNullOrEmpty(SelectedModelType))
        {
            Console.WriteLine("❌ SelectedModelType jest puste, nie można kontynuować.");
            return false;
        }

        if (_generatorStates != null && _generatorStates.Count == 0)
        {
            if (SelectedModelType.Trim() != "Rama")
            {
                await _message.Info($"Wybierz konstrukcję typu rama!!!");
                return false;
            }
        }

        Console.WriteLine($"📦 -> DodajWybranyKwadratOkna wywołane z idRegion: {idRegion} SelectedRowIdType: {SelectedRowIdType} - konfmodeleelementy");

        var generator = new Generator
        {
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82
        };

        if (KonfiguracjeSystemu != null)
        {
            generator.KonfiguracjeSystemu = KonfiguracjeSystemu;
            generator.RowIdSystemu = Guid.Parse(SelectedSystemId);

            if (Guid.TryParse(SelectedRowIdType, out var rowIdModeluSzukaj))
            {
                generator.RowIdModelu = rowIdModeluSzukaj;

                var powiazanyModel = await Http.GetFromJsonAsync<MVCKonfModele>($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{SelectedRowIdType}");
                if (powiazanyModel != null)
                {
                    generator.MVCKonfModelu = powiazanyModel;

                    if (generator.MVCKonfModelu.KonfModele != null)
                        Console.WriteLine($"! Powiązany model: {generator.MVCKonfModelu.KonfModele[0].NazwaKonfiguracji} ile: {generator.MVCKonfModelu.KonfModele.Count()}");
                }
                else
                {
                    Console.WriteLine($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    await _message.Error($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    return false;
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                await _message.Error($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                return false;

            }
        }
        else
        {
            if (string.IsNullOrEmpty(SelectedSystemId))
            {
                Console.WriteLine("❌ KonfiguracjeSystemu jest puste, nie można kontynuować.");
                return false;
            }

            var kofiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");
            generator.KonfiguracjeSystemu = kofiguracjeSystemu;
        }

        generator.EdytowanyModel = WybranyModel;
        generator.TypKsztaltu = WybranyKsztalt;
        generator.Wierzcholki = wierzcholki;

        var regionReferencyjny = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .FirstOrDefault(r => r.Id == idRegion);

        if (regionReferencyjny == null || regionReferencyjny.Wierzcholki == null)
        {
            Console.WriteLine("❌ Brak regionu referencyjnego.");
            return false;
        }

        var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo);

        foreach (var r in wszystkieRegiony)
        {
            Console.WriteLine($"🔎 Region: {r.Id}, Typ: {r.TypKsztaltu}, Wierzcholki: {r.Wierzcholki?.Count} TypLiniiDzielacej: {r.TypLiniiDzielacej}");

            foreach (var linia in r.Wierzcholki)
            {
                Console.WriteLine($"🔎 Styczne linie w #1 - Wierzcholki: {(int)linia.X},{(int)linia.Y}");
            }
        }

        var zawarteRegiony = wszystkieRegiony
           .Where(r =>
               r.Wierzcholki != null &&
               r.Wierzcholki.Count >= 3 &&
               r.Wierzcholki.All(p => CzyPunktWNWielokacie(p, regionReferencyjny.Wierzcholki))
           )
           .ToList();

        foreach (var r in wszystkieRegiony)
        {
            Console.WriteLine($"🧩 Region: {r.Id} | Typ: {r.TypKsztaltu} | TypLiniiDzielacej: {r.TypLiniiDzielacej} | Wierzcholki: {r.Wierzcholki?.Count ?? 0}");

            if (r.Wierzcholki != null)
            {
                foreach (var p in r.Wierzcholki)
                    Console.WriteLine($"   Punkt: {p.X};{p.Y}");
            }
        }

        var wszystkieRegionyLinii = wszystkieRegiony
        .Select(r =>
        {
            if (r.Wierzcholki == null || r.Wierzcholki.Count < 2)
                return null;

            List<XPoint> punktyLinii;

            // Jeśli to prostokąt (4 punkty) — wyciągnij linię środkową
            if (r.Wierzcholki.Count >= 4)
            {
                var minX = r.Wierzcholki.Min(p => p.X);
                var maxX = r.Wierzcholki.Max(p => p.X);
                var minY = r.Wierzcholki.Min(p => p.Y);
                var maxY = r.Wierzcholki.Max(p => p.Y);

                // Jeśli wysokość > szerokości → linia pionowa
                if (Math.Abs(maxY - minY) > Math.Abs(maxX - minX))
                {
                    var midX = (minX + maxX) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = midX, Y = minY },
                    new XPoint { X = midX, Y = maxY }
                };
                }
                else // pozioma
                {
                    var midY = (minY + maxY) / 2;
                    punktyLinii = new List<XPoint>
                {
                    new XPoint { X = minX, Y = midY },
                    new XPoint { X = maxX, Y = midY }
                };
                }
            }
            else
            {
                punktyLinii = r.Wierzcholki;
            }

            return new ShapeRegion
            {
                Id = r.Id,
                TypKsztaltu = r.TypKsztaltu,
                TypLiniiDzielacej = r.TypLiniiDzielacej,
                Wierzcholki = punktyLinii
            };
        })
        .Where(r => r != null)
        .ToList();

        var styczneLinie = wszystkieRegionyLinii
            .Where(r =>
                r.Wierzcholki != null &&
                r.Wierzcholki.Count == 2 &&
                !CzyPunktyRowneSlupek(r.Wierzcholki[0], r.Wierzcholki[1])
            )
            .ToList();

        Console.WriteLine($"✅ Styczne linie: {styczneLinie.Count}");

        foreach (var linia in styczneLinie)
        {
            Console.WriteLine($"✅ Styczne linie: 🔹 Linia: {linia.Id}, {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
        }

        bool czyRegionZawieraSlupekRuchomy = false;
        bool stronaLewa = false;
        bool stronaPrawa = false;

        if (styczneLinie.Count() > 0)
            Console.WriteLine($"⚠️⚠️⚠️ styczneLinie region rama/skrzydło: {styczneLinie.Count()} zawarteRegiony: {zawarteRegiony.Count()} styczneLinie:{styczneLinie[styczneLinie.Count() - 1].TypKsztaltu}  ⚠️");

        if (styczneLinie.Any())
        {

            // Filtrujemy linie typu "Słupek ruchomy"
            var slupkiRuchome = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek ruchomy")
                .ToList();

            if (slupkiRuchome.Any())
            {
                czyRegionZawieraSlupekRuchomy = true;
                Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy.");
                if (slupkiRuchome.Count == 1)
                {
                    // Mamy dokładnie jeden słupek → sprawdzamy, po której stronie kliknięto
                    var sl = slupkiRuchome[0];
                    double srodekX = (sl.Wierzcholki[0].X + sl.Wierzcholki[1].X) / 2;

                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2} Ilość słupków: {slupkiRuchome.Count()}");

                    if (klikX > srodekX)
                    {

                        stronaLewa = true;
                        Console.WriteLine("⬅️ Słupek ruchomy po lewej stronie.");
                    }
                    else
                    {
                        stronaPrawa = true;
                        Console.WriteLine("➡️ Słupek ruchomy po prawej stronie.");
                    }
                }
                else if (slupkiRuchome.Count() >= 2)
                {
                    // Średnia X dwóch pierwszych punktów słupka
                    double srodekX1 = slupkiRuchome[0].Wierzcholki[0].X;
                    double srodekX2 = slupkiRuchome[1].Wierzcholki[0].X;
                    double srodekX = (srodekX1 + srodekX2) / 2;

                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2} Ilość słupków: {slupkiRuchome.Count()}");

                    // Określamy stronę kliknięcia względem środka słupka
                    if (klikX > srodekX)
                    {
                        stronaLewa = true;
                        Console.WriteLine("⬅️ Słupek ruchomy po lewej stronie.");

                    }
                    else
                    {
                        stronaPrawa = true;
                        Console.WriteLine("➡️ Słupek ruchomy po prawej stronie.");
                    }
                }
                else
                {
                    // Jeżeli jest więcej niż jeden słupek w regionie — uznajemy, że są po obu stronach
                    stronaLewa = true;
                    stronaPrawa = true;
                    Console.WriteLine("↔️ Słupek ruchomy po obu stronach.");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka ruchomego.");
            }

            var slupkiStale = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek stały")
                .ToList();

            if (slupkiStale.Any())
            {
                double srodekX1 = slupkiStale[0].Wierzcholki[0].X;
                double srodekX2 = slupkiStale[1].Wierzcholki[0].X;
                double srodekX = (srodekX1 + srodekX2) / 2;

                Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2} Ilość słupków stałych: {slupkiStale.Count()}");

                // Określamy stronę kliknięcia względem środka słupka
                if (klikX > srodekX)
                {
                    stronaLewa = true;
                    Console.WriteLine("⬅️ Słupek stały po lewej stronie.");

                }
                else
                {
                    stronaPrawa = true;
                    Console.WriteLine("➡️ Słupek stały po prawej stronie.");
                }

                if (slupkiRuchome.Count() >= 2)
                {
                    stronaLewa = true;
                    stronaPrawa = true;
                    Console.WriteLine("➡️ Słupek stały po prawej ilewej stronie.");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka stałego.");
            }

            generator.RuchomySlupekPoLewej = stronaLewa;
            generator.RuchomySlupekPoPrawej = stronaPrawa;
            Console.WriteLine($"⚠️ Próbuję ustawić w generatorze słupek ruchomy lub stały TA SAMA ZMIENNA! generator.RuchomySlupekPoLewej :{generator.RuchomySlupekPoLewej} generator.RuchomySlupekPoPrawej :{generator.RuchomySlupekPoPrawej}");

        }
        else
        {
            Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera linii stycznych.");
        }

        if (czyRegionZawieraSlupekRuchomy && SelectedModelType != "Rama")
        {

            bool czyZawieraSlupekRuchomyWPowiazanymModelu = _generatory
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfModele != null &&
                     state.Value.MVCKonfModelu.KonfModele.Any(ks => ks.Typ == "Skrzydło z słupkiem ruchomym")
                 );

            Console.WriteLine($"✅✅✅ Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów. Model-Typ: {WybranyModel.Typ} czyZawieraSlupekRuchomyWPowiazanymModelu: {czyZawieraSlupekRuchomyWPowiazanymModelu}");

            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {

                if (WybranyModel.Typ != "Skrzydło z słupkiem ruchomym")
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj wcześniej słupek ruchomy do konstrukcji.",
                        2.0
                    );
                    return false;
                }

            }

        }

        int ileRegionWSkrzydleZawieraSlupekRuchomy = _regionsSkrzydlo.Where(x => x.TypLiniiDzielacej == "Słupek ruchomy").Count();

        int ileJestDodanychSlRuchWRegionach = _generatory
            .SelectMany(x => x.Value.Region) // spłaszczamy kolekcje regionów
            .Count(v => v.TypLiniiDzielacej == "Słupek ruchomy");

        if (generator.MVCKonfModelu == null || generator.MVCKonfModelu.KonfModele == null || generator == null) return false;

        int ileRegionDRZawieraSlupekRuchomy = generator.MVCKonfModelu.KonfModele.Where(x => x.Typ == "Skrzydło z słupkiem ruchomym").Count();

        if (WybranyModel == null)
        {
            await _message.Warning(
                "Błąd wyboru modelu!!!!",
                2.0
            );
            return false;
        }

        Console.WriteLine($"🟩 Ile regionów skrzydła zawiera słupek ruchomy: {ileRegionWSkrzydleZawieraSlupekRuchomy} - Ile regionów DR zawiera słupek ruchomy: {ileRegionDRZawieraSlupekRuchomy} - SelectedModelType: {SelectedModelType} -> ileJestDodanychSlRuchWRegionach: {ileJestDodanychSlRuchWRegionach} Wybrany typ {WybranyModel.Typ}");

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && ileRegionDRZawieraSlupekRuchomy == 0 && SelectedModelType != "Rama" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            Console.WriteLine($"🟩 Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego! SelectedModelType: {SelectedModelType}");

            await _message.Warning(
                "1# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;

        }

        if (ileJestDodanychSlRuchWRegionach > ileRegionDRZawieraSlupekRuchomy && SelectedModelType != "Rama" && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            await _message.Warning(
                "W regionie skrzydła jest już dodany słupek ruchomy. Nie można dodać więcej słupków ruchomych do tej konstrukcji.",
                2.0
            );
            return false;
        }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == ileJestDodanychSlRuchWRegionach && SelectedModelType != "Rama" && WybranyModel.Typ != "Skrzydło z słupkiem ruchomym" && SelectedModelType != "Słupek stały" && SelectedModelType != "Skrzydło")
        {
            await _message.Warning(
                "2# Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                2.0
            );
            return false;
        }

        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && WybranyModel.Typ == "Skrzydło z słupkiem ruchomym")
        {
            await _message.Warning(
                "Dodajesz konstrukcję z słupkiem ruchomym, W konstrukcji nie ma podzaiłu z słupkiem ruchomym",
                2.0
            );
            return false;
        }

        double minX = 0;
        double maxX = 0;
        double minY = 0;
        double maxY = 0;
        string linieDzielace = "";
        List<XPoint> WierzcholkiWartosciNominalne = new();
        WierzcholkiWartosciNominalne.AddRange(wierzcholki);

        Console.WriteLine($"📐📐📐 SelectedModelType  = {SelectedModelType} Ilość wierzchołków: {wierzcholki.Count()} 📐📐📐");

        generator.ElementLiniowy = SelectedModelType.Trim() == "Słupek stały";

        if (SelectedModelType.Trim() == "Rama")
        {

            var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionDualRama != null)
            {
                var regionPoints = wybranyRegionDualRama.Wierzcholki;

                if (regionPoints == null || regionPoints.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej ?? idRegion;
                linieDzielace = wybranyRegionDualRama.TypLiniiDzielacej ?? "Brak";

                minX = regionPoints.Min(p => p.X);
                maxX = regionPoints.Max(p => p.X);
                minY = regionPoints.Min(p => p.Y);
                maxY = regionPoints.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = 0;
                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej;

                Console.WriteLine($"📐📐📐 Region Zindeks = 0 ID: {wybranyRegionDualRama.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc} generator.Wierzcholki.Count():{generator.Wierzcholki.Count()}");

                // stronaLewa = false;
                //stronaPrawa = false;

                generator.RuchomySlupekPoLewej = false;
                generator.RuchomySlupekPoPrawej = false;

                generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);//Rama nie ma sąsiada dla tego null

            }
        }

        // Oblicz przesunięcia tylko dla skrzydeł
        double przesLewo = 0, przesPrawo = 0, przesGora = 0, przesDol = 0;

        // Przygotowanie stanu generatora
        var state = new GeneratorState
        {
            Id = _generatorStates.Count + 1,
            IdRegion = idRegion,
            ZIndeks = generator.Zindeks,
            RowIdSystemu = Guid.Parse(SelectedSystemId),
            RowIdModelu = Guid.TryParse(SelectedRowIdType, out var rowIdModelu) ? rowIdModelu : (Guid?)null,
            MVCKonfModelu = generator.MVCKonfModelu,
            WybranyModel = WybranyModel,
            WybranyKsztalt = WybranyKsztalt,
            IdRegionWarstwaNizej = generator.IdRegionuPonizej,
            Wierzcholki = generator.ElementyRamyRysowane.SelectMany(k => k.Wierzcholki ?? new List<XPoint>()).Distinct().ToList(),
            WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne,
            LinieDzielace = linieDzielace,
            SlupekRuchomyPoLewejStronie = stronaLewa,
            SlupekRuchomyPoPrawejStronie = stronaPrawa,
            ListaKwadratow = new List<DaneKwadratu>(),
            ElementLiniowy = generator.ElementLiniowy,
        };

        Console.WriteLine($"✅ Zapisano wierzchołki dla słupka stałego: {string.Join(", ", state.Wierzcholki.Select(p => $"({p.X:F2},{p.Y:F2})"))}");

        var linie = ExtractLinesFromSquare(WierzcholkiWartosciNominalne);

        foreach (var linia in linie)
        {
            if (linia.Count != 2) continue;

            var katSzukaj = ObliczKatLinii(linia);

            Console.WriteLine($"🔎 DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° w stanie ID: {state.Id}, IdRegion: {state.IdRegion}, WybranyTyp: {state.WybranyKsztalt}");

            var sasiedzi = ZnajdzSasiada(
                linia,
                _generatorStates.Values.ToList(),
                katSzukaj,
                state.SlupekRuchomyPoLewejStronie,
                state.SlupekRuchomyPoPrawejStronie,
                state.IdRegion,
                WybranyModel.Typ == "Skrzydło z słupkiem ruchomym",
                0.02
            );

            foreach (var s in sasiedzi)
            {
                Console.WriteLine($"   🔹 Sasiad: WybranyTyp: {s.WybranyTyp} linia.Count():{linia.Count()}");
            }

            foreach (var s in linia)
            {
                Console.WriteLine($"   🔹 Sasiad: WybranyTyp: X:{s.X} Y:{s.Y}");
            }

            // przykład pobrania najlepszego sąsiada
            var najlepszySasiad = sasiedzi.FirstOrDefault();

            if (sasiedzi != null && sasiedzi.Any())
            {
                double minX1 = WierzcholkiWartosciNominalne.Min(p => p.X);
                double maxX1 = WierzcholkiWartosciNominalne.Max(p => p.X);
                double minY1 = WierzcholkiWartosciNominalne.Min(p => p.Y);
                double maxY1 = WierzcholkiWartosciNominalne.Max(p => p.Y);

                for (int i = 0; i < sasiedzi.Count; i++)
                {
                    var s = sasiedzi[i];
                    var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                    if (stan?.WierzcholkiWartosciNominalne == null) continue;

                    double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                    double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                    double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                    double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                    // różnica dopasowania
                    double roznicaDopasowania = Math.Abs(minX1 - stanMinX) +
                                               Math.Abs(maxX1 - stanMaxX) +
                                               Math.Abs(minY1 - stanMinY) +
                                               Math.Abs(maxY1 - stanMaxY);

                    Console.WriteLine(
                        $"   🔹 Sasiad {i + 1}: IdRegionu: {s.IdRegionu}, RowIdElementu: {s.RowIdElementu}, " +
                        $"Dopasowanie: {roznicaDopasowania:F4} ZIndeks:{s.ZIndeks} id:{s.Id} " +
                        $"WybranyTyp: {s.WybranyTyp} MaSlupekRuchomy: {s.MaSlupekRuchomy}");
                }

                // 🔹 1. Szukamy "Słupka ruchomego"
                najlepszySasiad = sasiedzi
                    .Where(s => s.WybranyTyp == "Słupek ruchomy")
                    .OrderBy(s =>
                    {
                        var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                        if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                        double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                        double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                        double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                        double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                        return Math.Abs(minX1 - stanMinX) +
                               Math.Abs(maxX1 - stanMaxX) +
                               Math.Abs(minY1 - stanMinY) +
                               Math.Abs(maxY1 - stanMaxY);
                    })
                    .FirstOrDefault();

                // 🔹 2. Jeśli nie znaleziono → szukamy innych
                if (najlepszySasiad == null)
                {
                    najlepszySasiad = sasiedzi
                        .Where(s => s.WybranyTyp != "Słupek ruchomy")
                        .OrderBy(s =>
                        {
                            var stan = _generatorStates.Values.FirstOrDefault(gs => gs.Id == s.Id);
                            if (stan?.WierzcholkiWartosciNominalne == null) return double.MaxValue;

                            double stanMinX = stan.WierzcholkiWartosciNominalne.Min(p => p.X);
                            double stanMaxX = stan.WierzcholkiWartosciNominalne.Max(p => p.X);
                            double stanMinY = stan.WierzcholkiWartosciNominalne.Min(p => p.Y);
                            double stanMaxY = stan.WierzcholkiWartosciNominalne.Max(p => p.Y);

                            return Math.Abs(minX1 - stanMinX) +
                                   Math.Abs(maxX1 - stanMaxX) +
                                   Math.Abs(minY1 - stanMinY) +
                                   Math.Abs(maxY1 - stanMaxY);
                        })
                        .FirstOrDefault();
                }
            }

            Console.WriteLine(
                $"🔎 DodajWybranyKwadratOkna -> Sprawdzam linię o kącie {katSzukaj}° - " +
                $"Najlepszy sąsiad: {(najlepszySasiad != null ? najlepszySasiad.RowIdElementu : "Brak")}"
            );

            var rowId = ZnajdzKonfiguracjeDlaLinii(linia, state, stronaLewa, stronaPrawa, idRegion, "Słupek ruchomy");

            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = linia,
                RowIdElementu = rowId,
                RowIdSasiada = najlepszySasiad?.RowIdElementu ?? Guid.Empty,
                RowIdRegionuSasiada = najlepszySasiad?.IdRegionu ?? "",
                KatLinii = katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                Strona = StronaSzukaj(
                        katSzukaj,
                        linia,
                        WierzcholkiWartosciNominalne.Min(p => p.Y),
                        WierzcholkiWartosciNominalne.Max(p => p.Y),
                        WierzcholkiWartosciNominalne.Min(p => p.X),
                        WierzcholkiWartosciNominalne.Max(p => p.X)
                    )
            });
        }

        if (SelectedModelType.ToLower().Trim() == "słupek stały")
        {

            if (!styczneLinie.Any())
            {
                Console.WriteLine($"✅ Region {idRegion} nie zawiera słupka stałego.");
                return false;
            }

            Console.WriteLine($"🔹 Znaleziono {styczneLinie.Count} potencjalnych linii dla słupka stałego");

            generator.Zindeks = 1;

            // 🔹 Spróbuj znaleźć linię typu „Słupek stały”
            var liniaStala = styczneLinie
                .Where(s =>
                    !string.IsNullOrWhiteSpace(s.TypLiniiDzielacej) &&
                    s.TypLiniiDzielacej.ToLower().Contains("słupek") &&
                    s.Wierzcholki != null &&
                    s.Wierzcholki.Count == 2)
                .FirstOrDefault(s =>
                    Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) > 0.01 ||
                    Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01);

            foreach (var linia in styczneLinie)
            {
                Console.WriteLine($"🔹 Sprawdzana linia: {linia.Id}, TypLiniiDzielacej: '{linia.TypLiniiDzielacej}', Wierzcholki: {linia.Wierzcholki[0].X},{linia.Wierzcholki[0].Y} → {linia.Wierzcholki[1].X},{linia.Wierzcholki[1].Y}");
            }

            // 🔹 Jeśli nie znaleziono, spróbuj automatycznie dobrać pionową linię
            if (liniaStala == null)
            {

                Console.WriteLine("⚠️ Nie znaleziono linii z TypLiniiDzielacej='Słupek stały'. Szukam pionowej linii jako zamiennika...");
                liniaStala = styczneLinie
                    .Where(s => s.Wierzcholki != null && s.Wierzcholki.Count == 2)
                    .FirstOrDefault(s =>
                        Math.Abs(s.Wierzcholki[0].X - s.Wierzcholki[1].X) < 0.01 &&  // pionowa
                        Math.Abs(s.Wierzcholki[0].Y - s.Wierzcholki[1].Y) > 0.01);  // ale nie zerowa wysokość
            }

            if (liniaStala == null)
            {
                Console.WriteLine("❌ Nadal nie znaleziono poprawnej linii słupka (brak dwóch różnych punktów lub pionowej linii).");
                return false;
            }

            styczneLinie = styczneLinie.Where(e => e.TypLiniiDzielacej == "Słupek stały").ToList();//??????????????????????

            // 🔹 Określ orientację
            bool pionowy = Math.Abs(liniaStala.Wierzcholki[0].X - liniaStala.Wierzcholki[1].X) < 0.01;
            bool poziomy = Math.Abs(liniaStala.Wierzcholki[0].Y - liniaStala.Wierzcholki[1].Y) < 0.01;

            var orientacja = pionowy ? "Pionowa" : poziomy ? "Pozioma" : "Skośna";
            Console.WriteLine($"📏 Rozpoznano linię: {orientacja}");

            // 🔹 Oblicz kąt
            var katSzukaj = ObliczKatLinii(liniaStala.Wierzcholki);
            Console.WriteLine($"📐 Kąt słupka stałego: {katSzukaj:F2}°");

            generator.RowIdModelu = generator.MVCKonfModelu.KonfSystem.FirstOrDefault().RowId;// Pobieram RowIdModelu z konfiguracji systemu

            // 🔹 Zapisz dane do stanu
            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = liniaStala.Wierzcholki,
                RowIdElementu = generator.RowIdModelu,
                RowIdSasiada = Guid.Empty,
                RowIdRegionuSasiada = "",
                KatLinii = katSzukaj,
                OffsetBottom = 0,
                OffsetTop = 0,
                OffsetLeft = 0,
                OffsetRight = 0,
                Strona = "Środek",
                BoolElementLinia = true
            });

            // 🔹 Aktualizacja stanu
            state.ZIndeks = generator.Zindeks;
            state.WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne;
            generator.RuchomySlupekPoLewej = false;
            generator.RuchomySlupekPoPrawej = false;
            generator.ElementLiniowy = true;

            Console.WriteLine($"✅ Rozpoczynam przekazywanie AddElements ID: {idRegion}");

            generator.AddElements(
                new List<ShapeRegion> { _regionsSkrzydlo.LastOrDefault(r => r.Id == idRegion) },
                idRegion,
                _generatorStates,
                _regionsDualRama,
                state.ListaKwadratow
            );

            Console.WriteLine($"📐📐📐 Słupek stały zakończony pomyślnie 📐📐📐");

        }


        if (SelectedModelType.Trim() == "Skrzydło" || SelectedModelType.Trim() == "Skrzydło z słupkiem ruchomym")
        {
            var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);
            linieDzielace = wybranyRegionSkrzydlo?.TypLiniiDzielacej ?? "Brak";

            if (wybranyRegionSkrzydlo != null)
            {
                var regionPointsSkrzydlo = wybranyRegionSkrzydlo.Wierzcholki;

                if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionSkrzydlo.IdRegionuPonizej ?? idRegion + "-BLAD";

                minX = regionPointsSkrzydlo.Min(p => p.X);
                maxX = regionPointsSkrzydlo.Max(p => p.X);
                minY = regionPointsSkrzydlo.Min(p => p.Y);
                maxY = regionPointsSkrzydlo.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = SelectedModelType == "Skrzydło z słupkiem ruchomym" ? 1 : 2;

                //luzy wynikahjące z przesunięcia

                // najpierw wczytujesz region i dodajesz jego dane
                var regionDoDodania = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

                if (regionDoDodania != null)
                {
                    // ✅ KOPIOWANIE punktów do regionu, na którym operuje AddElements
                    regionDoDodania.Wierzcholki = WierzcholkiWartosciNominalne
                        .Select(p => new XPoint { X = p.X, Y = p.Y })
                        .ToList();

                    // ✅ Najpierw przesuń punkty
                    await WyliczObszarSkrzydla(
                        state,
                        przesLewo, przesPrawo,
                        przesGora, przesDol,
                        stronaLewa, stronaPrawa,
                        generator, regionDoDodania
                    );
                    // 4. Zapisz do stanu
                    state.ZIndeks = generator.Zindeks;
                    state.Wierzcholki = regionDoDodania.Wierzcholki;
                    state.WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne;

                    generator.RuchomySlupekPoLewej = stronaLewa;
                    generator.RuchomySlupekPoPrawej = stronaPrawa;

                    // 5. Dodaj elementy
                    generator.AddElements(new List<ShapeRegion> { regionDoDodania }, idRegion, _generatorStates, _regionsSkrzydlo, state.ListaKwadratow);
                }
                else
                {
                    Console.WriteLine($"❌ Nie znaleziono regionu skrzydła o ID: {idRegion}");

                }

            }
            else
            {
                Console.WriteLine($"📐📐📐 wybranyRegionSkrzydlo == null");
            }
        }

        //   Console.WriteLine($"✅ ElementyRamyRysowane.Count: {generator.ElementyRamyRysowane.Count}");

        if (generator.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine("❌ Brak elementów do rysowania!");
            return false;
        }

        // Console.WriteLine($"📦📦📦 Generowanie elementów ListaKwadratow: {state.ListaKwadratow.Count}.");

        // Console.WriteLine($"📦📦📦 Dodano elementy do regionu {idRegion} o typie {SelectedModelType}. przesLewo:{przesLewo}, przesPrawo:{przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol} 📦📦📦");
        // Zapis do słownika i aktualizacja listy
        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        // Zapisz stan generatora
        _generatory[idRegion] = generator;

        ZapiszStanGeneratora(idRegion, state);

        //await Task.CompletedTask;

        return true;
    }

    private static bool CzyPunktyRowneSlupek(XPoint p1, XPoint p2, double epsilon = 0.001)
    {
        return Math.Abs(p1.X - p2.X) < epsilon && Math.Abs(p1.Y - p2.Y) < epsilon;
    }

    private async Task<ShapeRegion> WyliczObszarSkrzydla(GeneratorState state,
      double przesLewo, double przesPrawo, double przesGora, double przesDol,
      bool stronaLewa, bool stronaPrawa, Generator generator,
      ShapeRegion _regionsSkrzydlo)
    {

        if (_regionsSkrzydlo == null)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla-> Nie znaleziono regionu o podanym ID.");
            return null;
        }

        var regionPointsSkrzydlo = _regionsSkrzydlo.Wierzcholki;

        if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
        {
            Console.WriteLine("❌ WyliczObszarSkrzydla->  Region ma za mało punktów.");
            return null;
        }

        // Oblicz bounding box z obecnych punktów
        double minX = regionPointsSkrzydlo.Min(p => p.X);
        double maxX = regionPointsSkrzydlo.Max(p => p.X);
        double minY = regionPointsSkrzydlo.Min(p => p.Y);
        double maxY = regionPointsSkrzydlo.Max(p => p.Y);


        // Pobierz przesunięcia z boków
        foreach (var bok in state.ListaKwadratow)
        {

            var polaczenieWartosci = await PobierzPolaczenia(bok.RowIdSasiada, bok.RowIdElementu, bok.Strona ?? "NaN");
            var spolaczenieStrona = polaczenieWartosci.FirstOrDefault();

            double przesY = spolaczenieStrona != null
                ? Math.Abs(spolaczenieStrona.PrzesuniecieY)
                : 0;

            Console.WriteLine($"📦 WyliczObszarSkrzydla-> Sprawdzam bok: {bok.RowIdElementu}, Strona: {bok.Strona} przesY: {przesY}");

            // ustaw z połączenia
            switch (bok.Strona.ToLower())
            {
                case "lewa": przesLewo = przesY; break;
                case "prawa": przesPrawo = przesY; break;
                case "góra": przesGora = przesY; break;
                case "dół": przesDol = przesY; break;
            }

            // fallback tylko gdy brak sąsiada
            if (bok.RowIdSasiada == Guid.Empty)
            {
                var konf = generator.KonfiguracjeSystemu
                    .FirstOrDefault(s => s.RowId == bok.RowIdElementu);

                if (konf != null)
                {
                    double fallback = -((konf.PoziomDol ?? 0) - (konf.PoziomOsSymetrii ?? 0));

                    Console.WriteLine($"📦 WyliczObszarSkrzydla-> bok.RowIdElementu: {bok.RowIdElementu} konf.PoziomDol: {(konf.PoziomDol ?? 0)} - konf.PoziomOsSymetrii: {(konf.PoziomOsSymetrii ?? 0)} / przesLewo: {przesLewo} przesPrawo: {przesPrawo}");

                    switch (bok.Strona.ToLower())
                    {
                        case "lewa": if (stronaLewa) przesLewo = fallback; break;
                        case "prawa": if (stronaPrawa) przesPrawo = fallback; break;
                        case "góra": przesGora = fallback; break;
                        case "dół": przesDol = fallback; break;
                    }
                }
            }
        }

        // Przesuń punkty konturu
        for (int i = 0; i < regionPointsSkrzydlo.Count; i++)
        {
            var punkt = regionPointsSkrzydlo[i];

            if (Math.Abs(punkt.X - minX) < 0.1)
                punkt.X += przesLewo;
            else if (Math.Abs(punkt.X - maxX) < 0.1)
                punkt.X -= przesPrawo;

            if (Math.Abs(punkt.Y - maxY) < 0.1)
                punkt.Y -= przesDol;
            else if (Math.Abs(punkt.Y - minY) < 0.1)
                punkt.Y += przesGora;

            regionPointsSkrzydlo[i] = punkt;
        }

        double minXSPRAWDZENIE = regionPointsSkrzydlo.Min(p => p.X);

        Console.WriteLine($"📦📦📦 WyliczObszarSkrzydla-> Po przesunięciu minX: {minXSPRAWDZENIE}, przesLewo: {przesLewo}, przesPrawo: {przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol}");


        if (state != null && state.ListaKwadratow.Count() > 0)
        {
            state.ListaKwadratow[state.ListaKwadratow.Count() - 1].OffsetLeft = przesLewo;
            state.ListaKwadratow[state.ListaKwadratow.Count() - 1].OffsetRight = przesPrawo;
            state.ListaKwadratow[state.ListaKwadratow.Count() - 1].OffsetTop = przesGora;
            state.ListaKwadratow[state.ListaKwadratow.Count() - 1].OffsetBottom = przesDol;
        }

        _regionsSkrzydlo.Wierzcholki = regionPointsSkrzydlo;

        return _regionsSkrzydlo;
    }


    private void UsunOstatniKsztaltZGeneratora(string idRegion, Generator generator)
    {
        if (string.IsNullOrWhiteSpace(idRegion))
        {
            Console.WriteLine("⚠️ UsunOstatniKsztaltZGeneratora-> IdRegion nie został podany");
            return;
        }

        if (generator?.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine($"ℹ️ UsunOstatniKsztaltZGeneratora-> Brak kształtów do usunięcia w regionie {idRegion}");
            return;
        }

        // Usuń ostatni kształt
        var ostatni = generator.ElementyRamyRysowane.Last();
        generator.ElementyRamyRysowane.Remove(ostatni);

        Console.WriteLine($"🗑️ UsunOstatniKsztaltZGeneratora-> Usunięto ostatni kształt z regionu {idRegion}");

        // Aktualizacja mapy regionów
        if (generator.ElementyRamyRysowane.Count == 0 && _ksztaltyNaRegion.ContainsKey(idRegion))
        {
            _ksztaltyNaRegion.Remove(idRegion);
            Console.WriteLine($"📭 UsunOstatniKsztaltZGeneratora-> Usunięto wpis z _ksztaltyNaRegion dla {idRegion}");
        }
        else
        {
            _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        }

        // Odświeżenie listy globalnej
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
    }

    private async Task<List<PrzesuniecieDto>> PobierzPolaczenia(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 PobierzPolaczenia-> Pobieram przesunięcia z: {zewId} w: {wewId} strona: {strona}");

            var response = await Http.GetAsync($"api/konfpolaczenie/find-shifts/{zewId}/{wewId}/{strona}");

            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<PrzesuniecieDto>>();
                return lista ?? new List<PrzesuniecieDto>();
            }
            else
            {
                Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ PobierzPolaczenia-> Błąd podczas pobierania przesunięć: {ex.Message}");
        }

        return new List<PrzesuniecieDto>();
    }


    private async Task<List<KonfPolaczenie>> PobierzPolaczeniaAll(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 Pobieram dane połączeń z: {zewId} w: {wewId} strona: {strona}");
            var response = await Http.GetAsync($"api/konfpolaczenie/find-by-elements-all/{zewId}/{wewId}");
            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>();
                return lista ?? new List<KonfPolaczenie>();
            }
            else
            {
                Console.WriteLine($"❌ Błąd podczas pobierania połączeń: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd podczas pobierania połączenia: {ex.Message}");
        }

        return new List<KonfPolaczenie>();
    }

    public static string StronaSzukaj(int kat, List<XPoint> linia, double regionMinY, double regionMaxY, double regionMinX, double regionMaxX)
    {
        string strona = "";
        if (kat == 0 || kat == 180) // Linie poziome
        {
            double avgY = (linia[0].Y + linia[1].Y) / 2;

            if (Math.Abs(avgY - regionMinY) < 0.1) strona = "góra";
            else if (Math.Abs(avgY - regionMaxY) < 0.1) strona = "dół";
        }
        else if (kat == 90 || kat == 270) // Linie pionowe
        {
            double avgX = (linia[0].X + linia[1].X) / 2;

            if (Math.Abs(avgX - regionMinX) < 0.1) strona = "lewa";
            else if (Math.Abs(avgX - regionMaxX) < 0.1) strona = "prawa";
        }
        return strona;
    }

    public static int ObliczKatLinii(List<XPoint> linia)
    {
        if (linia == null || linia.Count != 2)
            return 0;

        var p1 = linia[0];
        var p2 = linia[1];

        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;

        double angleRadians = Math.Atan2(dy, dx); // uwzględnia znak
        double angleDegrees = angleRadians * (180.0 / Math.PI);

        if (angleDegrees < 0)
            angleDegrees += 360; // zakres 0–360

        return (int)Math.Round(angleDegrees);
    }

    public static Guid ZnajdzKonfiguracjeDlaLinii(
        List<XPoint> linia,
        GeneratorState stan,
        bool slRuchStroLewa,
        bool slRuchStroPrawa,
        string obecnyRegionId,
        string typSlupka)
    {
        if (linia == null || linia.Count != 2)
            return Guid.Empty;

        var p1 = linia[0];
        var p2 = linia[1];

        bool jestPionowa = Math.Abs(p1.X - p2.X) < 0.01;
        bool jestPozioma = Math.Abs(p1.Y - p2.Y) < 0.01;

        double minX = stan.WierzcholkiWartosciNominalne.Min(v => v.X);
        double maxX = stan.WierzcholkiWartosciNominalne.Max(v => v.X);
        double minY = stan.WierzcholkiWartosciNominalne.Min(v => v.Y);
        double maxY = stan.WierzcholkiWartosciNominalne.Max(v => v.Y);
        double tolerancja = 1.0; // np. 1 mm


        if (stan?.MVCKonfModelu?.KonfSystem == null)
            return Guid.Empty;

        string slLewa = slRuchStroLewa ? typSlupka : "";
        string slPrawa = slRuchStroPrawa ? typSlupka : "";

        Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> typ: {typSlupka}" +
                          $" jestPionowa: {jestPionowa}, jestPozioma: {jestPozioma}, " +
                          $"slLewa: {slLewa}, slPrawa: {slPrawa}");

        Guid znaleziony = Guid.Empty;

        // 1️⃣ Najpierw próba z uwzględnieniem słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            Console.WriteLine($"🔍 ZnajdzKonfiguracjeDlaLinii -> typ: {konf.Typ} - wartość w pętli");

            if (jestPionowa)
            {
                if (Math.Abs(p1.X - minX) < tolerancja && konf.WystepujeLewa &&
                    !string.IsNullOrEmpty(slLewa) && konf.Typ.Contains(slLewa))
                {
                    Console.WriteLine($"✅ [Słupkowy] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (Math.Abs(p1.X - maxX) < tolerancja && konf.WystepujePrawa &&
                    !string.IsNullOrEmpty(slPrawa) && konf.Typ.Contains(slPrawa))
                {
                    Console.WriteLine($"✅ [Słupkowy] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Słupkowy] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Słupkowy] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        // 2️⃣ Jeśli nie znaleziono — próba bez słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa &&
                    (string.IsNullOrEmpty(slLewa) || !konf.Typ.Contains(typSlupka)))
                {
                    Console.WriteLine($"✅ [Bez słupka] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.X > 85 && konf.WystepujePrawa &&
                    (string.IsNullOrEmpty(slPrawa) || !konf.Typ.Contains(typSlupka)))
                {
                    Console.WriteLine($"✅ [Bez słupka] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Bez słupka] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Bez słupka] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        // 3️⃣ Jeśli dalej nic — bierzemy pierwszą pasującą stronę
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa)
                {
                    Console.WriteLine($"✅ [Fallback] Lewa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.X > 85 && konf.WystepujePrawa)
                {
                    Console.WriteLine($"✅ [Fallback] Prawa -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                {
                    Console.WriteLine($"✅ [Fallback] Góra -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }

                if (p1.Y > 75 && konf.WystepujeDol)
                {
                    Console.WriteLine($"✅ [Fallback] Dół -> {konf.RowId} Typ:{konf.Typ}");
                    return konf.RowId;
                }
            }
        }

        Console.WriteLine("❌ ZnajdzKonfiguracjeDlaLinii -> Nie znaleziono konfiguracji.");
        return znaleziony;
    }


    public List<SasiadInfo> ZnajdzSasiada(
        List<XPoint> linia,
        List<GeneratorState> wszystkieStany,
        int kat,
        bool ruchomySlupekPoLewej,
        bool ruchomySlupekPoPrawej,
        string obecnyRegionId,
        bool czyModelMaSlupekRuchomy = false,
        double tolerancja = 0.03)
    {
        var pasujace = new List<SasiadInfo>();

        // Walidacja wejścia
        if (linia == null || linia.Count != 2)
        {
            return new List<SasiadInfo>
        {
            new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = "",
                ZIndeks = -1,
                MaSlupekRuchomy = false,
                Id = 0,
                WybranyTyp = "BRAK"
            }
        };
        }

        Console.WriteLine($"🔍 ZnajdzSasiada-> Szukam sąsiada dla linii w regionie {obecnyRegionId} kat: {kat} " +
              $" model ma słupek ruchomy: {czyModelMaSlupekRuchomy}");

        // Console.WriteLine(
        //     $"🔍 ZnajdzSasiada-> Szukam sąsiada dla linii w regionie {obecnyRegionId} kat: {kat} " +
        //     $"ruchomySlupekPoLewej: {ruchomySlupekPoLewej} ruchomySlupekPoPrawej:{ruchomySlupekPoPrawej} " +
        //     $"wszystkieStany.Count: {wszystkieStany?.Count() ?? 0}");

        // if (wszystkieStany != null && wszystkieStany.Count > 0)
        // {
        //     for(int i = 0; i < Math.Min(3, wszystkieStany.Count); i++)
        //     {
        //         var stan = wszystkieStany[i];
        //         Console.WriteLine(
        //             $"🔍 ZnajdzSasiada-> wszystkieStany[{i}].WybranyModel.RowId: {stan.WybranyModel?.RowId} " +
        //             $"wszystkieStany[{i}].IdRegion: {stan.IdRegion} " +
        //             $"wszystkieStany[{i}].ZIndeks: {stan.ZIndeks} " +
        //             $"wszystkieStany[{i}].WierzcholkiWartosciNominalne.Count: {stan.WierzcholkiWartosciNominalne?.Count()}");
        //     }
        // }

        var p1 = linia[0];
        var p2 = linia[1];

        bool jestPionowa = Math.Abs(p1.X - p2.X) < tolerancja;
        bool jestPozioma = Math.Abs(p1.Y - p2.Y) < tolerancja;

        // Słupki ruchome obecnie nieużywane
        string slPoLewej = "";
        string slPoPrawej = "";
        // string slPoLewej = ruchomySlupekPoLewej && !czyModelMaSlupekRuchomy ? "Słupek ruchomy" : "";
        // string slPoPrawej = ruchomySlupekPoPrawej && !czyModelMaSlupekRuchomy ? "Słupek ruchomy" : "";

        var stanyDoPrzeszukania = wszystkieStany
            .Where(s => s.WierzcholkiWartosciNominalne != null && s.IdRegion != obecnyRegionId)
            .OrderByDescending(s => s.Id);

        // Console.WriteLine($"🔍 ZnajdzSasiada-> stanyDoPrzeszukania: {stanyDoPrzeszukania.Count()}");

        // foreach(var s in stanyDoPrzeszukania)
        // {
        //     Console.WriteLine(
        //         $"🔍 ZnajdzSasiada-> Stan do przeszukania Id: {s.Id} IdRegion: {s.IdRegion} ZIndeks: {s.ZIndeks} " +
        //         $"WierzcholkiWartosciNominalne.Count: {s.WierzcholkiWartosciNominalne?.Count()}");
        // }

        string KTyp = "";

        foreach (var stan in stanyDoPrzeszukania)
        {
            var wierzcholki = stan.WierzcholkiWartosciNominalne!;
            var linieStanu = ExtractLinesFromSquare(wierzcholki);

            double stanMinX = wierzcholki.Min(p => p.X);
            double stanMaxX = wierzcholki.Max(p => p.X);
            double stanMinY = wierzcholki.Min(p => p.Y);
            double stanMaxY = wierzcholki.Max(p => p.Y);

            foreach (var innaLinia in linieStanu)
            {
                if (innaLinia.Count != 2) continue;

                var q1 = innaLinia[0];
                var q2 = innaLinia[1];

                q1.X = Math.Round(q1.X, 3);
                q1.Y = Math.Round(q1.Y, 3);
                q2.X = Math.Round(q2.X, 3);
                q2.Y = Math.Round(q2.Y, 3);


                // Console.WriteLine(
                //     $"🔍 ZnajdzSasiada-> Porównuję z linią id:{stan.Id} ZIndeks:{stan.ZIndeks} kat: {kat} " +
                //     $"w regionie {stan.IdRegion} q1:({q1.X},{q1.Y}) q2:({q2.X},{q2.Y})");

                if (!CzyNakladajaSieDowolne(p1, p2, q1, q2, tolerancja, kat))
                    continue;

                Console.WriteLine(
                    $"🔍 ZnajdzSasiada-> Porównanie OK z linią id:{stan.Id} ZIndeks:{stan.ZIndeks} kat: {kat} " +
                    $"w regionie {stan.IdRegion} q1:({q1.X},{q1.Y}) q2:({q2.X},{q2.Y})");

                var konfLista = stan.MVCKonfModelu?.KonfSystem;
                if (konfLista == null) continue;

                foreach (var konf in konfLista)
                {
                    KTyp = konf.Typ;

                    if (jestPionowa)
                    {
                        // Lewa krawędź sąsiada
                        if (Math.Abs(p1.X - stanMinX) < tolerancja &&
                            konf.WystepujeLewa &&
                            (string.IsNullOrEmpty(slPoPrawej) || konf.Typ.Contains(slPoPrawej)))
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK"
                            });
                        }

                        // Prawa krawędź sąsiada
                        if (Math.Abs(p1.X - stanMaxX) < tolerancja &&
                            konf.WystepujePrawa &&
                            (string.IsNullOrEmpty(slPoLewej) || konf.Typ.Contains(slPoLewej)))
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK"
                            });
                        }
                    }
                    else if (jestPozioma)
                    {
                        // Górna krawędź sąsiada
                        if (Math.Abs(p1.Y - stanMinY) < tolerancja &&
                            konf.WystepujeGora)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK"
                            });
                        }

                        // Dolna krawędź sąsiada
                        if (Math.Abs(p1.Y - stanMaxY) < tolerancja &&
                            konf.WystepujeDol)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks,
                                MaSlupekRuchomy = czyModelMaSlupekRuchomy,
                                Id = stan.Id,
                                WybranyTyp = konf.Typ ?? "BRAK"
                            });
                        }
                    }
                }
            }
        }

        Console.WriteLine(
            $"🔍 ZnajdzSasiada-> pasujace.Count: {pasujace.Count()} kąt: {kat} " +
            $"slPoPrawej: {slPoPrawej} slPoLewej: {slPoLewej} konf.Typ: {KTyp}");

        var wynik = pasujace
            .OrderBy(p => p.Id)
            .ToList();

        if (!wynik.Any())
        {
            wynik.Add(new SasiadInfo
            {
                RowIdElementu = Guid.Empty,
                IdRegionu = "",
                ZIndeks = -1,
                Id = 0,
                MaSlupekRuchomy = false,
                WybranyTyp = "BRAK"
            });
        }

        return wynik;
    }

    private bool CzyPunktyRowne(XPoint p1, XPoint p2, double tolerancja)
    {
        return Math.Abs(p1.X - p2.X) < tolerancja && Math.Abs(p1.Y - p2.Y) < tolerancja;
    }

    private double DlugoscWspolna(XPoint a1, XPoint a2, XPoint b1, XPoint b2)
    {
        if (Math.Abs(a1.X - a2.X) < 0.01) // pionowa
        {
            var minY1 = Math.Min(a1.Y, a2.Y);
            var maxY1 = Math.Max(a1.Y, a2.Y);
            var minY2 = Math.Min(b1.Y, b2.Y);
            var maxY2 = Math.Max(b1.Y, b2.Y);
            return Math.Max(0, Math.Min(maxY1, maxY2) - Math.Max(minY1, minY2));
        }
        else if (Math.Abs(a1.Y - a2.Y) < 0.01) // pozioma
        {
            var minX1 = Math.Min(a1.X, a2.X);
            var maxX1 = Math.Max(a1.X, a2.X);
            var minX2 = Math.Min(b1.X, b2.X);
            var maxX2 = Math.Max(b1.X, b2.X);
            return Math.Max(0, Math.Min(maxX1, maxX2) - Math.Max(minX1, minX2));
        }

        return 0;
    }

    private static bool CzyNakladajaSieDowolne(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol = 0.02, int kat = 0)
    {
        bool jestPionowa = Math.Abs(a1.X - a2.X) < tol && Math.Abs(b1.X - b2.X) < tol;
        bool jestPozioma = Math.Abs(a1.Y - a2.Y) < tol && Math.Abs(b1.Y - b2.Y) < tol;

        if (jestPionowa)
        {
            // Sprawdź czy X jest blisko siebie
            if (Math.Abs(a1.X - b1.X) > tol)
                return false;

            // Sprawdź nakładanie w osi Y
            double aMin = Math.Min(a1.Y, a2.Y);
            double aMax = Math.Max(a1.Y, a2.Y);
            double bMin = Math.Min(b1.Y, b2.Y);
            double bMax = Math.Max(b1.Y, b2.Y);

            return aMax >= bMin - tol && bMax >= aMin - tol;
        }
        else if (jestPozioma)
        {
            // Sprawdź czy Y jest blisko siebie
            if (Math.Abs(a1.Y - b1.Y) > tol)
                return false;

            // Sprawdź nakładanie w osi X
            double aMin = Math.Min(a1.X, a2.X);
            double aMax = Math.Max(a1.X, a2.X);
            double bMin = Math.Min(b1.X, b2.X);
            double bMax = Math.Max(b1.X, b2.X);

            return aMax >= bMin - tol && bMax >= aMin - tol;
        }

        // W innych przypadkach fallback – np. skośne
        return false;
    }


    private readonly struct Vector2D
    {
        public readonly double X;
        public readonly double Y;

        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }

        public double Length => Math.Sqrt(X * X + Y * Y);

        public Vector2D Normalize()
        {
            var len = Length;
            return len > 0 ? new Vector2D(X / len, Y / len) : new Vector2D(0, 0);
        }

        public static double Cross(Vector2D a, Vector2D b) => a.X * b.Y - a.Y * b.X;

        public double Dot(Vector2D other) => X * other.X + Y * other.Y;
    }


    public static List<List<XPoint>> ExtractLinesFromSquare(List<XPoint> wierzcholki)
    {
        var linie = new List<List<XPoint>>();

        if (wierzcholki == null || wierzcholki.Count < 2)
            return linie; // brak linii

        for (int i = 0; i < wierzcholki.Count; i++)
        {
            var start = wierzcholki[i];
            var end = (i == wierzcholki.Count - 1) ? wierzcholki[0] : wierzcholki[i + 1]; // zamknięcie figury

            linie.Add(new List<XPoint> { start, end });
        }

        return linie;
    }


    private void ZapiszStanGeneratora(string idRegion, GeneratorState state)
    {

        _generatorStates[idRegion] = state;

        Console.WriteLine($"✅ Zapisano stan generatora dla regionu {idRegion}. Liczba _generatorStates: {_generatorStates?.Count ?? 0}");
    }

    private bool CzyPunktLezyNaKrawedzi(XPoint punkt, List<XPoint> wielokat)
    {
        const double eps = 0.001; // tolerancja błędu
        for (int i = 0; i < wielokat.Count; i++)
        {
            var a = wielokat[i];
            var b = wielokat[(i + 1) % wielokat.Count];

            double cross = (punkt.Y - a.Y) * (b.X - a.X) - (punkt.X - a.X) * (b.Y - a.Y);
            if (Math.Abs(cross) > eps) continue;

            double dot = (punkt.X - a.X) * (b.X - a.X) + (punkt.Y - a.Y) * (b.Y - a.Y);
            if (dot < 0) continue;

            double squaredLen = (b.X - a.X) * (b.X - a.X) + (b.Y - a.Y) * (b.Y - a.Y);
            if (dot > squaredLen) continue;

            return true;
        }
        return false;
    }


    private double Odleglosc(XPoint a, XPoint b)
    {
        return Math.Sqrt(Math.Pow(a.X - b.X, 2) + Math.Pow(a.Y - b.Y, 2));
    }

    private bool CzyPunktWNWielokacie(XPoint punkt, List<XPoint> wielokat)
    {
        int j = wielokat.Count - 1;
        bool inside = false;

        for (int i = 0; i < wielokat.Count; j = i++)
        {
            if (((wielokat[i].Y > punkt.Y) != (wielokat[j].Y > punkt.Y)) &&
                (punkt.X < (wielokat[j].X - wielokat[i].X) * (punkt.Y - wielokat[i].Y) / (wielokat[j].Y - wielokat[i].Y) + wielokat[i].X))
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private bool CzyLiniaPrzecinaRegion(List<XPoint> linia, List<XPoint> wielokat)
    {
        var a = linia[0];
        var b = linia[1];

        // 1. klasyczne przecięcie
        for (int i = 0; i < wielokat.Count; i++)
        {
            var c = wielokat[i];
            var d = wielokat[(i + 1) % wielokat.Count];

            if (CzyPrzecinajaSie(a, b, c, d))
                return true;
        }

        // 2. jeden koniec linii wewnątrz regionu
        if (CzyPunktWNWielokacie(a, wielokat) || CzyPunktWNWielokacie(b, wielokat))
            return true;

        // 3. jeden koniec linii na krawędzi regionu
        if (CzyPunktLezyNaKrawedzi(a, wielokat) || CzyPunktLezyNaKrawedzi(b, wielokat))
            return true;

        return false;
    }

    private bool CzyPrzecinajaSie(XPoint a, XPoint b, XPoint c, XPoint d, double tolerancja = 1e-6)
    {
        double d1 = Kierunek(c, d, a);
        double d2 = Kierunek(c, d, b);
        double d3 = Kierunek(a, b, c);
        double d4 = Kierunek(a, b, d);

        // klasyczne przecięcie
        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
            ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)))
            return true;

        // przypadki współliniowe: punkt leży na odcinku
        if (Math.Abs(d1) < tolerancja && PunktNaOdcinku(a, c, d)) return true;
        if (Math.Abs(d2) < tolerancja && PunktNaOdcinku(b, c, d)) return true;
        if (Math.Abs(d3) < tolerancja && PunktNaOdcinku(c, a, b)) return true;
        if (Math.Abs(d4) < tolerancja && PunktNaOdcinku(d, a, b)) return true;

        return false;
    }

    private bool PunktNaOdcinku(XPoint p, XPoint a, XPoint b)
    {
        return p.X <= Math.Max(a.X, b.X) && p.X >= Math.Min(a.X, b.X) &&
               p.Y <= Math.Max(a.Y, b.Y) && p.Y >= Math.Min(a.Y, b.Y);
    }


    private double Kierunek(XPoint a, XPoint b, XPoint c)
    {
        return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);
    }


    private async Task GenerujElementyDlaRegionu(string idRegion, float szerokosc, float wysokosc)
    {
        if (!_generatorStates.TryGetValue(idRegion, out var state))
        {
            Console.WriteLine($"❌ Brak stanu generatora dla regionu {idRegion}");
            return;
        }

        var generator = new Generator
        {
            //KonfiguracjeSystemu = state.PowiazaneModele,
            RowIdSystemu = state.RowIdSystemu,
            MVCKonfModelu = state.MVCKonfModelu,
            TypKsztaltu = state.WybranyKsztalt,
            EdytowanyModel = state.WybranyModel,
            ElementLiniowy = state.ElementLiniowy,
        };


        var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);
        var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

        // Sprawdź, czy region skrzydła ma linię dzielącą z ruchomym słupkiem
        bool czyRegionZawieraSlupekRuchomy = _regionsSkrzydlo?.Any(x => x.TypLiniiDzielacej == "Słupek ruchomy") == true;

        bool czyRegionZawieraSlupekStaly = _regionsDualRama?.Any(x => x.TypLiniiDzielacej == "Słupek stały") == true;

        Console.WriteLine($"✅ czyRegionZawieraSlupekStaly: {czyRegionZawieraSlupekStaly}");

        if (czyRegionZawieraSlupekRuchomy)
        {
            Console.WriteLine($"✅ GenerujElementyDlaRegionu-> Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów.");

            // Sprawdź, czy istnieje "Słupek ruchomy" w jakimkolwiek PowiazanymModelu (lista)
            bool czyZawieraSlupekRuchomyWPowiazanymModelu = StateContainer.States
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfSystem != null &&
                     state.Value.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy")
                 );


            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {
                // Sprawdź, czy istnieje "Słupek ruchomy" w pojedynczym PowiazanymModelu (np. generator)
                bool czySlupekRuchomyWPojedynczymModelu = generator.MVCKonfModelu != null &&
                    generator.MVCKonfModelu.KonfSystem != null &&
                    generator.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy");

                if (!czySlupekRuchomyWPojedynczymModelu)
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj słupek ruchomy do systemu.",
                        2.0
                    );
                    return;
                }
            }
        }

        double minX = 0, maxX = 0, minY = 0, maxY = 0;

        if (wybranyRegionDualRama != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionDualRama.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 0;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates, _regionsDualRama, null);
        }
        else if (wybranyRegionSkrzydlo != null && !czyRegionZawieraSlupekStaly)
        {
            var regionPoints = wybranyRegionSkrzydlo.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 1;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion, _generatorStates, _regionsSkrzydlo, null);
        }
        else
        {
            Console.WriteLine($"❌ GenerujElementyDlaRegionu-> Nie znaleziono regionu o ID {idRegion}");
            return;
        }

        // Skalowanie i przesunięcie jeśli zmieniasz szerokość/wysokość
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }

            }
        }

        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();


        // Console.WriteLine($"✅ Wygenerowano elementy dla regionu {idRegion} po skalowaniu.");
        await Task.CompletedTask;
    }

    private async Task RenderFrame(bool calculate = true)
    {
        try
        {
            if (_context == null || ksztalty == null || !ksztalty.Any())
                return;

            // // Przygotowanie canvas
            // await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            // await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);
            // //await _context.TranslateAsync(_panX, _panY);
            // await _context.ScaleAsync(_currentScale, _currentScale);


            // W rysowaniu:
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            await _context.TranslateAsync(_offsetX, _offsetY);
            await _context.ScaleAsync(_currentScale, _currentScale);

            // Przygotowanie tekstury
            var baseUrl = Navigation.BaseUri;
            var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

            // Rysowanie każdego kształtu
            foreach (var ksztalt in ksztalty)
            {
                //Console.WriteLine($"Rysuję kształt: {ksztalt.TypKsztaltu}");
                if (ksztalt.Wierzcholki == null || ksztalt.Wierzcholki.Count < 3)
                    continue;

                Console.WriteLine($"*********** >>>>>> IndeksElementu: {ksztalt.IndeksElementu} Grupa: {ksztalt.Grupa}");

                if (ksztalt.Grupa.Contains("Słupek stały"))
                {
                    if (ksztalt.IndeksElementu == "BRAK-DANYCH") // To do sprawdzenia!!!!
                        continue;

                    var szerSlupka = KonfiguracjeSystemu.FirstOrDefault(x => x.RowId == ksztalt.RowIdElementu);

                    if (szerSlupka != null)
                    {
                        ksztalt.Wierzcholki = ksztalt.Wierzcholki.Select(p => new XPoint
                        {
                            X = p.X - (double)Math.Abs((double)szerSlupka.PionOsSymetrii),   // przesunięcie w osi X
                            Y = p.Y     // przesunięcie w osi Y
                        })
                    .ToList();
                    }

                }
                // Console.WriteLine($"*********** >>>>>> ksztalt: {ksztalt.Id}");

                await DrawShapeWithVariableOffset(_context, ksztalt, imageUrl, calculate);
                await DrawSingleContourTextOnly(_context, ksztalt.Wierzcholki, $"{ksztalt.IndeksElementu.ToString()} [{ksztalt.Kat.ToString()}/{ksztalt.Strona}]"); // Tekst z ID i kątem na profilu
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd renderowania: {ex.Message}\n{ex.StackTrace}");
        }
    }

    private async Task DrawShapeWithVariableOffset(Canvas2DContext context, KsztaltElementu ksztalt, string textureUrl, bool calculate)
    {
        var outerPoints = ksztalt.Wierzcholki;

        // Console.WriteLine($"outerPoints: {outerPoints.Count}");

        var offsets = GetOffsetsForGroup(ksztalt.Grupa);

        await DrawSingleContour(context, outerPoints);

        // await DrawDoubleContour(context, outerPoints, innerPoints);
        if (_dotNetHelper != null)
        {
            await JS.InvokeVoidAsync("loadAndDrawTexture",
                CanvasRef.CanvasReference,
                textureUrl,
                _dotNetHelper
            );
        }

        await context.SetStrokeStyleAsync("#000000");
        await context.SetLineWidthAsync(1.5f);
        await context.StrokeAsync();
    }


    private (float left, float right, float top, float bottom) GetOffsetsForGroup(string grupa)
    {
        // Domyślne wartości (można dostosować)
        float grLewo = 82;
        float grPrawo = 82;
        float grGora = 82;
        float grDol = 92;

        return grupa switch
        {
            "Lewo" => (grLewo, 0, 0, 0),
            "Prawo" => (0, grPrawo, 0, 0),
            "Gora" => (0, 0, grGora, 0),
            "Dol" => (0, 0, 0, grDol),
            _ => (grLewo, grPrawo, grGora, grDol) // Domyślne dla innych przypadków
        };
    }

    private async Task DrawSingleContour(Canvas2DContext context, List<XPoint> outerPoints)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Rysuj pojedynczy kontur zewnętrzny
        await context.BeginPathAsync();

        // Rozpocznij od pierwszego punktu
        await context.MoveToAsync(outerPoints[0].X, outerPoints[0].Y);

        // Rysuj linie do kolejnych punktów
        for (int i = 1; i < outerPoints.Count; i++)
        {
            await context.LineToAsync(outerPoints[i].X, outerPoints[i].Y);
        }

        // Zamknij kształt
        await context.ClosePathAsync();

        // Opcjonalne stylowanie
        await context.SetStrokeStyleAsync("black");
        await context.SetLineWidthAsync(2);
        await context.StrokeAsync();
    }

    private async Task DrawSingleContourTextOnly(Canvas2DContext context, List<XPoint> outerPoints, string tekst)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Oblicz środek figury
        double centerX = outerPoints.Average(p => p.X);
        double centerY = outerPoints.Average(p => p.Y);

        // Sprawdź proporcje
        double width = outerPoints.Max(p => p.X) - outerPoints.Min(p => p.X);
        double height = outerPoints.Max(p => p.Y) - outerPoints.Min(p => p.Y);
        bool rotate = height > width;

        // Rysowanie tekstu
        await context.SaveAsync();
        await context.SetFontAsync($"30px Arial");
        await context.SetFillStyleAsync("black");
        await context.SetTextAlignAsync(TextAlign.Center);
        await context.SetTextBaselineAsync(TextBaseline.Middle);

        if (rotate)
        {
            await context.TranslateAsync(centerX, centerY);
            await context.RotateAsync((float)Math.PI / 2); // 90 stopni
            await context.FillTextAsync(tekst, 0, 0);
        }
        else
        {
            await context.FillTextAsync(tekst, centerX, centerY);
        }

        await context.RestoreAsync();
    }


    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task GoCAD()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        NavigationManager.NavigateTo($"/DrawCAD");

        await Task.CompletedTask;
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                //Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    public class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class PointClassification
    {
        public bool IsLeft { get; set; }
        public bool IsRight { get; set; }
        public bool IsTop { get; set; }
        public bool IsBottom { get; set; }
    }

    public class DraggedModelInfo
    {
        public string? Type { get; set; }
        public string? RowId { get; set; }
    }

    private class DomSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    public class SasiadInfo
    {
        public Guid RowIdElementu { get; set; }
        public string? IdRegionu { get; set; }
        public int ZIndeks { get; set; }
        public bool MaSlupekRuchomy { get; set; }
        public int Id { get; set; }
        public string WybranyTyp { get; set; }
    }

    public class PrzesuniecieDto
    {
        public double PrzesuniecieX { get; set; }
        public double PrzesuniecieY { get; set; }
    }

}
