@page "/Modele-okienne"
@using AntDesign
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@using GEORGE.Shared.ViewModels;
@using GEORGE.Client.Pages.Utils
@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@using System.Globalization
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation
@inject NavigationManager NavigationManager
@inject ShapeTransferService ShapeService

@using System.IO;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.Formats.Png;

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using GEORGE.Client.Pages.Models
@using GEORGE.Client.Pages.Okna

@inject GeneratorStateContainer StateContainer

@implements IDisposable

<script>
        (() => {
        // Inicjalizacja globalnych zmiennych
        const _originalInvoke = DotNet.invokeMethodAsync;
        DotNet.invokeMethodAsync = function (assemblyName, methodName, ...args) {
            console.log(`🔍 DotNet.invokeMethodAsync intercepted: ${assemblyName}.${methodName}`, args);
            return _originalInvoke(assemblyName, methodName, ...args)
                .catch(err => {
                    console.warn("❌ Intercepted DotNet.invokeMethodAsync error:", err);
                    throw err;
                });
        };

        window._dragListenersInitialized = window._dragListenersInitialized || false;

        window.currentDraggedModel = null;
        window.currentDraggedType = null;
        window.isDragging = false;
        window.blazorCanvas = null;

        // Ustawienie referencji do canvasu
        window.setCanvasRef = (canvasRef) => {
        if (!canvasRef) {
        console.error("❌ Blazor przekazał null do setCanvasRef!");
        return;
        }
        window.blazorCanvas = canvasRef;
       // console.log("✅ Canvas ustawiony!", canvasRef);
        };

        // Ustawienie referencji do .NET
        window.setDotNetHelper = (dotNetHelper) => {
        window.dotNetHelper = dotNetHelper;
        //console.log("✅ DotNetHelper ustawiony!");
        };

        // Funkcja rozpoczynająca przeciąganie
        window.startDrag = (modelType, event) => {
        if (event.button !== 0) return; // Obsługa tylko lewego przycisku myszy

        event.preventDefault();
        window.isDragging = true;
        window.currentDraggedType = modelType;

        // Pobranie obrazka do ustawienia jako kursor
        const img = document.getElementById(`wing-${modelType}`);
        if (!img) {
        console.error(`❌ Nie znaleziono obrazka dla modelu: ${modelType}`);
        return;
        }

        // Tworzymy nowy obrazek, który będzie podążał za kursorem
        const cursorImg = new Image();
        cursorImg.src = img.src;
        cursorImg.style.position = "absolute";
        cursorImg.style.pointerEvents = "none";
        cursorImg.style.width = "50px";
        cursorImg.style.height = "50px";
        cursorImg.style.opacity = "0.8";
        cursorImg.id = "dragCursorImage";

        document.body.appendChild(cursorImg);
        window.currentDraggedImage = cursorImg;

        // Aktualizacja pozycji obrazka pod kursorem
        window.updateCursorImagePosition(event);
        };

        //     // Aktualizacja pozycji obrazka kursora
        // window.updateCursorImagePosition = (event) => {
        //         if (!window.isDragging || !window.currentDraggedImage) return;
        //         window.currentDraggedImage.style.left = `${event.pageX - 25}px`;
        //         window.currentDraggedImage.style.top = `${event.pageY - 25}px`;
        //     };

        // Funkcja kończąca przeciąganie

        if (!window._stopDragDefined) {
            window.stopDrag = async function (event) {
                if (!window.isDragging) return;

                window.isDragging = false;

                if (window.currentDraggedImage) {
                    document.body.removeChild(window.currentDraggedImage);
                    window.currentDraggedImage = null;
                }

                if (!window.blazorCanvas) {
                    console.error("❌ Brak referencji do canvasu!");
                    return;
                }

                const rect = window.blazorCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                console.log(`🛑 Upuszczono model: ${window.currentDraggedType} na (${x}, ${y})`);

                if (window.dotNetHelper) {
                    try {
                        await window.dotNetHelper.invokeMethodAsync('OnDragEnd', window.currentDraggedType, x, y);
                    } catch (err) {
                        console.warn("❌ invokeMethodAsync (OnDragEnd) nie powiodło się:", err);
                        window.dotNetHelper = null;
                    }
                }

                window.currentDraggedType = null;
            };

            document.addEventListener("mouseup", window.stopDrag);
            window._stopDragDefined = true;
        }


        // Obsługa aktualizacji kursora
        document.addEventListener("mousemove", window.updateCursorImagePosition);

        // Obsługa upuszczenia obrazka
       if (!window._dragListenersInitialized) {
        document.addEventListener("mouseup", window.stopDrag);
        document.addEventListener("mousemove", window.updateCursorImagePosition);
        window._dragListenersInitialized = true;
        }



        window.SetCustomCursor = (base64Image) => {
        //console.log("🔵 Ustawiam kursor na Base64!");

        const cursorUrl = `data:image/png;base64,${base64Image}`;
        document.body.style.cursor = `url(${cursorUrl}) 8 8, auto`;

        // console.log(`🖱 Kursor ustawiony globalnie: ${cursorUrl}`);
        };

        window.ResetCursor = () => {
        //console.log("🔄 Resetowanie kursora");
        document.querySelector(".canvas-container").style.cursor = "default";
        document.querySelector("canvas").style.cursor = "default";
        };

        // JavaScript
        window.AddCanvasHoverListener = (canvasElement) => {
        canvasElement.addEventListener('mousemove', () => {
        // Wymusza aktualizację kursora, jeśli został już ustawiony
        if (document.body.style.cursor.includes('url')) {
        document.body.style.cursor = document.body.style.cursor;
        }
        });
        };

        // Funkcja do ładowania tekstury
        window.loadAndDrawTexture = async (canvasElement, imageUrl, dotNetHelper) => {
        const ctx = canvasElement.getContext('2d');
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imageUrl;

        await new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = reject;
        //console.log("🔍 dotNetHelper:", dotNetHelper);
        });

        const pattern = ctx.createPattern(img, 'repeat');
        ctx.fillStyle = pattern;

        // ❗ Dodaj tę linię, aby wypełnić aktualną ścieżkę!
        ctx.fill("evenodd");

        ctx.canvas.dataset.pattern = "wood-pattern";

        if (dotNetHelper) {
            try {
                await dotNetHelper.invokeMethodAsync('OnTextureLoaded');
            } catch (err) {
                console.warn("❌ OnTextureLoaded invoke failed", err);
            }
        }
        };

        // Globalny reset kursora z obsługą wszystkich przeglądarek
        window.ResetCursorGlobal = () => {
        // Reset dla wszystkich możliwych elementów
        document.documentElement.style.cursor = 'default';
        document.body.style.cursor = 'default';
        document.querySelector('.canvas-container').style.cursor = 'default';

        // Wymuś natychmiastowe odświeżenie
        const style = document.createElement('style');
        style.innerHTML = '*{cursor: default !important;}';
        document.head.appendChild(style);
        setTimeout(() => document.head.removeChild(style), 100);
        };

        let currentModel = null;

        window.SetCurrentModel = (modelType, modelRowId) => {
        currentModel = modelType;
        window.currentDraggedModel = {
        type: modelType,
        rowId: modelRowId
        };

        document.documentElement.setAttribute('data-current-model', modelType);
        document.documentElement.setAttribute('data-model-row-id', modelRowId);
        console.log(`📦 Ustawiono model: ${modelType}, ID: ${modelRowId}`);
        };

        window.getDraggedModelInfo = () => {
        if (!window.currentDraggedModel) {
        console.warn("⚠️ currentDraggedModel is not set.");
        return null;
        }

        return {
        type: window.currentDraggedModel.type,
        rowId: window.currentDraggedModel.rowId
        };
        };


        window.clearCurrentModel = () => {
        currentModel = null;
        document.documentElement.removeAttribute('data-current-model');
        };

        // Blokuj domyślne zachowanie przeglądarki
        document.addEventListener('dragover', (e) => {
        e.preventDefault();
        });

        window.getCanvasBoundingRect = function (canvasElement) {
            if (!canvasElement) {
                console.warn("❌ Canvas element is null in JS.");
                return null;
            }

            const rect = canvasElement.getBoundingClientRect();
            return {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
            };
        };

        })();

    window.clearDotNetHelper = () => {
        console.log("🧹 Czyszczenie dotNetHelper. Stary:", window.dotNetHelper);
        window.dotNetHelper = null;
    };

    window.getElementSize = (selector) => {
        const el = document.querySelector(selector);
        if (!el) return null;

        const rect = el.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height
        };
    };

    window.registerResizeCallback = (dotnetHelper) => {
        window.addEventListener("resize", () => {
            dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
        });
    };

        window.registerResizeHandler = function (dotnetHelper) {
            window.addEventListener("resize", () => {
                dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
            });
        };

    // Sprawdza, czy canvas jest poprawny i w DOM
    window.isCanvasValid = () => {
        const isValid = !!window.blazorCanvas && document.contains(window.blazorCanvas);
        //console.log(`✅ Canvas valid: ${isValid}`);
        return isValid;
    };

    // Czyści referencję do canvas (wywoływane z C# przy usuwaniu komponentu)
    window.clearCanvasRef = () => {
        console.log("🧹 Czyszczenie referencji do canvas");
        window.blazorCanvas = null;
    };
</script>

<style>
    /* Globalne ustawienia */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
    }

    /* Specjalna klasa dla resetu */
    .cursor-reset * {
        cursor: default !important;
        pointer-events: auto !important;
    }

    /* Kontener główny */
    .window-model-container {
        display: flex;
        height: 70vh;
        background-color: #fff;
        padding: 10px;
        box-sizing: border-box;
    }

    /* Panel boczny z modelami */
    .wing-model-container {
        flex: 0 0 250px; /* Szerokość panelu bocznego */
        height: 100%;
        overflow-y: auto;
        border-right: 2px solid #ddd;
        padding: 10px;
        background: #f8f9fa;
    }

        /* Tabela modeli */
        .wing-model-container table {
            font-size: 13px;
            width: 100%;
            border-collapse: collapse;
        }

        .wing-model-container th, .wing-model-container td {
            padding: 6px;
            text-align: center;
        }

        .wing-model-container th {
            background-color: #007bff;
            color: white;
        }

        .wing-model-container tr:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        /* Miniatury modeli */
        .wing-model-container img {
            width: 45px;
            height: 45px;
            object-fit: contain;
            cursor: -webkit-grab; /* Obsługa w Safari */
            cursor: grab;
            transition: transform 0.2s ease-in-out;
        }

            .wing-model-container img:hover {
                transform: scale(1.1);
            }

    /* Główne okno wyświetlania */
    .display-window {
        flex-grow: 1;
        height: 100%;
        min-height: 400px; /* Zapewnienie minimalnej wysokości */
        border: 2px solid #ddd;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        box-sizing: border-box;
        position: relative;
        overflow: hidden;
        cursor: crosshair;
    }

    .container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    .canvas-container {
        width: @(CanvasWidth + "px");
        height: @(CanvasHeight + "px");
        pointer-events: none; /* Wyłącz interakcje z canvasem */
        max-width: 100%;
        max-height: 100%;
        border: 2px solid #ddd;
        background-color: #fff;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Ukrywa przewijanie */
        position: relative;
    }

    canvas {
        pointer-events: none; /* Kontynuuj ignorowanie zdarzeń */
        display: block;
        max-width: 100%;
        max-height: 100%;
        background-color: transparent;
    }

    .interactive-layer {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2; /* Warstwa NAD canvasem */
        pointer-events: auto; /* Włącz interakcje */
    }
    /* Paski przewijania */
    .wing-model-container::-webkit-scrollbar {
        width: 8px;
    }

    .wing-model-container::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 5px;
    }

        .wing-model-container::-webkit-scrollbar-thumb:hover {
            background: #0056b3;
        }

    /* 🔹 Toolbar z przyciskami */
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        justify-content: center;
        padding: 10px;
        background: #fff;
    }

        /* Styl dla przycisków */
        .toolbar .btn {
            flex: 1;
            min-width: 90px;
            font-size: 13px;
            padding: 6px 8px;
            transition: all 0.2s ease-in-out;
        }

            .toolbar .btn:hover {
                transform: scale(1.05);
            }

    .zoom-controls {
        position: absolute;
        top: 170px; /* Ustawienie 10px od góry */
        right: 10px; /* Ustawienie 10px od prawej */
        display: flex;
        gap: 10px; /* Odstęp między przyciskami */
        z-index: 1000; /* Upewnia się, że są na wierzchu */
    }

    .btn-zoom {
        width: 40px;
        height: 40px;
        font-size: 20px;
        border-radius: 50%; /* Okrągłe przyciski */
        border: none;
        background-color: #007bff; /* Niebieski, możesz zmienić */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Delikatny cień */
        transition: background-color 0.3s ease;
    }

        .btn-zoom:hover {
            background-color: #0056b3; /* Ciemniejszy niebieski przy najechaniu */
        }

    /* Panel zajmuje pełną szerokość */
    .scrollable-panel {
        width: 100%;
        max-height: 400px; /* Możesz zmienić na więcej, np. 600px */
        overflow-y: auto; /* Włącza przewijanie w pionie */
    }

    /* Sider zajmuje całą szerokość */
    .info-panel {
        background-color: #222;
        color: #ffeb99;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
        width: 500px; /* Pełna szerokość */
        max-width: 1000px;
    }

    /* Lista informacji */
    .info-list {
        list-style: none;
        padding: 0;
        width: 760px;
    }

    /* Każdy element ma własne miejsce */
    .info-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 760px;
    }

        /* Tekst jasnożółty */
        .info-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .info-item strong {
            color: #ffcc00;
        }

    /* Obsługa braku danych */
    .no-data {
        color: red;
        text-align: center;
        font-style: italic;
    }

    /* Lista materiałów */
    .materials-list {
        list-style: none;
        padding: 0;
        width: 100%;
    }

    /* Pojedynczy materiał */
    .material-item {
        background: #333;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 10px;
        box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
    }

        /* Kolor jasny dla tekstu */
        .material-item span {
            color: #ffeb99;
            font-size: 1em;
        }

        .material-item strong {
            color: #ffcc00;
        }

</style>

<!-- Nagłówek -->

<div class="d-flex justify-content-between align-items-center mt-2 mb-2">
    <h3 class="mb-0">Modele Okienne</h3>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoCAD">
        OKN-CAD
    </Button>
    &nbsp;&nbsp;
    <button class="btn btn-primary" @onclick="GoBack">
        <i class="fas fa-arrow-left"></i> Wróć do poprzednej strony
    </button>

</div>

<Collapse Animation>
    <Panel Header="Wymiary, kolory itp. Okien" Key="1">
        <div class="form-group mt-3">
            <label>Szerokość:</label>
            <input type="number" class="form-control" @bind="Szerokosc" />

            <label>Wysokość:</label>
            <input type="number" class="form-control" @bind="Wysokosc" />

            <label>Kolor:</label>
            <input type="color" class="form-control" @bind="Kolor" />
        </div>
        <Button OnClick="() => ZmienWymiaryOkna()">Zmień wymiary</Button>
        <Button OnClick="() => RozstawLinie()">Podziały ustaw symetrycznie</Button>
    </Panel>

    <Panel Header="Informacja o wyrobie restrykcje" Key="2" class="scrollable-panel">
        <Sider class="info-panel">
            <h4 style="color:aquamarine;">🛠️ Informacja o wyrobie:</h4>

            @if (infoObiekt != null && infoObiekt.Any())
            {
                <p class="entries-count"> 📌 Liczba wpisów: <strong>@infoObiekt.Count()</strong></p>
                <ul class="info-list">
                    @foreach (var wymiar in infoObiekt)
                    {
                        <li class="info-item">
                            <span><strong>📏 Szerokość:</strong> @wymiar.Szerokosc mm</span>
                            <span><strong>📐 Wysokość:</strong> @wymiar.Wysokosc mm</span>
                            <span><strong>🏗️ Wyrób:</strong> @wymiar.RodzajObiektu</span>
                            <span><strong>⚠️ Restrykcje:</strong> @wymiar.Restrykcja</span>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p class="no-data">❌ Brak danych o wyrobie.</p>
            }
        </Sider>
    </Panel>
    <Panel Header="Materiały" Key="3" class="scrollable-panel">
        @if (infoBoom != null && infoBoom.Any())
        {
            <p class="entries-count">📌 Liczba materiałów: <strong>@infoBoom.Count()</strong></p>
            <ul class="materials-list">
                @foreach (var material in infoBoom)
                {
                    <li class="material-item">
                        <span><strong>📏 Długość:</strong> @material.Dlugosc mm</span>
                        <span><strong>🏷️ Nazwa:</strong> @material.Nazwa</span>
                        <span><strong title="@material.RowIdIndeksu">🔢 Indeks:</strong> @material.Indeks</span>
                        <span><strong>📦 Ilość sztuk:</strong> @material.IloscSztuk</span>
                        <span><strong>⚠️ Restrykcje:</strong> @material.Restrykcja</span>
                    </li>
                }
            </ul>
        }
        else
        {
            <p class="no-data">❌ Brak użytych materiałów.</p>
        }
    </Panel>

</Collapse>


<!-- Kontener na modele i canvas -->
<div class="window-model-container">
    <!-- Kontener na przyciski -->
    <div class="zoom-controls">
        <label>@mousePosition skala: @((int)(_currentScale * 100))</label>
        <button @onclick="UsunOstatniObiekt" class="btn-zoom">🗑️</button>
        <button @onclick="ZoomIn" class="btn-zoom">➕</button>
        <button @onclick="ZoomOut" class="btn-zoom">➖</button>
        <button @onclick="PokazModal" class="btn-zoom">💎</button>
        <button class="btn btn-zoom" @onclick="OtworzPrzeglad">🔍</button>
    </div>
    <!-- Panel boczny z modelami -->
    <div class="wing-model-container">
        <!-- 🔹 Wybór systemu -->
        <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
            <div class="d-flex">
                @if (Systemy != null && Systemy.Any())
                {
                    <select class="form-select me-2" style="width:100%" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                }
            </div>
        </Tooltip>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Typ</th>
                    <th>Wymiary</th>
                    <th>Miniaturka</th>
                </tr>
            </thead>
            <tbody>
                @if (ListaModeli != null)
                {
                    @foreach (var model in ListaModeli)
                    {
                        <tr>
                            <td>@model.Typ</td>
                            <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                            <td>
                                @if (model.Rysunek != null && model.Ikona32x32.Length > 0)
                                {
                                    <img id="@($"wing-{model.Typ}")"
                                         src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                         @onclick='@(() => WybierzModel(model))'
                                         @ondragstart='@(e => JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId))'
                                         @onmouseout='@(e => JS.InvokeVoidAsync("ResetCursor"))'
                                         draggable="true"
                                         style="cursor: grab;
                                                          width: auto;
                                                          height: auto;
                                                          max-width: 50px;
                                                          max-height: 50px;
                                                          border: @(model == WybranyModel ? "4px solid #007bff" : "none")" />

                                }
                                else
                                {
                                    <span class="text-muted">Brak</span>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <!-- Główne okno wyświetlania -->
    <div class="display-window" @onmouseup="OnMouseUp" @onmousemove="MouseMove"
         style="position: relative; /* Wymagane dla warstw */
            overflow: visible; /* Zapobiega przycinaniu kursora */
            cursor: inherit; /* Dziedziczy kursor z JS */">

        <!-- Tutaj elementy reagujące na kursor (np. przyciski) -->
        @if (hasCanvasError)
        {
            <p style="color: red; position: relative; z-index: 100;">❌ Błąd: Nie udało się załadować canvasu!</p>
        }
        else
        {
            <!-- Canvas -->
            <div class="canvas-container" style="padding:0px;background-color: transparent;border: 0px;">
                <BECanvas @ref="CanvasRef" Width="@CanvasWidth" Height="@CanvasHeight" />
            </div>
        }
    </div>
</div>

<div class="modal fade @classShowTWZ" tabindex="-1"
     style="display: @displayTWZ; margin: auto; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; width: 80%;">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Punkty elementów okien</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal"></button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto; font-size: 0.85rem; font-family: Consolas, monospace;">
                @if (ksztalty is not null && ksztalty.Any())
                {

                    @foreach (var ksztalt in ksztalty)
                    {
                        <div class="card my-2 shadow-sm">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>Typ:</strong> @ksztalt.TypKsztaltu &nbsp;|&nbsp;
                                    <strong>Grupa:</strong> @ksztalt.Grupa &nbsp;|&nbsp;
                                    <strong>ZIndex:</strong> @ksztalt.ZIndex &nbsp;|&nbsp;
                                    <strong>RowIdElementu:</strong> @ksztalt.RowIdElementu
                                    <br />
                                    <strong>IdRegion:</strong> @ksztalt.IdRegion
                                </div>
                                <button class="btn btn-sm btn-primary" @onclick="@(() => EdytujKsztalt(ksztalt.Id))">Edytuj</button>
                            </div>
                            <div class="card-body">
                                @if (edytowanyId == ksztalt.Id)
                                {
                                    <div class="mb-2">
                                        <label>Typ kształtu</label>
                                        <input class="form-control" @bind="ksztalt.TypKsztaltu" />
                                    </div>
                                    <!-- Pozostałe inputy jak wcześniej... -->

                                    <div class="mb-2">
                                        <label><strong>Wierzchołki (X, Y):</strong></label>
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var punkt = ksztalt.Wierzcholki[i];
                                            var lokalnyIndex = i;  // 👈 to jest klucz

                                            <div class="d-flex align-items-center mb-1" @key="punkt">
                                                <span class="me-2">[@lokalnyIndex]</span>
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                       @oninput="@(e => ZmienX(ksztalt, lokalnyIndex, e))" placeholder="X" />
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                       @oninput="@(e => ZmienY(ksztalt, lokalnyIndex, e))" placeholder="Y" />
                                            </div>
                                        }
                                    </div>

                                    <button class="btn btn-success btn-sm" @onclick="@ZapiszKsztalt">Zapisz</button>
                                    <button class="btn btn-secondary btn-sm ms-2" @onclick="@AnulujEdycje">Anuluj</button>
                                }
                                else
                                {
                                    <p><strong>Wypełnienie wewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieWewnetrzne">@ksztalt.WypelnienieWewnetrzne</span></p>
                                    <p><strong>Wypełnienie zewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieZewnetrzne">@ksztalt.WypelnienieZewnetrzne</span></p>
                                    <p><strong>Grubość obramowania:</strong> @ksztalt.GruboscObramowania px</p>
                                    <p><strong>Czy zawiera otwór:</strong> @(ksztalt.CzyZawieraOtwor ? "Tak" : "Nie")</p>
                                    <p><strong>Widoczny:</strong> @(ksztalt.Widoczny ? "Tak" : "Nie")</p>
                                    <p><strong>Długość: @ksztalt.DlogoscElementu</strong></p>
                                    <p><strong>Wierzchołki:</strong></p>
                                    <ul class="list-group list-group-flush">
                                        @foreach (var p in ksztalt.Wierzcholki)
                                        {
                                            <li class="list-group-item">
                                                X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                            </li>
                                        }
                                    </ul>
                                }
                            </div>
                        </div>
                    }

                    <hr>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec(X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec(X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>

                }
                else
                {
                    <p class="text-muted">Brak danych do wyświetlenia 😔 nie wygenerowano okien</p>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec(X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>ID MASTER:</strong> @region.IdMaster</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @p.X, Y: @p.Y
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @(Math.Round(linia.X1, 3)), Y1: @(Math.Round(linia.Y1, 3)), Koniec(X2: @(Math.Round(linia.X2, 3)), Y2: @(Math.Round(linia.Y2, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@(Math.Round(bbox.X, 3)), Y=@(Math.Round(bbox.Y, 3)), Width=@(Math.Round(bbox.Width, 3)), Height=@(Math.Round(bbox.Height, 3))</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>
                }
            </div>
        </div>
    </div>
</div>

<Modal Title="Podgląd danych wygenerowanych "
       Visible="@_generatorState"
       OnOk="@HandleCancel"
       OnCancel="@HandleCancel"
       Maximizable="@true"
       Centered="@true"
       DefaultMaximized="@true">
    <Generator_state_viewer StateContainer="StateContainer"></Generator_state_viewer>
</Modal>


@code {
    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private KonfModele? WybranyModel { get; set; }

    private string WybranyKsztalt = "prostokat";
    private int X = 0, Y = 0, Szerokosc = 1000, Wysokosc = 1000;
    private string Kolor = "#ff0000"; // Domyślny czerwony

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef; // Referencja do komponentu BECanvas
    private Canvas2DContext? _context;
    private DotNetObjectReference<Modele_okienne>? _dotNetHelper;

    // Dodaj nowe pola w sekcji @code
    private string? SelectedModelType { get; set; }
    private string? SelectedRowIdType { get; set; }
    // private double DropX { get; set; }
    // private double DropY { get; set; }
    private ElementReference canvasElement;

    private double _currentScale = 1.0;
    private const double ScaleFactor = 1.1;
    private double _panX = 0;
    private double _panY = 0;

    private long CanvasWidth { get; set; } = 900;
    private long CanvasHeight { get; set; } = 600;

    private double _zoomCenterX = 450; // Środek canvasu
    private double _zoomCenterY = 300;

    private List<WyrobWymiaryOpis>? infoObiekt;

    private List<WygenerowaneMaterialy> infoBoom = new List<WygenerowaneMaterialy>();

    private List<IShapeDC> _shapes = new List<IShapeDC>();

    private List<ShapeRegion> _regionsDualRama = new();
    private List<ShapeRegion> _regionsSkrzydlo = new();

    private string woodPatternName = "sosna.jpg"; // Nazwa pliku do wzoru drewna meranti.jpg wood.jpg

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private string classShowTWZ = "";
    private string displayTWZ = "none";
    private string edytowanyId = "";

    private string edytowanyIdshape = "";

    private string mousePosition = "X: 0, Y: 0";

    private string? edytowanyRegionId;

    private Dictionary<string, List<KsztaltElementu>> _ksztaltyNaRegion = new();
    private List<KsztaltElementu> ksztalty = new();

    private Dictionary<string, GeneratorState> _generatorStates = new();
    private readonly Dictionary<string, Generator> _generatory = new();

    private bool _generatorState = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {

            _shapes = ShapeService.Shapes;

            if (_shapes != null && _shapes.Count() > 0)
            {



                double maxWysokosc = _shapes.Max(s => s.Wysokosc);
                double maxSzerokosc = _shapes.Max(s => s.Szerokosc);

                if (maxWysokosc > 0 && maxSzerokosc > 0)
                {
                    Wysokosc = (int)maxWysokosc;
                    Szerokosc = (int)maxSzerokosc;
                }
                // 2. Oblicz skalę z zachowaniem proporcji tak, by dopasować do docelowych wymiarów
                double scaleX = Szerokosc / CanvasWidth;
                double scaleY = Wysokosc / CanvasHeight;
                double scale = Math.Min(scaleX, scaleY) / 2;

                scale = scale * 0.9;
                _currentScale = scale;

                Console.WriteLine($"🔍 OnInitializedAsync --> Przeskalowano kształty: skala={scale} CanvasWidth: {CanvasWidth} CanvasHeight: {CanvasHeight}");

                // Generuj regiony po transformacji
                //  _regions = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)CanvasWidth, (int)CanvasHeight);
                _regionsDualRama = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, true);
                _regionsSkrzydlo = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, false); // ostatni parametr nie wiem czy potrzeby do sprawdzenia (czy rama true/falsa)

                await RozstawLinie(false);

                foreach (var rds in _regionsSkrzydlo)
                {
                    var center = GeometryUtils.ObliczCentroid(rds.Wierzcholki);

                    foreach (var rdr in _regionsDualRama)
                    {
                        if (GeometryUtils.CzyPunktWielokacie(center, rdr.Wierzcholki))
                        {
                            rds.IdRegionuPonizej = rdr.Id;
                            // Console.WriteLine($"🔗 Region skrzydła {rds.Id} przypisany do regionu ramy {rdr.Id}");
                            break; // Przypisz tylko pierwszą pasującą ramę
                        }
                    }
                }

                double minX = 0;
                double minY = 0;
                double maxX = Szerokosc;
                double maxY = Wysokosc;

                double contentWidth = maxX - minX;
                double contentHeight = maxY - minY;

                double canvasW = CanvasWidth;
                double canvasH = CanvasHeight;

                double margin = 20;
                scaleX = (canvasW - 2 * margin) / contentWidth;
                scaleY = (canvasH - 2 * margin) / contentHeight;

                double centerX = canvasW / 2;
                double centerY = canvasH / 2;

                double contentCenterX = (minX + maxX) / 2;
                double contentCenterY = (minY + maxY) / 2;

                _panX = centerX - contentCenterX * scale;
                _panY = centerY - contentCenterY * scale;

                await ApplyZoom(scale);

            }

            Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

            if (_dotNetHelper == null)
            {
                _dotNetHelper = DotNetObjectReference.Create(this);
                await Task.Delay(25); // Krótkie opóźnienie dla płynności
                await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
                await Task.Delay(25); // Krótkie opóźnienie dla płynności
                //Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
            }

            // Sprawdź, czy skrypt JS został poprawnie załadowany
            var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
            if (!isScriptLoaded)
            {
                throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");

                // await JS.InvokeVoidAsync("AddCanvasHoverListener", CanvasRef);

            }

            if (_shapes != null)
            {
                Console.WriteLine($"Odebrano dane _shapes: {_shapes.Count()}");

                await RedrawCanvas();// to chyba poprawy!!!

                //   StateHasChanged();
            }
            else
            {
                Console.WriteLine($"Odebrano dane _shapes: null");
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas inicjalizacji: {ex.Message}");
        }

        await Laduj_Uprawnienia();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {

            if (firstRender && CanvasRef != null)
            {
                Console.WriteLine("🖌️ Inicjalizacja canvasu...");

                var isFunctionDefined = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
                if (!isFunctionDefined)
                    throw new Exception("⚠️ Funkcja setCanvasRef nie jest zdefiniowana!");

                await JS.InvokeVoidAsync("setCanvasRef", CanvasRef.CanvasReference);
                Console.WriteLine("✅ Canvas ustawiony!");

                // 👇 TU DODAJ
                _context ??= await CanvasRef.CreateCanvas2DAsync();

                await JS.InvokeVoidAsync("registerResizeCallback", DotNetObjectReference.Create(this));

                // // Możesz od razu wywołać rysowanie
                // if (_shapes?.Any() == true)
                //     await RedrawCanvas();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Krytyczny błąd: {ex.Message}");
            hasCanvasError = true;
            StateHasChanged();
        }
    }

    private void WybierzModel(KonfModele model)
    {
        WybranyModel = model;
        // Dodatkowe akcje przy wyborze modelu
        JS.InvokeVoidAsync("SetCustomCursor", Convert.ToBase64String(model.Ikona32x32));
        JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId);
    }

    private void ZmienX(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienX wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newX))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.X = newX;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newX}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienX: {ex.Message}");
        }
    }

    private void ZmienY(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienY wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newY))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.Y = newY;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienY: indeks {index}, nowa wartość Y: {newY}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienY: {ex.Message}");
        }
    }


    private async Task EdytujKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        edytowanyId = id;
        Console.WriteLine($"edytowanyId: {edytowanyId}");
    }

    private async Task ZapiszKsztalt()
    {
        // Nie zmieniaj listy ksztalty – dane są już w niej zaktualizowane przez binding
        edytowanyId = "";
        await RenderFrame(false);
    }


    private void AnulujEdycje()
    {
        edytowanyId = "";
    }

    private void ZmienXRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var x))
        {
            var punkt = region.Wierzcholki[index];
            punkt.X = x;// / _currentScale;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private void ZmienYRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var y))
        {
            var punkt = region.Wierzcholki[index];
            punkt.Y = y;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private async Task ZapiszRegion()
    {
        edytowanyRegionId = null;
        await RedrawCanvas();
        //StateHasChanged(); // aby odświeżyć widok
    }


    private void ZamknijModal()
    {
        classShowTWZ = "";
        displayTWZ = "none";
    }

    private async Task PokazModal()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        classShowTWZ = "show";
        displayTWZ = "block";
    }

    private async Task OtworzPrzeglad()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        StateContainer.States = _generatorStates;

        if (_generatorStates.Count == 0)
        {
            await _message.Warning("Brak zapisanych stanów generatora.", 1.5);
            return;
        }

        await Task.Delay(50); // Krótkie opóźnienie dla płynności

        _generatorState = true;

    }

    private void HandleCancel(MouseEventArgs e)
    {
        _generatorState = false;
    }

    [JSInvokable("UpdateCanvasSizeFromResize")]
    public async Task UpdateCanvasSizeFromResize()
    {
        await ApplyZoom(_currentScale);
    }

    private async Task RedrawCanvas()
    {
        if (_context is null)
        {
            //logger.LogError("Brak kontekstu canvas!");
            return;
        }

        await ClearCanvas();

        // Resetuj transformacje zamiast mnożyć scale
        await _context.SetTransformAsync(1, 0, 0, 1, 0, 0); // identyczna transformacja

        await _context.SaveAsync();
        await _context.ScaleAsync(_currentScale, _currentScale);

        foreach (var shape in _shapes)
        {
            await shape.Draw(_context);
        }

        await _context.RestoreAsync();

    }

    private async Task ClearCanvas()
    {
        // Sprawdź, czy kontekst istnieje i czy canvas jest w DOM
        if (_context == null || !await JS.InvokeAsync<bool>("isCanvasValid"))
        {
            Console.WriteLine("❌ Brak kontekstu canvas (invalid or disposed)");
            return;
        }

        try
        {
            await _context.SetFillStyleAsync("white");
            await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine("❌ ClearCanvas błąd: " + ex.Message);
        }
    }

    private async Task UsunOstatniObiekt()
    {
        if (_generatorStates.Count == 0)
            return;

        var ostatni = _generatorStates.Keys.LastOrDefault();
        if (string.IsNullOrWhiteSpace(ostatni))
            return;

        if (_generatorStates.TryGetValue(ostatni, out var state) &&
            _generatory.TryGetValue(state.IdRegion, out var generator))
        {
            UsunOstatniKsztaltZGeneratora(state.IdRegion, generator);

            _generatorStates.Remove(ostatni);
            _generatory.Remove(state.IdRegion);

            _ksztaltyNaRegion.Remove(state.IdRegion);
            ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
        }


        await ClearCanvas();
        isTextureLoaded = false;

        await Task.Delay(100);
        await RedrawCanvas();
        await DrawStructureAndRestrykcje();
        await RenderFrame();

        StateHasChanged();
    }


    private async Task ZoomIn()
    {
        var newScale = _currentScale * 1.2;
        await ApplyZoom(newScale);
    }

    private async Task ZoomOut()
    {
        var newScale = _currentScale / 1.2;
        await ApplyZoom(Math.Max(newScale, 0.12));
    }

    private async Task ApplyZoom(double newScale)
    {
        if (CanvasWidth == 0 || CanvasHeight == 0)
            return;

        // 📌 Środek canvasu jako punkt odniesienia do zoomu
        _zoomCenterX = CanvasWidth / 2.0;
        _zoomCenterY = CanvasHeight / 2.0;

        Console.WriteLine($"🔍 ZOOM: nowa skala = {newScale:F2}, aktualna skala = {_currentScale:F2}");

        var ratio = 1 - (newScale / _currentScale);
        _panX += (_zoomCenterX - _panX) * ratio;
        _panY += (_zoomCenterY - _panY) * ratio;

        _currentScale = newScale;

        isTextureLoaded = false;

        await RedrawCanvas();
        await DrawStructureAndRestrykcje();
        await RenderFrame();

        // Rysuj wszystkie kształty w przeskalowanym kontekście
        if (_context != null && _shapes != null)
        {
            foreach (var shape in _shapes)
            {
                await shape.Draw(_context);
            }
        }

        StateHasChanged();

    }

    private async Task FitToCanvas(IShapeDC targetShape, string idRegion, bool skalaAutomatyczna, List<XPoint> Wierzcholki, double klikX, double klikY)
    {

        Console.WriteLine($"🔍 FitToCanvas --> Dopasowano do shape: scale={_currentScale:F2}, panX={_panX:F2}, panY={_panY:F2}");

        // await DrawStructureAndRestrykcje(0);

        //await Task.Delay(250); // Krótkie opóźnienie dla płynności

        //if (await DodajWybranyKwadratOkna(idRegion, Wierzcholki) == false) return; // teraz z idRegion

        if (!await DodajWybranyKwadratOkna(idRegion, Wierzcholki, klikX, klikY))
            return;

        await DrawStructureAndRestrykcje(0);

        isTextureLoaded = false;

        // await UpdateCanvasSizeFromDiv();
        await RenderFrame();

    }

    double logicalX = 0;
    private async Task MouseMove(MouseEventArgs e)
    {
        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);
        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na przestrzeń logiczną
        logicalX = relativeX / _currentScale;
        double logicalY = relativeY / _currentScale;

        mousePosition = $"X: {logicalX:F2}, Y: {logicalY:F2}";
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_context == null) return;

        if (CanvasRef == null)
        {
            Console.WriteLine("⚠️ Brak referencji do canvasu!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            await _message.Warning("Wybierz system okienny przed przeciągnięciem modelu.", 1.5);
            return;
        }

        if (WybranyModel == null)
        {
            await _message.Warning("Wybierz model z listy przed przeciągnięciem.", 1.0);
            return;
        }

        // Pobierz informacje o przeciąganym modelu
        var draggedInfo = await GetDraggedModelInfoAsync();
        if (draggedInfo != null && !string.IsNullOrEmpty(draggedInfo.Type))
        {
            SelectedModelType = draggedInfo.Type;
            SelectedRowIdType = draggedInfo.RowId;
        }

        //await Task.Delay(25);

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);

        //await Task.Delay(50);

        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na przestrzeń logiczną
        double modelX = relativeX / _currentScale;
        double modelY = relativeY / _currentScale;

        Console.WriteLine($"🔧 relativeX: {relativeX}, relativeY: {relativeY}, Scale: {_currentScale}");
        Console.WriteLine($"📌 Pozycja w modelu: modelX={modelX}, modelY={modelY}");

        // await Task.Delay(50);

        bool tylkoRama = false;

        if (SelectedModelType == "Rama") tylkoRama = true;

        // 🔍 Znajdź region, w który kliknięto
        var region = FindRegionAtPosition(modelX, modelY, tylkoRama);

        if (region == null)
        {
            await _message.Warning($"❌ Nie znaleziono regionu dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🔍 Znajdź shape wewnątrz regionu
        var shape = _shapes.FirstOrDefault(s =>
        {
            var bbox = s.GetBoundingBox();
            var testPoints = new[]
            {
            new XPoint(bbox.X, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y + bbox.Height),
            new XPoint(bbox.X, bbox.Y + bbox.Height),
            new XPoint(bbox.X + bbox.Width / 2, bbox.Y + bbox.Height / 2)
            };

            return testPoints.Any(p => IsPointInPolygon(region.Wierzcholki, p.X, p.Y));
        });

        if (shape == null)
        {
            await _message.Warning($"❌ Nie znaleziono kształtu w regionie {region.Id} dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🎯 Dopasuj widok do kształtu i regionu
        await FitToCanvas(shape, region.Id, false, region.Wierzcholki, modelX, modelY);

        await Task.Delay(50);

        foreach (var shapeX in _shapes)
        {
            // Console.WriteLine($"🖌️ Rysuję {shapeX.GetType().Name}");
            await shapeX.Draw(_context);
        }
        await _context.RestoreAsync();

        WybranyModel = null;

        // Resetuj kursor JS
        await JS.InvokeVoidAsync("ResetCursorGlobal");

    }

    private ShapeRegion? FindRegionAtPosition(double x, double y, bool tylkoRama)
    {
        Console.WriteLine($"🔍 Szukam regionu w pozycji (model): X={x:F2}, Y={y:F2}");

        if (_regionsDualRama == null || !_regionsDualRama.Any() || _regionsSkrzydlo == null || !_regionsSkrzydlo.Any())
        {
            Console.WriteLine("❌ Brak regionów do sprawdzenia!");
            return null;
        }

        if (tylkoRama)
        {
            foreach (var region in _regionsDualRama)
            {
                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsDualRama Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region DualRama {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }
        else
        {
            foreach (var region in _regionsSkrzydlo)
            {

                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ _regionsSkrzydlo Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region Skrzydło {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }

        Console.WriteLine("❌ Żaden region nie zawiera podanego punktu.");
        return null;
    }

    private bool IsPointInPolygon(List<XPoint> polygon, double x, double y)
    {
        bool inside = false;
        int n = polygon.Count;

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            var xi = polygon[i].X;
            var yi = polygon[i].Y;
            var xj = polygon[j].X;
            var yj = polygon[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi); // +epsilon by uniknąć dzielenia przez 0

            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private async Task OnlyRestrykcje()
    {

        if (!string.IsNullOrEmpty(SelectedModelType))
        {

            if (ListaModeli != null)
            {
                Console.WriteLine($"OnlyRestrykcje - Typ --> SelectedModelType: {SelectedModelType}");

                var _ListaModeliResrykcje = ListaModeli.FirstOrDefault(x => x.Typ == SelectedModelType);

                if (_ListaModeliResrykcje != null)
                {
                    infoObiekt = new List<WyrobWymiaryOpis>();

                    string restrykcje = "Brak restrykcji :)";

                    if (_ListaModeliResrykcje.KonstrMinSzer > Szerokosc)
                    {
                        restrykcje = "<#SYS> Konstrukcja nie spełnia warunku MIN szerokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMinWys > Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MAX wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }

                    // ✅ Poprawione: Utwórz nowy obiekt przed ustawieniem właściwości
                    WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(Szerokosc, Wysokosc, SelectedModelType, restrykcje);

                    infoObiekt.Add(opisy);

                    if (KonfiguracjeSystemu != null)
                    {
                        var _KonfiguracjeSystemu = KonfiguracjeSystemu.OrderBy(x => x.Indeks);

                        if (_KonfiguracjeSystemu != null)
                        {
                            foreach (var _kon in _KonfiguracjeSystemu)
                            {
                                WygenerowaneMaterialy opisySys = new WygenerowaneMaterialy(
                                 _kon.RowId,
                                 _kon.PoziomDol ?? 0.0,
                                 _kon.Nazwa ?? "",
                                 _kon.Indeks ?? "",
                                 1,
                                 ""
                                 );

                                infoBoom.Add(opisySys);
                            }


                        }

                    }


                }

            }
        }

        await Task.CompletedTask;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        //Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private bool isTextureLoaded = false;

    private async Task DrawStructureAndRestrykcje(int isTextureLoadedNZ = 999)
    {
        if (isTextureLoadedNZ == 0) isTextureLoaded = false;

        try
        {
            if (CanvasRef == null)
            {
                Console.WriteLine("⚠️ Brak referencji do canvasu!");
                return;
            }

            _context ??= await CanvasRef.CreateCanvas2DAsync();

            if (!isTextureLoaded)
            {
                // var baseUrl = Navigation.BaseUri;
                // var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

                // await JS.InvokeVoidAsync("loadAndDrawTexture",
                //     CanvasRef.CanvasReference,
                //     imageUrl,
                //     _dotNetHelper
                // );

                await OnlyRestrykcje();

                // StateHasChanged();
                // return;
            }

            //await RenderFrame();

            // Reszta kodu do rysowania...
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas rysowania: {ex.Message}");
        }
    }

    public async Task<DraggedModelInfo> GetDraggedModelInfoAsync()
    {
        try
        {
            var info = await JS.InvokeAsync<DraggedModelInfo>("getDraggedModelInfo");
            await JS.InvokeVoidAsync("clearCurrentModel"); // Opcjonalne czyszczenie po odczycie
            return info;
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Błąd pobierania informacji o modelu: {ex.Message}");
            return null;
        }
    }

    [JSInvokable]
    public async Task OnDragError(string message)
    {
        await _message.Error(message);
        StateHasChanged();
    }

    public void Dispose()
    {
        try
        {
            //JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper?.Dispose();
            _dotNetHelper = null;
            Console.WriteLine($"🧹 Dispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd Dispose: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("clearDotNetHelper");
        _dotNetHelper?.Dispose();
        _dotNetHelper = null;
        Console.WriteLine($"🧹 AsyncDispose wywołany. Obiekt: {this.GetHashCode()}");
    }


    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        try
        {
            isTextureLoaded = true;
            // Console.WriteLine("✅ Tekstura załadowana!");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ładowania tekstury: {ex.Message}");
        }
    }

    public async Task RozstawLinie(bool zmienWymOkna = true)
    {
        // Krok 1: Zbieramy wszystkie linie z obu kolekcji
        var wszystkieLinie = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .Where(r => r.TypKsztaltu.ToLower().Contains("linia"))
            .ToList();

        int liczbaLinii = wszystkieLinie.Count;

        if (liczbaLinii == 0)
        {
            Console.WriteLine("❌ Brak regionów typu 'linia'");
            return;
        }

        // Krok 2: Rozstawiamy je w równych odstępach
        double odstępX = Szerokosc / (liczbaLinii + 0);

        for (int i = 0; i < liczbaLinii; i++)
        {
            var region = wszystkieLinie[i];
            double nowaX = odstępX * (i + 1); // np. 1/4, 2/4, 3/4 dla 3 linii

            for (int j = 0; j < region.Wierzcholki.Count; j++)
            {
                var punkt = region.Wierzcholki[j];
                punkt.X = nowaX;
                region.Wierzcholki[j] = punkt;
            }
        }

        // Odświeżenie widoku
        if (zmienWymOkna) await ZmienWymiaryOkna(false);
    }

    private async Task ZmienWymiaryOkna(bool generujRegion = true)
    {
        if (_shapes != null && _shapes.Count() > 0)
        {

            // double maxWysokosc = _shapes.Max(s => s.Wysokosc);
            // double maxSzerokosc = _shapes.Max(s => s.Szerokosc);

            // if (maxWysokosc > 0 && maxSzerokosc > 0)
            // {
            //     Wysokosc = (int)maxWysokosc;
            //     Szerokosc = (int)maxSzerokosc;
            // }
            // 2. Oblicz skalę z zachowaniem proporcji tak, by dopasować do docelowych wymiarów
            double scaleX = Szerokosc / CanvasWidth;
            double scaleY = Wysokosc / CanvasHeight;
            double scale = Math.Min(scaleX, scaleY) / 2;

            scale = scale * 0.9;
            _currentScale = scale;

            Console.WriteLine($"🔍 ZmienWymiaryOkna --> Przeskalowano kształty: skala={scale} CanvasWidth: {CanvasWidth} CanvasHeight: {CanvasHeight}");

            // Generuj regiony po transformacji
            if (generujRegion)
            {
                _regionsDualRama = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, true);
                _regionsSkrzydlo = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, false); // ostatni parametr nie wiem czy potrzeby do sprawdzenia (czy rama true/falsa)
            }
            foreach (var rds in _regionsSkrzydlo)
            {
                var center = GeometryUtils.ObliczCentroid(rds.Wierzcholki);

                foreach (var rdr in _regionsDualRama)
                {
                    if (GeometryUtils.CzyPunktWielokacie(center, rdr.Wierzcholki))
                    {
                        rds.IdRegionuPonizej = rdr.Id;
                        // Console.WriteLine($"🔗 Region skrzydła {rds.Id} przypisany do regionu ramy {rdr.Id}");
                        break; // Przypisz tylko pierwszą pasującą ramę
                    }
                }
            }

            double minX = 0;
            double minY = 0;
            double maxX = Szerokosc;
            double maxY = Wysokosc;

            double contentWidth = maxX - minX;
            double contentHeight = maxY - minY;

            double canvasW = CanvasWidth;
            double canvasH = CanvasHeight;

            double margin = 20;
            scaleX = (canvasW - 2 * margin) / contentWidth;
            scaleY = (canvasH - 2 * margin) / contentHeight;

            double centerX = canvasW / 2;
            double centerY = canvasH / 2;

            double contentCenterX = (minX + maxX) / 2;
            double contentCenterY = (minY + maxY) / 2;

            _panX = centerX - contentCenterX * scale;
            _panY = centerY - contentCenterY * scale;

            await ApplyZoom(scale);

        }

        if (Systemy == null) Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

        if (_dotNetHelper == null)
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
            Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
        }

        // Sprawdź, czy skrypt JS został poprawnie załadowany
        var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
        if (!isScriptLoaded)
        {
            throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");
        }

        if (_shapes != null)
        {
            Console.WriteLine($"Odebrano dane _shapes: {_shapes.Count()}");

            await RedrawCanvas();

        }
        else
        {
            Console.WriteLine($"Odebrano dane _shapes: null");
        }
    }

    private async Task<bool> DodajWybranyKwadratOkna(string idRegion, List<XPoint> Wierzcholki, double klikX, double klikY)
    {
        if (SelectedModelType == null || string.IsNullOrEmpty(SelectedModelType))
        {
            Console.WriteLine("❌ SelectedModelType jest puste, nie można kontynuować.");
            return false;
        }

        if (_generatorStates != null && _generatorStates.Count == 0)
        {
            if (SelectedModelType.Trim() != "Rama")
            {
                await _message.Info($"Wybierz konstrukcję typu rama!!!");
                return false;
            }
        }


        Console.WriteLine($"📦 -> DodajWybranyKwadratOkna wywołane z idRegion: {idRegion} SelectedRowIdType: {SelectedRowIdType} - konfmodeleelementy");

        var generator = new Generator
        {
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82
        };

        if (KonfiguracjeSystemu != null)
        {
            generator.KonfiguracjeSystemu = KonfiguracjeSystemu;
            generator.RowIdSystemu = Guid.Parse(SelectedSystemId);

            if (Guid.TryParse(SelectedRowIdType, out var rowIdModeluSzukaj))
            {
                generator.RowIdModelu = rowIdModeluSzukaj;

                var powiazanyModel = await Http.GetFromJsonAsync<MVCKonfModele>($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{SelectedRowIdType}");
                if (powiazanyModel != null)
                {
                    generator.MVCKonfModelu = powiazanyModel;

                    if (generator.MVCKonfModelu.KonfModele != null)
                        Console.WriteLine($"! Powiązany model: {generator.MVCKonfModelu.KonfModele[0].NazwaKonfiguracji} ile: {generator.MVCKonfModelu.KonfModele.Count()}");
                }
                else
                {
                    Console.WriteLine($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    await _message.Error($"⚠️ Nie znaleziono powiązanego modelu dla SelectedRowIdType: {SelectedRowIdType}");
                    return false;
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                await _message.Error($"⚠️ Nieprawidłowy SelectedRowIdType: {SelectedRowIdType}");
                return false;

            }
        }
        else
        {
            if (string.IsNullOrEmpty(SelectedSystemId))
            {
                Console.WriteLine("❌ KonfiguracjeSystemu jest puste, nie można kontynuować.");
                return false;
            }

            var kofiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIND_ROWID_SYS/{SelectedSystemId}");
            generator.KonfiguracjeSystemu = kofiguracjeSystemu;
        }

        generator.EdytowanyModel = WybranyModel;
        generator.TypKsztaltu = WybranyKsztalt;
        generator.Wierzcholki = Wierzcholki;

        var regionReferencyjny = _regionsDualRama
            .Concat(_regionsSkrzydlo)
            .FirstOrDefault(r => r.Id == idRegion);

        if (regionReferencyjny == null || regionReferencyjny.Wierzcholki == null)
        {
            Console.WriteLine("❌ Brak regionu referencyjnego.");
            return false;
        }

        var wszystkieRegiony = _regionsDualRama.Concat(_regionsSkrzydlo);
        var zawarteRegiony = wszystkieRegiony
            .Where(r =>
                r.Id != idRegion &&
                r.Wierzcholki != null &&
                r.Wierzcholki.Count >= 3 &&
                r.Wierzcholki.All(p => CzyPunktWNWielokacie(p, regionReferencyjny.Wierzcholki))
            )
            .ToList();

        //Console.WriteLine($"⚠️ 🟩🟩🟩🟩 zawarteRegiony: {zawarteRegiony.Count()}");

        var styczneLinie = wszystkieRegiony
            .Where(r =>
                r.Id != idRegion &&
                r.Wierzcholki != null &&
                r.Wierzcholki.Count == 2 &&
                r.TypKsztaltu?.ToLower().Contains("linia") == true &&
                r.Wierzcholki.Any(p => CzyPunktLezyNaKrawedzi(p, regionReferencyjny.Wierzcholki))
            )
            .ToList();

        bool czyRegionZawieraSlupekRuchomy = false;
        bool stronaLewa = false;
        bool stronaPrawa = false;

        if (styczneLinie.Any())
        {
            Console.WriteLine($"⚠️ 🟩 styczneLinie region rama: {styczneLinie.Count()} zawarteRegiony: {zawarteRegiony.Count()} 🟩 ⚠️");

            // Filtrujemy linie typu "Słupek ruchomy"
            var slupkiRuchome = styczneLinie
                .Where(x => x.TypLiniiDzielacej == "Słupek ruchomy")
                .ToList();

            if (slupkiRuchome.Any())
            {
                czyRegionZawieraSlupekRuchomy = true;
                Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy.");

                if (slupkiRuchome.Count >= 2)
                {
                    // Średnia X dwóch pierwszych punktów słupka
                    double srodekX1 = slupkiRuchome[0].Wierzcholki[0].X;
                    double srodekX2 = slupkiRuchome[1].Wierzcholki[0].X;
                    double srodekX = (srodekX1 + srodekX2) / 2;

                    Console.WriteLine($"📏 klikX={klikX:F2}, srodekX={srodekX:F2}");

                    // Określamy stronę kliknięcia względem środka słupka
                    if (klikX > srodekX)
                    {
                        stronaLewa = true;
                        Console.WriteLine("⬅️ Wybrano lewą stronę słupka.");
                    }
                    else
                    {
                        stronaPrawa = true;
                        Console.WriteLine("➡️ Wybrano prawą stronę słupka.");
                    }
                }
                else
                {
                    // Jeżeli jest więcej niż jeden słupek w regionie — uznajemy, że są po obu stronach
                    stronaLewa = true;
                    stronaPrawa = true;
                    Console.WriteLine("↔️ Słupek ruchomy po obu stronach.");
                }
            }
            else
            {
                Console.WriteLine($"⚠️ Region {idRegion} NIE zawiera słupka ruchomego.");
            }

            generator.RuchomySlupekPoLewej = stronaLewa;
            generator.RuchomySlupekPoPrawej = stronaPrawa;
        }


        if (czyRegionZawieraSlupekRuchomy && SelectedModelType != "Rama")
        {
            Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów.");

            bool czyZawieraSlupekRuchomyWPowiazanymModelu = _generatorStates
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfSystem != null &&
                     state.Value.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy")
                 );

            Console.WriteLine($"Czy zawiera słupek ruchomy w powiązanym modelu: {czyZawieraSlupekRuchomyWPowiazanymModelu} [{_generatorStates.Count()}] Region ze słupkiem: {czyRegionZawieraSlupekRuchomy}");


            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {
                bool czySlupekRuchomyWPojedynczymModelu = generator.MVCKonfModelu != null &&
                generator.MVCKonfModelu.KonfSystem != null &&
                generator.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy");

                if (!czySlupekRuchomyWPojedynczymModelu)
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj wcześniej słupek ruchomy do konstrukcji.",
                        2.0
                    );
                    return false;
                }

            }

        }

        int ileRegionWSkrzydleZawieraSlupekRuchomy = _regionsSkrzydlo.Where(x => x.TypLiniiDzielacej == "Słupek ruchomy").Count();
        int ileRegionDRZawieraSlupekRuchomy = generator.MVCKonfModelu.KonfModele.Where(x => x.Typ == "Skrzydło z słupkiem ruchomym").Count();
        Console.WriteLine($"🟩 Ile regionów skrzydła zawiera słupek ruchomy: {ileRegionWSkrzydleZawieraSlupekRuchomy} - Ile regionów DR zawiera słupek ruchomy: {ileRegionDRZawieraSlupekRuchomy} - SelectedModelType: {SelectedModelType}");
        if (ileRegionWSkrzydleZawieraSlupekRuchomy == 0 && ileRegionDRZawieraSlupekRuchomy > 0 && SelectedModelType != "Rama")
        {
                await _message.Warning(
                    "Dodajesz konstrukcję z słupkiem ruchomym, Najpierw dodaj podział z osią słupka ruchomego!",
                    2.0
                );
                return false;

        }

        double minX = 0;
        double maxX = 0;
        double minY = 0;
        double maxY = 0;
        string linieDzielace = "";
        List<XPoint> WierzcholkiWartosciNominalne = new();
        WierzcholkiWartosciNominalne.AddRange(Wierzcholki);
        Console.WriteLine($"📐📐📐 SelectedModelType  = {SelectedModelType} Ilość wierzchołków: {Wierzcholki.Count()} 📐📐📐");

        if (SelectedModelType.Trim() == "Rama")
        {

            var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionDualRama != null)
            {
                var regionPoints = wybranyRegionDualRama.Wierzcholki;

                if (regionPoints == null || regionPoints.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej ?? idRegion;
                linieDzielace = wybranyRegionDualRama.TypLiniiDzielacej ?? "Brak";

                minX = regionPoints.Min(p => p.X);
                maxX = regionPoints.Max(p => p.X);
                minY = regionPoints.Min(p => p.Y);
                maxY = regionPoints.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = 0;
                generator.IdRegionuPonizej = wybranyRegionDualRama.IdRegionuPonizej;

                Console.WriteLine($"📐📐📐 Region Zindeks = 0 ID: {wybranyRegionDualRama.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc} generator.Wierzcholki.Count():{generator.Wierzcholki.Count()}");

                stronaLewa = false;
                stronaPrawa = false;

                generator.RuchomySlupekPoLewej = false;
                generator.RuchomySlupekPoPrawej = false;

                generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates);

            }
        }

        // Oblicz przesunięcia tylko dla skrzydeł
        double przesLewo = 0, przesPrawo = 0, przesGora = 0, przesDol = 0;

        // Przygotowanie stanu generatora
        var state = new GeneratorState
        {
            Id = _generatorStates.Count + 1,
            IdRegion = idRegion,
            ZIndeks = generator.Zindeks,
            RowIdSystemu = Guid.Parse(SelectedSystemId),
            RowIdModelu = Guid.TryParse(SelectedRowIdType, out var rowIdModelu) ? rowIdModelu : (Guid?)null,
            MVCKonfModelu = generator.MVCKonfModelu,
            WybranyModel = WybranyModel,
            WybranyKsztalt = WybranyKsztalt,
            IdRegionWarstwaNizej = generator.IdRegionuPonizej,
            Wierzcholki = generator.ElementyRamyRysowane.SelectMany(k => k.Wierzcholki ?? new List<XPoint>()).Distinct().ToList(),
            WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne,
            LinieDzielace = linieDzielace,
            SlupekRuchomyPoLewejStronie = stronaLewa,
            SlupekRuchomyPoPrawejStronie = stronaPrawa,
            ListaKwadratow = new List<DaneKwadratu>()
        };

        var linie = ExtractLinesFromSquare(WierzcholkiWartosciNominalne);

        foreach (var linia in linie)
        {
            if (linia.Count != 2) continue;

            var katSzukaj = ObliczKatLinii(linia);

            var info = ZnajdzSasiada(
                linia,
                _generatorStates.Values.ToList(),
                katSzukaj,
                state.SlupekRuchomyPoLewejStronie,
                state.SlupekRuchomyPoPrawejStronie,
                state.IdRegion,
                0.02
            );

            var rowId = ZnajdzKonfiguracjeDlaLinii(linia, state, stronaLewa, stronaPrawa, idRegion);

            state.ListaKwadratow.Add(new DaneKwadratu
            {
                Wierzcholki = linia,
                RowIdElementu = rowId,
                RowIdSasiada = info.RowIdElementu,
                RowIdRegionuSasiada = info.IdRegionu,
                KatLinii = katSzukaj,
                Strona = StronaSzukaj(
                    katSzukaj,
                    linia,
                    WierzcholkiWartosciNominalne.Min(p => p.Y),
                    WierzcholkiWartosciNominalne.Max(p => p.Y),
                    WierzcholkiWartosciNominalne.Min(p => p.X),
                    WierzcholkiWartosciNominalne.Max(p => p.X)
                )
            });
        }


        if (SelectedModelType.Trim() == "Skrzydło" || SelectedModelType.Trim() == "Skrzydło z słupkiem ruchomym")
        {
            var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);
            linieDzielace = wybranyRegionSkrzydlo?.TypLiniiDzielacej ?? "Brak";

            if (wybranyRegionSkrzydlo != null)
            {
                var regionPointsSkrzydlo = wybranyRegionSkrzydlo.Wierzcholki;

                if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return false;
                }

                generator.IdRegionuPonizej = wybranyRegionSkrzydlo.IdRegionuPonizej ?? idRegion + "-BLAD";

                minX = regionPointsSkrzydlo.Min(p => p.X);
                maxX = regionPointsSkrzydlo.Max(p => p.X);
                minY = regionPointsSkrzydlo.Min(p => p.Y);
                maxY = regionPointsSkrzydlo.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindeks = SelectedModelType == "Skrzydło z słupkiem ruchomym" ? 1 : 2;

                //luzy wynikahjące z przesunięcia

                // najpierw wczytujesz region i dodajesz jego dane
                var regionDoDodania = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

                if (regionDoDodania != null)
                {
                    // ✅ KOPIOWANIE punktów do regionu, na którym operuje AddElements
                    regionDoDodania.Wierzcholki = WierzcholkiWartosciNominalne
                        .Select(p => new XPoint { X = p.X, Y = p.Y })
                        .ToList();

                    // ✅ Najpierw przesuń punkty
                    await WyliczObszarSkrzydla(
                        state,
                        przesLewo, przesPrawo,
                        przesGora, przesDol,
                        stronaLewa, stronaPrawa,
                        generator, regionDoDodania
                    );
                    // 4. Zapisz do stanu
                    state.ZIndeks = generator.Zindeks;
                    state.Wierzcholki = regionDoDodania.Wierzcholki;
                    state.WierzcholkiWartosciNominalne = WierzcholkiWartosciNominalne;

                    // 5. Dodaj elementy
                    generator.AddElements(new List<ShapeRegion> { regionDoDodania }, idRegion, _generatorStates);
                }
                else
                {
                    Console.WriteLine($"❌ Nie znaleziono regionu skrzydła o ID: {idRegion}");

                }

            }
            else
            {
                Console.WriteLine($"📐📐📐 wybranyRegionSkrzydlo == null");
            }
        }

        if (SelectedModelType.Trim() == "Słupek stały")
        {
            // Logika dla słupka stałego
        }

        //   Console.WriteLine($"✅ ElementyRamyRysowane.Count: {generator.ElementyRamyRysowane.Count}");

        if (generator.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine("❌ Brak elementów do rysowania!");
            return false;
        }

        // Console.WriteLine($"📦📦📦 Generowanie elementów ListaKwadratow: {state.ListaKwadratow.Count}.");

        // Console.WriteLine($"📦📦📦 Dodano elementy do regionu {idRegion} o typie {SelectedModelType}. przesLewo:{przesLewo}, przesPrawo:{przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol} 📦📦📦");
        // Zapis do słownika i aktualizacja listy
        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        // Zapisz stan generatora
        _generatory[idRegion] = generator;
        ZapiszStanGeneratora(idRegion, state);

        //await Task.CompletedTask;

        return true;
    }

    private async Task<ShapeRegion> WyliczObszarSkrzydla(GeneratorState state,
      double przesLewo, double przesPrawo, double przesGora, double przesDol,
      bool stronaLewa, bool stronaPrawa, Generator generator,
      ShapeRegion _regionsSkrzydlo)
    {

        if (_regionsSkrzydlo == null)
        {
            Console.WriteLine("❌ Nie znaleziono regionu o podanym ID.");
            return null;
        }

        var regionPointsSkrzydlo = _regionsSkrzydlo.Wierzcholki;

        if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
        {
            Console.WriteLine("❌ Region ma za mało punktów.");
            return null;
        }

        // Oblicz bounding box z obecnych punktów
        double minX = regionPointsSkrzydlo.Min(p => p.X);
        double maxX = regionPointsSkrzydlo.Max(p => p.X);
        double minY = regionPointsSkrzydlo.Min(p => p.Y);
        double maxY = regionPointsSkrzydlo.Max(p => p.Y);


        // Pobierz przesunięcia z boków
        foreach (var bok in state.ListaKwadratow)
        {

            Console.WriteLine($"📦📦📦 Sprawdzam bok: RowIdElementu: {bok.RowIdElementu}, RowIdSasiada: {bok.RowIdSasiada}, KatLinii: {bok.KatLinii} ilość boków: {state.ListaKwadratow.Count()} regionMinX: {minX}");

            var polaczenieWartosci = await PobierzPolaczenia(bok.RowIdSasiada, bok.RowIdElementu, bok.Strona ?? "NaN");

            // Wybierz dopasowanie po stronie połączenia
            var spolaczenieStrona = polaczenieWartosci.FirstOrDefault();

            double przesY = spolaczenieStrona != null
                ? Math.Abs(spolaczenieStrona.PrzesuniecieY)
                : 0;

            switch (bok.Strona)
            {
                case "lewa": przesLewo = przesY; break;
                case "prawa": przesPrawo = przesY; break;
                case "góra": przesGora = przesY; break;
                case "dół": przesDol = przesY; break;
            }

            // Jeśli brak sąsiada — ustaw domyślne testowe przesunięcia
            if (bok.RowIdSasiada == Guid.Empty && stronaLewa)
            {
                przesLewo = 0;
                var konfiguracja1 = generator.KonfiguracjeSystemu.FirstOrDefault(s => s.RowId == bok.RowIdElementu);
                if (konfiguracja1 != null)
                {
                    przesLewo = (konfiguracja1.PoziomDol ?? 0) - (konfiguracja1.PoziomOsSymetrii ?? 0);
                    Console.WriteLine($"📦📦📦 Przesunięcie lewo: {przesLewo} dla RowIdElementu: {bok.RowIdElementu}");
                }
            }

            if (bok.RowIdSasiada == Guid.Empty && stronaPrawa)
                przesPrawo = 0;
            var konfiguracja2 = generator.KonfiguracjeSystemu.FirstOrDefault(s => s.RowId == bok.RowIdElementu);
            if (konfiguracja2 != null)
            {
                przesPrawo = (konfiguracja2.PoziomDol ?? 0) - (konfiguracja2.PoziomOsSymetrii ?? 0);
                Console.WriteLine($"📦📦📦 Przesunięcie prawo: {przesPrawo} dla RowIdElementu: {bok.RowIdElementu}");
            }
        }

        // Przesuń punkty konturu
        for (int i = 0; i < regionPointsSkrzydlo.Count; i++)
        {
            var punkt = regionPointsSkrzydlo[i];

            if (Math.Abs(punkt.X - minX) < 0.1)
                punkt.X += przesLewo;
            else if (Math.Abs(punkt.X - maxX) < 0.1)
                punkt.X -= przesPrawo;

            if (Math.Abs(punkt.Y - maxY) < 0.1)
                punkt.Y -= przesDol;
            else if (Math.Abs(punkt.Y - minY) < 0.1)
                punkt.Y += przesGora;

            regionPointsSkrzydlo[i] = punkt;
        }

        double minXSPRAWDZENIE = regionPointsSkrzydlo.Min(p => p.X);
        Console.WriteLine($"📦📦📦 Po przesunięciu minX: {minXSPRAWDZENIE}, przesLewo: {przesLewo}, przesPrawo: {przesPrawo}, przesGora: {przesGora}, przesDol: {przesDol}");

        _regionsSkrzydlo.Wierzcholki = regionPointsSkrzydlo;

        return _regionsSkrzydlo;
    }


    private void UsunOstatniKsztaltZGeneratora(string idRegion, Generator generator)
    {
        if (string.IsNullOrWhiteSpace(idRegion))
        {
            Console.WriteLine("⚠️ IdRegion nie został podany");
            return;
        }

        if (generator?.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine($"ℹ️ Brak kształtów do usunięcia w regionie {idRegion}");
            return;
        }

        // Usuń ostatni kształt
        var ostatni = generator.ElementyRamyRysowane.Last();
        generator.ElementyRamyRysowane.Remove(ostatni);

        Console.WriteLine($"🗑️ Usunięto ostatni kształt z regionu {idRegion}");

        // Aktualizacja mapy regionów
        if (generator.ElementyRamyRysowane.Count == 0 && _ksztaltyNaRegion.ContainsKey(idRegion))
        {
            _ksztaltyNaRegion.Remove(idRegion);
            Console.WriteLine($"📭 Usunięto wpis z _ksztaltyNaRegion dla {idRegion}");
        }
        else
        {
            _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        }

        // Odświeżenie listy globalnej
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(x => x).ToList();
    }

    private async Task<List<PrzesuniecieDto>> PobierzPolaczenia(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 Pobieram przesunięcia z: {zewId} w: {wewId} strona: {strona}");

            var response = await Http.GetAsync($"api/konfpolaczenie/find-shifts/{zewId}/{wewId}/{strona}");
            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<PrzesuniecieDto>>();
                return lista ?? new List<PrzesuniecieDto>();
            }
            else
            {
                Console.WriteLine($"❌ Błąd podczas pobierania przesunięć: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd podczas pobierania przesunięć: {ex.Message}");
        }

        return new List<PrzesuniecieDto>();
    }


    private async Task<List<KonfPolaczenie>> PobierzPolaczeniaAll(Guid zewId, Guid wewId, string strona)
    {
        try
        {
            Console.WriteLine($"📦 Pobieram dane połączeń z: {zewId} w: {wewId} strona: {strona}");
            var response = await Http.GetAsync($"api/konfpolaczenie/find-by-elements-all/{zewId}/{wewId}");
            if (response.IsSuccessStatusCode)
            {
                var lista = await response.Content.ReadFromJsonAsync<List<KonfPolaczenie>>();
                return lista ?? new List<KonfPolaczenie>();
            }
            else
            {
                Console.WriteLine($"❌ Błąd podczas pobierania połączeń: {response.ReasonPhrase} - strona: {strona}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd podczas pobierania połączenia: {ex.Message}");
        }

        return new List<KonfPolaczenie>();
    }

    public static string StronaSzukaj(int kat, List<XPoint> linia, double regionMinY, double regionMaxY, double regionMinX, double regionMaxX)
    {
        string strona = "";
        if (kat == 0 || kat == 180) // Linie poziome
        {
            double avgY = (linia[0].Y + linia[1].Y) / 2;

            if (Math.Abs(avgY - regionMinY) < 0.1) strona = "góra";
            else if (Math.Abs(avgY - regionMaxY) < 0.1) strona = "dół";
        }
        else if (kat == 90 || kat == 270) // Linie pionowe
        {
            double avgX = (linia[0].X + linia[1].X) / 2;

            if (Math.Abs(avgX - regionMinX) < 0.1) strona = "lewa";
            else if (Math.Abs(avgX - regionMaxX) < 0.1) strona = "prawa";
        }
        return strona;
    }

    public static int ObliczKatLinii(List<XPoint> linia)
    {
        if (linia == null || linia.Count != 2)
            return 0;

        var p1 = linia[0];
        var p2 = linia[1];

        double dx = p2.X - p1.X;
        double dy = p2.Y - p1.Y;

        double angleRadians = Math.Atan2(dy, dx); // uwzględnia znak
        double angleDegrees = angleRadians * (180.0 / Math.PI);

        if (angleDegrees < 0)
            angleDegrees += 360; // zakres 0–360

        return (int)Math.Round(angleDegrees);
    }


    public static Guid ZnajdzKonfiguracjeDlaLinii(List<XPoint> linia, GeneratorState stan, bool slRuchStroLewa, bool slRuchStroPrawa, string obecnyRegionId)
    {
        if (linia == null || linia.Count != 2)
            return Guid.Empty;

        var p1 = linia[0];
        var p2 = linia[1];

        bool jestPionowa = Math.Abs(p1.X - p2.X) < 0.01;
        bool jestPozioma = Math.Abs(p1.Y - p2.Y) < 0.01;

        if (stan?.MVCKonfModelu?.KonfSystem == null)
            return Guid.Empty;

        string slLewa = slRuchStroLewa ? "Słupek ruchomy" : "";
        string slPrawa = slRuchStroPrawa ? "Słupek ruchomy" : "";

        Guid znaleziony = Guid.Empty;


        // 1️⃣ Najpierw próba z uwzględnieniem słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa && konf.Typ.Contains(slLewa))
                    return konf.RowId;
                if (p1.X > 85 && konf.WystepujePrawa && konf.Typ.Contains(slPrawa))
                    return konf.RowId;
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                    return konf.RowId;
                if (p1.Y > 75 && konf.WystepujeDol)
                    return konf.RowId;
            }
        }

        // 2️⃣ Jeśli nie znaleziono — próba bez słupka
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa && (string.IsNullOrEmpty(slLewa) || !konf.Typ.Contains("Słupek ruchomy")))
                    return konf.RowId;
                if (p1.X > 85 && konf.WystepujePrawa && (string.IsNullOrEmpty(slPrawa) || !konf.Typ.Contains("Słupek ruchomy")))
                    return konf.RowId;
            }
        }

        // 3️⃣ Jeśli dalej nic — bierzemy pierwszą pasującą stronę
        foreach (var konf in stan.MVCKonfModelu.KonfSystem)
        {
            if (jestPionowa)
            {
                if (p1.X < 5 && konf.WystepujeLewa)
                    return konf.RowId;
                if (p1.X > 85 && konf.WystepujePrawa)
                    return konf.RowId;
            }
            else if (jestPozioma)
            {
                if (p1.Y < 5 && konf.WystepujeGora)
                    return konf.RowId;
                if (p1.Y > 75 && konf.WystepujeDol)
                    return konf.RowId;
            }
        }

        return znaleziony;
    }


    public SasiadInfo ZnajdzSasiada(
    List<XPoint> linia,
    List<GeneratorState> wszystkieStany,
    int kat,
    bool ruchomySlupekPoLewej,
    bool ruchomySlupekPoPrawej,
    string obecnyRegionId,
    double tolerancja = 0.03)
    {
        var pasujace = new List<SasiadInfo>();

        if (linia == null || linia.Count != 2)
            return new SasiadInfo { RowIdElementu = Guid.Empty, IdRegionu = "", ZIndeks = -1 };

        var p1 = linia[0];
        var p2 = linia[1];

        bool jestPionowa = Math.Abs(p1.X - p2.X) < tolerancja;
        bool jestPozioma = Math.Abs(p1.Y - p2.Y) < tolerancja;

        string slPoLewej = ruchomySlupekPoLewej ? "Słupek ruchomy" : "";
        string slPoPrawej = ruchomySlupekPoPrawej ? "Słupek ruchomy" : "";

        var stanyDoPrzeszukania = wszystkieStany
            .Where(s => s.WierzcholkiWartosciNominalne != null && s.IdRegion != obecnyRegionId)
            .OrderByDescending(s => s.Id);

        foreach (var stan in stanyDoPrzeszukania)
        {
            var wierzcholki = stan.WierzcholkiWartosciNominalne!;
            var linieStanu = ExtractLinesFromSquare(wierzcholki);

            double stanMinX = wierzcholki.Min(p => p.X);
            double stanMaxX = wierzcholki.Max(p => p.X);
            double stanMinY = wierzcholki.Min(p => p.Y);
            double stanMaxY = wierzcholki.Max(p => p.Y);

            foreach (var innaLinia in linieStanu)
            {
                if (innaLinia.Count != 2) continue;

                var q1 = innaLinia[0];
                var q2 = innaLinia[1];

                if (!CzyNakladajaSieDowolne(p1, p2, q1, q2, tolerancja))
                    continue;

                var konfLista = stan.MVCKonfModelu?.KonfSystem;
                if (konfLista == null) continue;

                foreach (var konf in konfLista)
                {
                    if (jestPionowa)
                    {
                        // Lewa krawędź sąsiada
                        if (Math.Abs(p1.X - stanMinX) < tolerancja &&
                            konf.WystepujeLewa &&
                            (string.IsNullOrEmpty(slPoPrawej) || konf.Typ.Contains(slPoPrawej)))
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks
                            });
                        }

                        // Prawa krawędź sąsiada
                        if (Math.Abs(p1.X - stanMaxX) < tolerancja &&
                            konf.WystepujePrawa &&
                            (string.IsNullOrEmpty(slPoLewej) || konf.Typ.Contains(slPoLewej)))
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks
                            });
                        }
                    }
                    else if (jestPozioma)
                    {
                        // Górna krawędź sąsiada
                        if (Math.Abs(p1.Y - stanMinY) < tolerancja &&
                            konf.WystepujeGora)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks
                            });
                        }

                        // Dolna krawędź sąsiada
                        if (Math.Abs(p1.Y - stanMaxY) < tolerancja &&
                            konf.WystepujeDol)
                        {
                            pasujace.Add(new SasiadInfo
                            {
                                RowIdElementu = konf.RowId,
                                IdRegionu = stan.IdRegion,
                                ZIndeks = stan.ZIndeks
                            });
                        }
                    }
                }
            }
        }

        return pasujace
            .OrderBy(p => p.ZIndeks)
            .FirstOrDefault() ?? new SasiadInfo { RowIdElementu = Guid.Empty, IdRegionu = "", ZIndeks = -1 };
    }


    private bool CzyPunktyRowne(XPoint p1, XPoint p2, double tolerancja)
    {
        return Math.Abs(p1.X - p2.X) < tolerancja && Math.Abs(p1.Y - p2.Y) < tolerancja;
    }

    private double DlugoscWspolna(XPoint a1, XPoint a2, XPoint b1, XPoint b2)
    {
        if (Math.Abs(a1.X - a2.X) < 0.01) // pionowa
        {
            var minY1 = Math.Min(a1.Y, a2.Y);
            var maxY1 = Math.Max(a1.Y, a2.Y);
            var minY2 = Math.Min(b1.Y, b2.Y);
            var maxY2 = Math.Max(b1.Y, b2.Y);
            return Math.Max(0, Math.Min(maxY1, maxY2) - Math.Max(minY1, minY2));
        }
        else if (Math.Abs(a1.Y - a2.Y) < 0.01) // pozioma
        {
            var minX1 = Math.Min(a1.X, a2.X);
            var maxX1 = Math.Max(a1.X, a2.X);
            var minX2 = Math.Min(b1.X, b2.X);
            var maxX2 = Math.Max(b1.X, b2.X);
            return Math.Max(0, Math.Min(maxX1, maxX2) - Math.Max(minX1, minX2));
        }

        return 0;
    }


    // private string OkreslStrone(double kat)
    // {
    //     // Normalizuj kąt do zakresu 0-360
    //     kat = (kat % 360 + 360) % 360;

    //     // Tolerancja dla ustawień poziomych/pionowych
    //     const double tolerancja = 5.0;

    //     if (Math.Abs(kat - 0) < tolerancja || Math.Abs(kat - 180) < tolerancja || Math.Abs(kat - 360) < tolerancja)
    //     {
    //         return "góra"; // Linia pozioma (góra/dół)
    //     }
    //     else if (Math.Abs(kat - 90) < tolerancja || Math.Abs(kat - 270) < tolerancja)
    //     {
    //         return "lewa"; // Linia pionowa (lewa/prawa)
    //     }

    //     return "dół"; // Domyślnie
    // }

    // private static bool CzyWspolosiowe(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol)
    // {
    //     bool aPion = Math.Abs(a1.X - a2.X) < tol;
    //     bool bPion = Math.Abs(b1.X - b2.X) < tol;

    //     if (aPion && bPion)
    //         return Math.Abs(a1.X - b1.X) < tol;

    //     bool aPoziom = Math.Abs(a1.Y - a2.Y) < tol;
    //     bool bPoziom = Math.Abs(b1.Y - b2.Y) < tol;

    //     if (aPoziom && bPoziom)
    //         return Math.Abs(a1.Y - b1.Y) < tol;

    //     return false; // różne kierunki
    // }

    private static bool CzyNakladajaSieDowolne(XPoint a1, XPoint a2, XPoint b1, XPoint b2, double tol = 0.02)
    {
        // Wektory
        var va = new Vector2D(a2.X - a1.X, a2.Y - a1.Y);
        var vb = new Vector2D(b2.X - b1.X, b2.Y - b1.Y);

        // Równoległość
        if (Math.Abs(Vector2D.Cross(va, vb)) > tol)
            return false;

        // Kolinearność: sprawdź czy b1 i b2 leżą na linii a1–a2
        bool b1OnLine = Math.Abs(Vector2D.Cross(va, new Vector2D(b1.X - a1.X, b1.Y - a1.Y))) < tol;
        bool b2OnLine = Math.Abs(Vector2D.Cross(va, new Vector2D(b2.X - a1.X, b2.Y - a1.Y))) < tol;
        if (!b1OnLine || !b2OnLine)
            return false;

        // Normalizacja wektora osi
        var axis = va.Normalize();

        // Projekcja punktów
        double[] proj = new double[4];
        proj[0] = new Vector2D(a1.X, a1.Y).Dot(axis);
        proj[1] = new Vector2D(a2.X, a2.Y).Dot(axis);
        proj[2] = new Vector2D(b1.X, b1.Y).Dot(axis);
        proj[3] = new Vector2D(b2.X, b2.Y).Dot(axis);

        double aMin = Math.Min(proj[0], proj[1]);
        double aMax = Math.Max(proj[0], proj[1]);
        double bMin = Math.Min(proj[2], proj[3]);
        double bMax = Math.Max(proj[2], proj[3]);

        bool overlap = aMax >= bMin - tol && bMax >= aMin - tol;
      //  Console.WriteLine($"🔍🔍🔍🔍 CzyNakladajaSieDowolne linie - OK 🔍🔍🔍🔍");
        return overlap;
    }

    private readonly struct Vector2D
    {
        public readonly double X;
        public readonly double Y;

        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }

        public double Length => Math.Sqrt(X * X + Y * Y);

        public Vector2D Normalize()
        {
            var len = Length;
            return len > 0 ? new Vector2D(X / len, Y / len) : new Vector2D(0, 0);
        }

        public static double Cross(Vector2D a, Vector2D b) => a.X * b.Y - a.Y * b.X;

        public double Dot(Vector2D other) => X * other.X + Y * other.Y;
    }


    public static List<List<XPoint>> ExtractLinesFromSquare(List<XPoint> wierzcholki)
    {
        var linie = new List<List<XPoint>>();

        if (wierzcholki == null || wierzcholki.Count < 2)
            return linie; // brak linii

        for (int i = 0; i < wierzcholki.Count; i++)
        {
            var start = wierzcholki[i];
            var end = (i == wierzcholki.Count - 1) ? wierzcholki[0] : wierzcholki[i + 1]; // zamknięcie figury

            linie.Add(new List<XPoint> { start, end });
        }

        return linie;
    }


    private void ZapiszStanGeneratora(string idRegion, GeneratorState state)
    {

        _generatorStates[idRegion] = state;

        Console.WriteLine($"✅ Zapisano stan generatora dla regionu {idRegion}. Liczba _generatorStates: {_generatorStates?.Count ?? 0}");
    }

    private bool CzyPunktWNWielokacie(XPoint punkt, List<XPoint> wielokat)
    {
        int j = wielokat.Count - 1;
        bool inside = false;

        for (int i = 0; i < wielokat.Count; j = i++)
        {
            if (((wielokat[i].Y > punkt.Y) != (wielokat[j].Y > punkt.Y)) &&
                (punkt.X < (wielokat[j].X - wielokat[i].X) * (punkt.Y - wielokat[i].Y) / (wielokat[j].Y - wielokat[i].Y) + wielokat[i].X))
            {
                inside = !inside;
            }
        }

        return inside;
    }


    private bool CzyPunktLezyNaKrawedzi(XPoint punkt, List<XPoint> wielokat, double tolerancja = 0.1)
    {
        for (int i = 0; i < wielokat.Count; i++)
        {
            var a = wielokat[i];
            var b = wielokat[(i + 1) % wielokat.Count];

            // Sprawdzenie, czy punkt leży na odcinku AB
            double dx = b.X - a.X;
            double dy = b.Y - a.Y;
            double d = Math.Sqrt(dx * dx + dy * dy);

            if (d < 1e-6) continue; // pomijamy zbyt krótkie odcinki

            double t = ((punkt.X - a.X) * dx + (punkt.Y - a.Y) * dy) / (d * d);

            if (t >= 0 && t <= 1)
            {
                double projX = a.X + t * dx;
                double projY = a.Y + t * dy;
                double dist = Math.Sqrt(Math.Pow(projX - punkt.X, 2) + Math.Pow(projY - punkt.Y, 2));

                if (dist <= tolerancja)
                    return true;
            }
        }

        return false;
    }



    private async Task GenerujElementyDlaRegionu(string idRegion, float szerokosc, float wysokosc)
    {
        if (!_generatorStates.TryGetValue(idRegion, out var state))
        {
            Console.WriteLine($"❌ Brak stanu generatora dla regionu {idRegion}");
            return;
        }

        var generator = new Generator
        {
            //KonfiguracjeSystemu = state.PowiazaneModele,
            RowIdSystemu = state.RowIdSystemu,
            MVCKonfModelu = state.MVCKonfModelu,
            TypKsztaltu = state.WybranyKsztalt,
            EdytowanyModel = state.WybranyModel,
        };


        var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);
        var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

        // Sprawdź, czy region skrzydła ma linię dzielącą z ruchomym słupkiem
        bool czyRegionZawieraSlupekRuchomy = _regionsSkrzydlo?.Any(x => x.TypLiniiDzielacej == "Słupek ruchomy") == true;

     //   Console.WriteLine($"✅ czyRegionZawieraSlupekRuchomy: {czyRegionZawieraSlupekRuchomy}");

        if (czyRegionZawieraSlupekRuchomy)
        {
            Console.WriteLine($"✅ Region {idRegion} zawiera słupek ruchomy. Kontynuuję generowanie elementów.");

            // Sprawdź, czy istnieje "Słupek ruchomy" w jakimkolwiek PowiazanymModelu (lista)
            bool czyZawieraSlupekRuchomyWPowiazanymModelu = StateContainer.States
                 .Any(state =>
                     state.Value.MVCKonfModelu != null &&
                     state.Value.MVCKonfModelu.KonfSystem != null &&
                     state.Value.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy")
                 );


            if (!czyZawieraSlupekRuchomyWPowiazanymModelu)
            {
                // Sprawdź, czy istnieje "Słupek ruchomy" w pojedynczym PowiazanymModelu (np. generator)
                bool czySlupekRuchomyWPojedynczymModelu = generator.MVCKonfModelu != null &&
                    generator.MVCKonfModelu.KonfSystem != null &&
                    generator.MVCKonfModelu.KonfSystem.Any(ks => ks.Typ == "Słupek ruchomy");

                if (!czySlupekRuchomyWPojedynczymModelu)
                {
                    await _message.Warning(
                        "Brak słupka ruchomego w regionie skrzydła. Dodaj słupek ruchomy do systemu.",
                        2.0
                    );
                    return;
                }
            }
        }

        double minX = 0, maxX = 0, minY = 0, maxY = 0;

        if (wybranyRegionDualRama != null)
        {
            var regionPoints = wybranyRegionDualRama.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 0;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion, _generatorStates);
        }
        else if (wybranyRegionSkrzydlo != null)
        {
            var regionPoints = wybranyRegionSkrzydlo.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindeks = 1;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion, _generatorStates);
        }
        else
        {
            Console.WriteLine($"❌ Nie znaleziono regionu o ID {idRegion}");
            return;
        }

        // Skalowanie i przesunięcie jeśli zmieniasz szerokość/wysokość
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }

            }
        }

        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

       // Console.WriteLine($"✅ Wygenerowano elementy dla regionu {idRegion} po skalowaniu.");
        await Task.CompletedTask;
    }


    private async Task RenderFrame(bool calculate = true)
    {
        try
        {
            if (_context == null || ksztalty == null || !ksztalty.Any())
                return;

            // Przygotowanie canvas
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);
            //await _context.TranslateAsync(_panX, _panY);
            await _context.ScaleAsync(_currentScale, _currentScale);

            // Przygotowanie tekstury
            var baseUrl = Navigation.BaseUri;
            var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

            // Rysowanie każdego kształtu
            foreach (var ksztalt in ksztalty)
            {
                //Console.WriteLine($"Rysuję kształt: {ksztalt.TypKsztaltu}");
                if (ksztalt.Wierzcholki == null || ksztalt.Wierzcholki.Count < 3)
                    continue;
                // Console.WriteLine($"*********** >>>>>> ksztalt: {ksztalt.Id}");

                await DrawShapeWithVariableOffset(_context, ksztalt, imageUrl, calculate);
                await DrawSingleContourTextOnly(_context, ksztalt.Wierzcholki, $"{ksztalt.RowIdElementu.ToString()}-{ksztalt.Kat.ToString()}/{ksztalt.Strona}");
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd renderowania: {ex.Message}\n{ex.StackTrace}");
        }
    }

    private async Task DrawShapeWithVariableOffset(Canvas2DContext context, KsztaltElementu ksztalt, string textureUrl, bool calculate)
    {
        var outerPoints = ksztalt.Wierzcholki;

        // Console.WriteLine($"outerPoints: {outerPoints.Count}");

        var offsets = GetOffsetsForGroup(ksztalt.Grupa);

        await DrawSingleContour(context, outerPoints);

        // await DrawDoubleContour(context, outerPoints, innerPoints);
        if (_dotNetHelper != null)
        {
            await JS.InvokeVoidAsync("loadAndDrawTexture",
                CanvasRef.CanvasReference,
                textureUrl,
                _dotNetHelper
            );
        }


        await context.SetStrokeStyleAsync("#000000");
        await context.SetLineWidthAsync(1.5f);
        await context.StrokeAsync();
    }


    private (float left, float right, float top, float bottom) GetOffsetsForGroup(string grupa)
    {
        // Domyślne wartości (można dostosować)
        float grLewo = 82;
        float grPrawo = 82;
        float grGora = 82;
        float grDol = 92;

        return grupa switch
        {
            "Lewo" => (grLewo, 0, 0, 0),
            "Prawo" => (0, grPrawo, 0, 0),
            "Gora" => (0, 0, grGora, 0),
            "Dol" => (0, 0, 0, grDol),
            _ => (grLewo, grPrawo, grGora, grDol) // Domyślne dla innych przypadków
        };
    }

    private async Task DrawSingleContour(Canvas2DContext context, List<XPoint> outerPoints)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Rysuj pojedynczy kontur zewnętrzny
        await context.BeginPathAsync();

        // Rozpocznij od pierwszego punktu
        await context.MoveToAsync(outerPoints[0].X, outerPoints[0].Y);

        // Rysuj linie do kolejnych punktów
        for (int i = 1; i < outerPoints.Count; i++)
        {
            await context.LineToAsync(outerPoints[i].X, outerPoints[i].Y);
        }

        // Zamknij kształt
        await context.ClosePathAsync();

        // Opcjonalne stylowanie
        await context.SetStrokeStyleAsync("black");
        await context.SetLineWidthAsync(2);
        await context.StrokeAsync();
    }

    private async Task DrawSingleContourTextOnly(Canvas2DContext context, List<XPoint> outerPoints, string tekst)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Oblicz środek figury
        double centerX = outerPoints.Average(p => p.X);
        double centerY = outerPoints.Average(p => p.Y);

        // Sprawdź proporcje
        double width = outerPoints.Max(p => p.X) - outerPoints.Min(p => p.X);
        double height = outerPoints.Max(p => p.Y) - outerPoints.Min(p => p.Y);
        bool rotate = height > width;

        // Rysowanie tekstu
        await context.SaveAsync();
        await context.SetFontAsync($"28px Arial");
        await context.SetFillStyleAsync("black");
        await context.SetTextAlignAsync(TextAlign.Center);
        await context.SetTextBaselineAsync(TextBaseline.Middle);

        if (rotate)
        {
            await context.TranslateAsync(centerX, centerY);
            await context.RotateAsync((float)Math.PI / 2); // 90 stopni
            await context.FillTextAsync(tekst, 0, 0);
        }
        else
        {
            await context.FillTextAsync(tekst, centerX, centerY);
        }

        await context.RestoreAsync();
    }


    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task GoCAD()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        NavigationManager.NavigateTo($"/DrawCAD");

        await Task.CompletedTask;
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                //Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    public class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class PointClassification
    {
        public bool IsLeft { get; set; }
        public bool IsRight { get; set; }
        public bool IsTop { get; set; }
        public bool IsBottom { get; set; }
    }

    public class DraggedModelInfo
    {
        public string? Type { get; set; }
        public string? RowId { get; set; }
    }

    private class DomSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    public class SasiadInfo
    {
        public Guid RowIdElementu { get; set; }
        public string? IdRegionu { get; set; }
        public int ZIndeks { get; set; }
    }

    public class PrzesuniecieDto
    {
        public double PrzesuniecieX { get; set; }
        public double PrzesuniecieY { get; set; }
    }

}