@page "/Modele-okienne"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@using GEORGE.Client.Pages.Utils
@inject IJSRuntime JS
@inject Utilities.ILocalStorage LocalStorage
@inject HttpClient Http
@using System.Net
@using System.Globalization
@inject IMessageService _message
@inject INotificationService _notice
@inject NavigationManager Navigation
@inject NavigationManager NavigationManager
@inject ShapeTransferService ShapeService
@using System.IO;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.Processing;
@using SixLabors.ImageSharp.Formats.Png;

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using GEORGE.Client.Pages.Models
@using GEORGE.Client.Pages.Okna

@implements IDisposable

<script>
    (() => {
    // Inicjalizacja globalnych zmiennych
    const _originalInvoke = DotNet.invokeMethodAsync;
    DotNet.invokeMethodAsync = function (assemblyName, methodName, ...args) {
        console.log(`🔍 DotNet.invokeMethodAsync intercepted: ${assemblyName}.${methodName}`, args);
        return _originalInvoke(assemblyName, methodName, ...args)
            .catch(err => {
                console.warn("❌ Intercepted DotNet.invokeMethodAsync error:", err);
                throw err;
            });
    };

    window._dragListenersInitialized = window._dragListenersInitialized || false;

    window.currentDraggedModel = null;
    window.currentDraggedType = null;
    window.isDragging = false;
    window.blazorCanvas = null;

    // Ustawienie referencji do canvasu
    window.setCanvasRef = (canvasRef) => {
    if (!canvasRef) {
    console.error("❌ Blazor przekazał null do setCanvasRef!");
    return;
    }
    window.blazorCanvas = canvasRef;
    console.log("✅ Canvas ustawiony!", canvasRef);
    };

    // Ustawienie referencji do .NET
    window.setDotNetHelper = (dotNetHelper) => {
    window.dotNetHelper = dotNetHelper;
    console.log("✅ DotNetHelper ustawiony!");
    };

    // Funkcja rozpoczynająca przeciąganie
    window.startDrag = (modelType, event) => {
    if (event.button !== 0) return; // Obsługa tylko lewego przycisku myszy

    event.preventDefault();
    window.isDragging = true;
    window.currentDraggedType = modelType;

    // Pobranie obrazka do ustawienia jako kursor
    const img = document.getElementById(`wing-${modelType}`);
    if (!img) {
    console.error(`❌ Nie znaleziono obrazka dla modelu: ${modelType}`);
    return;
    }

    // Tworzymy nowy obrazek, który będzie podążał za kursorem
    const cursorImg = new Image();
    cursorImg.src = img.src;
    cursorImg.style.position = "absolute";
    cursorImg.style.pointerEvents = "none";
    cursorImg.style.width = "50px";
    cursorImg.style.height = "50px";
    cursorImg.style.opacity = "0.8";
    cursorImg.id = "dragCursorImage";

    document.body.appendChild(cursorImg);
    window.currentDraggedImage = cursorImg;

    // Aktualizacja pozycji obrazka pod kursorem
    window.updateCursorImagePosition(event);
    };

    //     // Aktualizacja pozycji obrazka kursora
    // window.updateCursorImagePosition = (event) => {
    //         if (!window.isDragging || !window.currentDraggedImage) return;
    //         window.currentDraggedImage.style.left = `${event.pageX - 25}px`;
    //         window.currentDraggedImage.style.top = `${event.pageY - 25}px`;
    //     };

    // Funkcja kończąca przeciąganie

    if (!window._stopDragDefined) {
        window.stopDrag = async function (event) {
            if (!window.isDragging) return;

            window.isDragging = false;

            if (window.currentDraggedImage) {
                document.body.removeChild(window.currentDraggedImage);
                window.currentDraggedImage = null;
            }

            if (!window.blazorCanvas) {
                console.error("❌ Brak referencji do canvasu!");
                return;
            }

            const rect = window.blazorCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            console.log(`🛑 Upuszczono model: ${window.currentDraggedType} na (${x}, ${y})`);

            if (window.dotNetHelper) {
                try {
                    await window.dotNetHelper.invokeMethodAsync('OnDragEnd', window.currentDraggedType, x, y);
                } catch (err) {
                    console.warn("❌ invokeMethodAsync (OnDragEnd) nie powiodło się:", err);
                    window.dotNetHelper = null;
                }
            }

            window.currentDraggedType = null;
        };

        document.addEventListener("mouseup", window.stopDrag);
        window._stopDragDefined = true;
    }


    // Obsługa aktualizacji kursora
    document.addEventListener("mousemove", window.updateCursorImagePosition);

    // Obsługa upuszczenia obrazka
   if (!window._dragListenersInitialized) {
    document.addEventListener("mouseup", window.stopDrag);
    document.addEventListener("mousemove", window.updateCursorImagePosition);
    window._dragListenersInitialized = true;
    }



    window.SetCustomCursor = (base64Image) => {
    console.log("🔵 Ustawiam kursor na Base64!");

    const cursorUrl = `data:image/png;base64,${base64Image}`;
    document.body.style.cursor = `url(${cursorUrl}) 8 8, auto`;

    // console.log(`🖱 Kursor ustawiony globalnie: ${cursorUrl}`);
    };

    window.ResetCursor = () => {
    console.log("🔄 Resetowanie kursora");
    document.querySelector(".canvas-container").style.cursor = "default";
    document.querySelector("canvas").style.cursor = "default";
    };

    // JavaScript
    window.AddCanvasHoverListener = (canvasElement) => {
    canvasElement.addEventListener('mousemove', () => {
    // Wymusza aktualizację kursora, jeśli został już ustawiony
    if (document.body.style.cursor.includes('url')) {
    document.body.style.cursor = document.body.style.cursor;
    }
    });
    };

    // Funkcja do ładowania tekstury
    window.loadAndDrawTexture = async (canvasElement, imageUrl, dotNetHelper) => {
    const ctx = canvasElement.getContext('2d');
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageUrl;

    await new Promise((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = reject;
    console.log("🔍 dotNetHelper:", dotNetHelper);
    });

    const pattern = ctx.createPattern(img, 'repeat');
    ctx.fillStyle = pattern;

    // ❗ Dodaj tę linię, aby wypełnić aktualną ścieżkę!
    ctx.fill("evenodd");

    ctx.canvas.dataset.pattern = "wood-pattern";
    
    if (dotNetHelper) {
        try {
            await dotNetHelper.invokeMethodAsync('OnTextureLoaded');
        } catch (err) {
            console.warn("❌ OnTextureLoaded invoke failed", err);
        }
    }
    };

    // Globalny reset kursora z obsługą wszystkich przeglądarek
    window.ResetCursorGlobal = () => {
    // Reset dla wszystkich możliwych elementów
    document.documentElement.style.cursor = 'default';
    document.body.style.cursor = 'default';
    document.querySelector('.canvas-container').style.cursor = 'default';

    // Wymuś natychmiastowe odświeżenie
    const style = document.createElement('style');
    style.innerHTML = '*{cursor: default !important;}';
    document.head.appendChild(style);
    setTimeout(() => document.head.removeChild(style), 100);
    };

    let currentModel = null;

    window.SetCurrentModel = (modelType, modelRowId) => {
    currentModel = modelType;
    window.currentDraggedModel = {
    type: modelType,
    rowId: modelRowId
    };

    document.documentElement.setAttribute('data-current-model', modelType);
    document.documentElement.setAttribute('data-model-row-id', modelRowId);
    console.log(`📦 Ustawiono model: ${modelType}, ID: ${modelRowId}`);
    };

    window.getDraggedModelInfo = () => {
    if (!window.currentDraggedModel) {
    console.warn("⚠️ currentDraggedModel is not set.");
    return null;
    }

    return {
    type: window.currentDraggedModel.type,
    rowId: window.currentDraggedModel.rowId
    };
    };


    window.clearCurrentModel = () => {
    currentModel = null;
    document.documentElement.removeAttribute('data-current-model');
    };

    // Blokuj domyślne zachowanie przeglądarki
    document.addEventListener('dragover', (e) => {
    e.preventDefault();
    });

    window.getCanvasBoundingRect = function (canvasElement) {
        if (!canvasElement) {
            console.warn("❌ Canvas element is null in JS.");
            return null;
        }

        const rect = canvasElement.getBoundingClientRect();
        return {
            left: rect.left,
            top: rect.top,
            width: rect.width,
            height: rect.height
        };
    };

    })();

window.clearDotNetHelper = () => {
    console.log("🧹 Czyszczenie dotNetHelper. Stary:", window.dotNetHelper);
    window.dotNetHelper = null;
};

window.getElementSize = (selector) => {
    const el = document.querySelector(selector);
    if (!el) return null;

    const rect = el.getBoundingClientRect();
    return {
        width: rect.width,
        height: rect.height
    };
};

window.registerResizeCallback = (dotnetHelper) => {
    window.addEventListener("resize", () => {
        dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
    });
};

    window.registerResizeHandler = function (dotnetHelper) {
        window.addEventListener("resize", () => {
            dotnetHelper.invokeMethodAsync("UpdateCanvasSizeFromResize");
        });
    };

</script>

<style>
    /* Globalne ustawienia */
    html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #f8f9fa;
    }

    /* Specjalna klasa dla resetu */
    .cursor-reset * {
    cursor: default !important;
    pointer-events: auto !important;
    }

    /* Kontener główny */
    .window-model-container {
    display: flex;
    height: 70vh;
    background-color: #fff;
    padding: 10px;
    box-sizing: border-box;
    }

    /* Panel boczny z modelami */
    .wing-model-container {
    flex: 0 0 250px; /* Szerokość panelu bocznego */
    height: 100%;
    overflow-y: auto;
    border-right: 2px solid #ddd;
    padding: 10px;
    background: #f8f9fa;
    }

    /* Tabela modeli */
    .wing-model-container table {
    font-size: 13px;
    width: 100%;
    border-collapse: collapse;
    }

    .wing-model-container th, .wing-model-container td {
    padding: 6px;
    text-align: center;
    }

    .wing-model-container th {
    background-color: #007bff;
    color: white;
    }

    .wing-model-container tr:hover {
    background-color: rgba(0, 123, 255, 0.1);
    }

    /* Miniatury modeli */
    .wing-model-container img {
    width: 45px;
    height: 45px;
    object-fit: contain;
    cursor: -webkit-grab; /* Obsługa w Safari */
    cursor: grab;
    transition: transform 0.2s ease-in-out;
    }

    .wing-model-container img:hover {
    transform: scale(1.1);
    }

    /* Główne okno wyświetlania */
    .display-window {
    flex-grow: 1;
    height: 100%;
    min-height: 400px; /* Zapewnienie minimalnej wysokości */
    border: 2px solid #ddd;
    background-color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
    position: relative;
    overflow: hidden;
    cursor: crosshair;
    }

    .container {
    position: relative;
    width: 100%;
    height: 100%;
    }

    .canvas-container {
    width: @(CanvasWidth + "px");
    height: @(CanvasHeight + "px");
    pointer-events: none; /* Wyłącz interakcje z canvasem */
    max-width: 100%;
    max-height: 100%;
    border: 2px solid #ddd;
    background-color: #fff;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: auto; /* Ukrywa przewijanie */
    position: relative;
    }

    canvas {
    pointer-events: none; /* Kontynuuj ignorowanie zdarzeń */
    display: block;
    max-width: 100%;
    max-height: 100%;
    background-color: transparent;
    }

    .interactive-layer {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2; /* Warstwa NAD canvasem */
    pointer-events: auto; /* Włącz interakcje */
    }
    /* Paski przewijania */
    .wing-model-container::-webkit-scrollbar {
    width: 8px;
    }

    .wing-model-container::-webkit-scrollbar-thumb {
    background: #007bff;
    border-radius: 5px;
    }

    .wing-model-container::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
    }

    /* 🔹 Toolbar z przyciskami */
    .toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: center;
    padding: 10px;
    background: #fff;
    }

    /* Styl dla przycisków */
    .toolbar .btn {
    flex: 1;
    min-width: 90px;
    font-size: 13px;
    padding: 6px 8px;
    transition: all 0.2s ease-in-out;
    }

    .toolbar .btn:hover {
    transform: scale(1.05);
    }

    .zoom-controls {
    position: absolute;
    top: 170px; /* Ustawienie 10px od góry */
    right: 10px; /* Ustawienie 10px od prawej */
    display: flex;
    gap: 10px; /* Odstęp między przyciskami */
    z-index: 1000; /* Upewnia się, że są na wierzchu */
    }

    .btn-zoom {
    width: 40px;
    height: 40px;
    font-size: 20px;
    border-radius: 50%; /* Okrągłe przyciski */
    border: none;
    background-color: #007bff; /* Niebieski, możesz zmienić */
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Delikatny cień */
    transition: background-color 0.3s ease;
    }

    .btn-zoom:hover {
    background-color: #0056b3; /* Ciemniejszy niebieski przy najechaniu */
    }

    /* Panel zajmuje pełną szerokość */
    .scrollable-panel {
    width: 100%;
    max-height: 400px; /* Możesz zmienić na więcej, np. 600px */
    overflow-y: auto; /* Włącza przewijanie w pionie */
    }

    /* Sider zajmuje całą szerokość */
    .info-panel {
    background-color: #222;
    color: #ffeb99;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);
    width: 500px; /* Pełna szerokość */
    max-width: 1000px;
    }

    /* Lista informacji */
    .info-list {
    list-style: none;
    padding: 0;
    width: 760px;
    }

    /* Każdy element ma własne miejsce */
    .info-item {
    background: #333;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 10px;
    box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 760px;
    }

    /* Tekst jasnożółty */
    .info-item span {
    color: #ffeb99;
    font-size: 1em;
    }

    .info-item strong {
    color: #ffcc00;
    }

    /* Obsługa braku danych */
    .no-data {
    color: red;
    text-align: center;
    font-style: italic;
    }

    /* Lista materiałów */
    .materials-list {
    list-style: none;
    padding: 0;
    width: 100%;
    }

    /* Pojedynczy materiał */
    .material-item {
    background: #333;
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 10px;
    box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    gap: 6px;
    width: 100%;
    }

    /* Kolor jasny dla tekstu */
    .material-item span {
    color: #ffeb99;
    font-size: 1em;
    }

    .material-item strong {
    color: #ffcc00;
    }

</style>

<!-- Nagłówek -->

<div class="d-flex justify-content-between align-items-center mt-2 mb-2">
    <h3 class="mb-0">Modele Okienne</h3>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoCAD">
        OKN-CAD
    </Button>
    <label> </label>
    <button class="btn btn-primary" @onclick="GoBack">
        <i class="fas fa-arrow-left"></i> Wróć
    </button>

</div>

<Collapse Animation>
    <Panel Header="Wymiary, kolory itp. Okien" Key="1">
        <div class="form-group mt-3">
            <label>Szerokość:</label>
            <input type="number" class="form-control" @bind="Szerokosc" />

            <label>Wysokość:</label>
            <input type="number" class="form-control" @bind="Wysokosc" />

            <label>Kolor:</label>
            <input type="color" class="form-control" @bind="Kolor" />
        </div>
        <Button OnClick="() => ZmienWymiaryOkna()">Zmień wymiary</Button>
    </Panel>

    <Panel Header="Informacja o wyrobie restrykcje" Key="2" class="scrollable-panel">
        <Sider class="info-panel">
            <h4 style="color:aquamarine;">🛠️ Informacja o wyrobie:</h4>

            @if (infoObiekt != null && infoObiekt.Any())
            {
                <p class="entries-count"> 📌 Liczba wpisów: <strong>@infoObiekt.Count()</strong></p>
                <ul class="info-list">
                    @foreach (var wymiar in infoObiekt)
                    {
                        <li class="info-item">
                            <span><strong>📏 Szerokość:</strong> @wymiar.Szerokosc mm</span>
                            <span><strong>📐 Wysokość:</strong> @wymiar.Wysokosc mm</span>
                            <span><strong>🏗️ Wyrób:</strong> @wymiar.RodzajObiektu</span>
                            <span><strong>⚠️ Restrykcje:</strong> @wymiar.Restrykcja</span>
                        </li>
                    }
                </ul>
            }
            else
            {
                <p class="no-data">❌ Brak danych o wyrobie.</p>
            }
        </Sider>
    </Panel>
    <Panel Header="Materiały" Key="3" class="scrollable-panel">
        @if (infoBoom != null && infoBoom.Any())
        {
            <p class="entries-count">📌 Liczba materiałów: <strong>@infoBoom.Count()</strong></p>
            <ul class="materials-list">
                @foreach (var material in infoBoom)
                {
                    <li class="material-item">
                        <span><strong>📏 Długość:</strong> @material.Dlugosc mm</span>
                        <span><strong>🏷️ Nazwa:</strong> @material.Nazwa</span>
                        <span><strong>🔢 Indeks:</strong> @material.Indeks</span>
                        <span><strong>📦 Ilość sztuk:</strong> @material.IloscSztuk</span>
                        <span><strong>⚠️ Restrykcje:</strong> @material.Restrykcja</span>
                    </li>
                }
            </ul>
        }
        else
        {
            <p class="no-data">❌ Brak użytych materiałów.</p>
        }
    </Panel>

</Collapse>


<!-- Kontener na modele i canvas -->
<div class="window-model-container">
    <!-- Kontener na przyciski -->
    <div class="zoom-controls">
        <label>@mousePosition skala: @((int)(_currentScale * 100))</label>
        <button @onclick="ZoomIn" class="btn-zoom">➕</button>
        <button @onclick="ZoomOut" class="btn-zoom">➖</button>
        <button @onclick="PokazModal" class="btn-zoom">💎</button>
    </div>
    <!-- Panel boczny z modelami -->
    <div class="wing-model-container">
        <!-- 🔹 Wybór systemu -->
        <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
            <div class="d-flex">
                @if (Systemy != null && Systemy.Any())
                {
                    <select class="form-select me-2" style="width:100%" @onchange="@(async (args) => await OnSystemSelected(args))">
                        <option value="" disabled selected>-- Wybierz system --</option>
                        @foreach (var system in Systemy)
                        {
                            <option value="@system.RowId">@system.Nazwa_Systemu</option>
                        }
                    </select>
                }
            </div>
        </Tooltip>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Typ</th>
                    <th>Wymiary</th>
                    <th>Miniaturka</th>
                </tr>
            </thead>
            <tbody>
                @if (ListaModeli != null)
                {
                    @foreach (var model in ListaModeli)
                    {
                        <tr>
                            <td>@model.Typ</td>
                            <td>@model.KonstrMinSzer x @model.KonstrMinWys → @model.KonstrMaxSzer x @model.KonstrMaxWys</td>
                            <td>
                                @if (model.Rysunek != null && model.Ikona32x32.Length > 0)
                                {
                                    <img id="@($"wing-{model.Typ}")"
                                    src="data:image/png;base64,@Convert.ToBase64String(model.Rysunek)"
                                    @onclick='@(() => WybierzModel(model))'
                                    @ondragstart='@(e => JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId))'
                                    @onmouseout='@(e => JS.InvokeVoidAsync("ResetCursor"))'
                                    draggable="true"
                                    style="cursor: grab;
                                  width: auto;
                                  height: auto;
                                  max-width: 50px;
                                  max-height: 50px;
                                  border: @(model == WybranyModel ? "4px solid #007bff" : "none")" />

                                }
                                else
                                {
                                    <span class="text-muted">Brak</span>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    <!-- Główne okno wyświetlania -->
    <div class="display-window" @onmouseup="OnMouseUp"  @onmousemove="MouseMove"
    style="position: relative; /* Wymagane dla warstw */
            overflow: visible; /* Zapobiega przycinaniu kursora */
            cursor: inherit; /* Dziedziczy kursor z JS */">

        <!-- Tutaj elementy reagujące na kursor (np. przyciski) -->
        @if (hasCanvasError)
        {
            <p style="color: red; position: relative; z-index: 100;">❌ Błąd: Nie udało się załadować canvasu!</p>
        }
        else
        {
            <!-- Canvas -->
            <div class="canvas-container" style="padding:0px;background-color: transparent;border: 0px;">
                <BECanvas @ref="CanvasRef" Width="@CanvasWidth" Height="@CanvasHeight" />
            </div>
        }
    </div>
</div>

<div class="modal fade @classShowTWZ" tabindex="-1"
style="display: @displayTWZ; margin: auto; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; width: 80%;">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Punkty elementów okien</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="ZamknijModal"></button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto; font-size: 0.85rem; font-family: Consolas, monospace;">
                @if (ksztalty is not null && ksztalty.Any())
                {

                    @foreach (var ksztalt in ksztalty)
                    {
                        <div class="card my-2 shadow-sm">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>Typ:</strong> @ksztalt.TypKsztaltu &nbsp;|&nbsp;
                                    <strong>Grupa:</strong> @ksztalt.Grupa &nbsp;|&nbsp;
                                    <strong>ZIndex:</strong> @ksztalt.ZIndex
                                    <br/>
                                    <strong>IdRegion:</strong> @ksztalt.IdRegion
                                </div>
                                <button class="btn btn-sm btn-primary" @onclick="@(() => EdytujKsztalt(ksztalt.Id))">Edytuj</button>
                            </div>
                            <div class="card-body">
                                @if (edytowanyId == ksztalt.Id)
                                {
                                    <div class="mb-2">
                                        <label>Typ kształtu</label>
                                        <input class="form-control" @bind="ksztalt.TypKsztaltu" />
                                    </div>
                                    <!-- Pozostałe inputy jak wcześniej... -->

                                    <div class="mb-2">
                                        <label><strong>Wierzchołki (X, Y):</strong></label>
                                        @for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                                        {
                                            var punkt = ksztalt.Wierzcholki[i];
                                            var lokalnyIndex = i;  // 👈 to jest klucz

                                            <div class="d-flex align-items-center mb-1" @key="punkt">
                                                <span class="me-2">[@lokalnyIndex]</span>
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                       @oninput="@(e => ZmienX(ksztalt, lokalnyIndex, e))" placeholder="X" />
                                                <input class="form-control me-1" style="width: 100px;" type="number"
                                                       step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                       @oninput="@(e => ZmienY(ksztalt, lokalnyIndex, e))" placeholder="Y" />
                                            </div>
                                        }
                                    </div>

                                    <button class="btn btn-success btn-sm" @onclick="@ZapiszKsztalt">Zapisz</button>
                                    <button class="btn btn-secondary btn-sm ms-2" @onclick="@AnulujEdycje">Anuluj</button>
                                }
                                else
                                {
                                    <p><strong>Wypełnienie wewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieWewnetrzne">@ksztalt.WypelnienieWewnetrzne</span></p>
                                    <p><strong>Wypełnienie zewnętrzne:</strong> <span style="color:@ksztalt.WypelnienieZewnetrzne">@ksztalt.WypelnienieZewnetrzne</span></p>
                                    <p><strong>Grubość obramowania:</strong> @ksztalt.GruboscObramowania px</p>
                                    <p><strong>Czy zawiera otwór:</strong> @(ksztalt.CzyZawieraOtwor ? "Tak" : "Nie")</p>
                                    <p><strong>Widoczny:</strong> @(ksztalt.Widoczny ? "Tak" : "Nie")</p>
                                    <p><strong>Długość: @ksztalt.DlogoscElementu</strong></p>
                                    <p><strong>Wierzchołki:</strong></p>
                                    <ul class="list-group list-group-flush">
                                        @foreach (var p in ksztalt.Wierzcholki)
                                        {
                                            <li class="list-group-item">
                                                X: @p.X, Y: @p.Y
                                            </li>
                                        }
                                    </ul>
                                }
                         </div>
                        </div>
                    }

                    <hr>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.X, 3))"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@(Math.Round(punkt.Y, 3))"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @linia.X1, Y1: @linia.Y1), Koniec(X2: @linia.X2, Y2: @linia.Y2)
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@bbox.X, Y=@bbox.Y, Width=@bbox.Width, Height=@bbox.Height</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @(Math.Round(p.X, 3)), Y: @(Math.Round(p.Y, 3))
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @linia.X1, Y1: @linia.Y1), Koniec(X2: @linia.X2, Y2: @linia.Y2)
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@bbox.X, Y=@bbox.Y, Width=@bbox.Width, Height=@bbox.Height</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>
  
                }
                else
                {
                    <p class="text-muted">Brak danych do wyświetlenia 😔 nie wygenerowano okien</p>
                    <p style="color:red; font-size:14px;">Poniżej lista regionów, wymiary zewnętrzne @Szerokosc x @Wysokosc</p>
                    <Tabs>
                        <TabPane Tab="Ramy połączone">
                            @foreach (var region in _regionsDualRama)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @p.X, Y: @p.Y
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @linia.X1, Y1: @linia.Y1), Koniec(X2: @linia.X2, Y2: @linia.Y2)
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@bbox.X, Y=@bbox.Y, Width=@bbox.Width, Height=@bbox.Height</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                        <TabPane Tab="Podział skrzydeł">
                            @foreach (var region in _regionsSkrzydlo)
                            {
                                <div class="card mb-3">
                                    <div class="card-body">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="card-title">Region: @region.TypKsztaltu</h5>
                                            @if (edytowanyRegionId == region.Id)
                                            {
                                                <div>
                                                    <button class="btn btn-sm btn-success me-2" @onclick="ZapiszRegion">Zapisz</button>
                                                    <button class="btn btn-sm btn-secondary" @onclick="() => edytowanyRegionId = null">Anuluj</button>
                                                </div>
                                            }
                                            else
                                            {
                                                <button class="btn btn-sm btn-primary" @onclick="() => edytowanyRegionId = region.Id">Edytuj</button>
                                            }
                                        </div>

                                        <p><strong>ID:</strong> @region.Id</p>
                                        <p><strong>Liczba wierzchołków:</strong> @region.Wierzcholki.Count</p>
                                        <p><strong>Liczba linii dzielących:</strong> @region.LinieDzielace.Count</p>
                                        <p><strong>Typ podziału regionu:</strong> @region.TypLiniiDzielacej</p>

                                        <p><strong>Wierzchołki:</strong></p>
                                        @if (edytowanyRegionId == region.Id)
                                        {
                                            @for (int i = 0; i < region.Wierzcholki.Count; i++)
                                            {
                                                var punkt = region.Wierzcholki[i];
                                                var index = i;

                                                <div class="d-flex align-items-center mb-1" @key="punkt">
                                                    <span class="me-2">[@index]</span>
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.X"
                                                           @oninput="@(e => ZmienXRegion(region, index, e))" />
                                                    <input class="form-control me-1" style="width: 100px;" type="number"
                                                           step="0.01" value="@punkt.Y"
                                                           @oninput="@(e => ZmienYRegion(region, index, e))" />
                                                </div>
                                            }
                                        }
                                        else
                                        {
                                            <ul class="list-group list-group-flush">
                                                @foreach (var p in region.Wierzcholki)
                                                {
                                                    <li class="list-group-item">
                                                        X: @p.X, Y: @p.Y
                                                    </li>
                                                }
                                            </ul>
                                        }


                                        @* Linie dzielące *@
                                        @if (region.LinieDzielace.Any())
                                        {
                                            <p class="mt-3"><strong>Linie dzielące:</strong></p>
                                            <ul class="list-group list-group-flush">
                                                @foreach (var linia in region.LinieDzielace)
                                                {
                                                    <li class="list-group-item">
                                                        Start(X1: @linia.X1, Y1: @linia.Y1), Koniec(X2: @linia.X2, Y2: @linia.Y2)
                                                    </li>
                                                }
                                            </ul>
                                        }

                                        @* BoundingBox (opcjonalnie) *@
                                        @{
                                            var bbox = region.GetBoundingBox();
                                        }
                                        <p class="mt-3"><strong>BoundingBox:</strong> X=@bbox.X, Y=@bbox.Y, Width=@bbox.Width, Height=@bbox.Height</p>
                                    </div>
                                </div>
                            }

                        </TabPane>
                    </Tabs>
                }
            </div>
        </div>
    </div>
</div>


@code {
    // Klasa WingModel definiująca dane dla skrzydła
    private List<KonfSystem>? KonfiguracjeSystemu;

    private List<SystemyOkienne>? Systemy;

    private KonfModele? WybranyModel { get; set; }

    private string WybranyKsztalt = "prostokat";
    private int X = 0, Y = 0, Szerokosc = 1000, Wysokosc = 1000;
    private string Kolor = "#ff0000"; // Domyślny czerwony

    private string SelectedSystemId = "";
    private List<KonfModele>? ListaModeli;

    private BECanvasComponent? CanvasRef; // Referencja do komponentu BECanvas
    private Canvas2DContext? _context;
    private DotNetObjectReference<Modele_okienne>? _dotNetHelper;

    // Dodaj nowe pola w sekcji @code
    private string? SelectedModelType { get; set; }
    private string? SelectedRowIdType { get; set; }
    private double DropX { get; set; }
    private double DropY { get; set; }
    private ElementReference canvasElement;

    private double _currentScale = 1.0;
    private const double ScaleFactor = 1.1;
    private double _panX = 0;
    private double _panY = 0;

    private long CanvasWidth { get; set; } = 900;
    private long CanvasHeight { get; set; } = 600;

    private double _zoomCenterX = 450; // Środek canvasu
    private double _zoomCenterY = 300;

    private List<WyrobWymiaryOpis>? infoObiekt;

    private List<WygenerowaneMaterialy> infoBoom = new List<WygenerowaneMaterialy>();

    private List<IShapeDC> _shapes = new List<IShapeDC>();

    private List<ShapeRegion> _regionsDualRama = new();
    private List<ShapeRegion> _regionsSkrzydlo = new();

    private string woodPatternName = "sosna.jpg"; // Nazwa pliku do wzoru drewna meranti.jpg wood.jpg

    private bool hasCanvasError = false; // Nowa flaga do śledzenia błędów

    private string classShowTWZ = "";
    private string displayTWZ = "none";
    private string edytowanyId = "";

    private string edytowanyIdshape = "";

    private string mousePosition = "X: 0, Y: 0";

    private string? edytowanyRegionId;

    private Dictionary<string, List<KsztaltElementu>> _ksztaltyNaRegion = new();
    private List<KsztaltElementu> ksztalty = new();

    private Dictionary<string, GeneratorState> _generatorStates = new();

    protected override async Task OnInitializedAsync()
    {
        try
        {

            _shapes = ShapeService.Shapes;


            if (_shapes != null && _shapes.Count() > 0)
            {

                double maxWysokosc = _shapes.Max(s => s.Wysokosc);
                double maxSzerokosc = _shapes.Max(s => s.Szerokosc);

                if (maxWysokosc > 0 && maxSzerokosc > 0)
                {
                    Wysokosc = (int)maxWysokosc;
                    Szerokosc = (int)maxSzerokosc;
                }
                // 2. Oblicz skalę z zachowaniem proporcji tak, by dopasować do docelowych wymiarów
                double scaleX = Szerokosc / CanvasWidth;
                double scaleY = Wysokosc / CanvasHeight;
                double scale = Math.Min(scaleX, scaleY) / 2;

                scale = scale * 0.9;
                _currentScale = scale;

                Console.WriteLine($"🔍 OnInitializedAsync --> Przeskalowano kształty: skala={scale} CanvasWidth: {CanvasWidth} CanvasHeight: {CanvasHeight}");

                // Generuj regiony po transformacji
                //  _regions = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)CanvasWidth, (int)CanvasHeight);
                _regionsDualRama = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, true);
                _regionsSkrzydlo = GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, false);

                double minX = 0;
                double minY = 0;
                double maxX = Szerokosc;
                double maxY = Wysokosc;

                double contentWidth = maxX - minX;
                double contentHeight = maxY - minY;

                double canvasW = CanvasWidth;
                double canvasH = CanvasHeight;

                double margin = 20;
                scaleX = (canvasW - 2 * margin) / contentWidth;
                scaleY = (canvasH - 2 * margin) / contentHeight;

                double centerX = canvasW / 2;
                double centerY = canvasH / 2;

                double contentCenterX = (minX + maxX) / 2;
                double contentCenterY = (minY + maxY) / 2;

                _panX = centerX - contentCenterX * scale;
                _panY = centerY - contentCenterY * scale;

                await ApplyZoom(scale);

            }


            Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>("api/systemy-okienne");

            if (_dotNetHelper == null)
            {
                _dotNetHelper = DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
                Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");
            }

            // Sprawdź, czy skrypt JS został poprawnie załadowany
            var isScriptLoaded = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
            if (!isScriptLoaded)
            {
                throw new Exception("⚠️ Skrypt dragAndDrop.js nie został poprawnie załadowany!");

                // await JS.InvokeVoidAsync("AddCanvasHoverListener", CanvasRef);

            }

            if (_shapes != null)
            {
                Console.WriteLine($"Odebrano dane _shapes: {_shapes.Count()}");

                await RedrawCanvas();// to chyba poprawy!!!

                //   StateHasChanged();
            }
            else
            {
                Console.WriteLine($"Odebrano dane _shapes: null");
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas inicjalizacji: {ex.Message}");
        }

        await Laduj_Uprawnienia();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {

            if (firstRender && CanvasRef != null)
            {
                Console.WriteLine("🖌️ Inicjalizacja canvasu...");

                var isFunctionDefined = await JS.InvokeAsync<bool>("eval", "typeof setCanvasRef === 'function'");
                if (!isFunctionDefined)
                    throw new Exception("⚠️ Funkcja setCanvasRef nie jest zdefiniowana!");

                await JS.InvokeVoidAsync("setCanvasRef", CanvasRef.CanvasReference);
                Console.WriteLine("✅ Canvas ustawiony!");

                // 👇 TU DODAJ
                _context ??= await CanvasRef.CreateCanvas2DAsync();

                await JS.InvokeVoidAsync("registerResizeCallback", DotNetObjectReference.Create(this));

                // // Możesz od razu wywołać rysowanie
                // if (_shapes?.Any() == true)
                //     await RedrawCanvas();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Krytyczny błąd: {ex.Message}");
            hasCanvasError = true;
            StateHasChanged();
        }
    }


    private void WybierzModel(KonfModele model)
    {
        WybranyModel = model;
        // Dodatkowe akcje przy wyborze modelu
        JS.InvokeVoidAsync("SetCustomCursor", Convert.ToBase64String(model.Ikona32x32));
        JS.InvokeVoidAsync("SetCurrentModel", model.Typ, model.RowId);
    }

    private void ZmienX(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienX wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newX))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.X = newX;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienX: indeks {index}, nowa wartość X: {newX}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienX: {ex.Message}");
        }
    }

    private void ZmienY(KsztaltElementu ksztalt, int index, ChangeEventArgs e)
    {
        try
        {
            Console.WriteLine($"➡️ ZmienY wywołane. index: {index} e.Value: '{e.Value}'");

            if (ksztalt == null || ksztalt.Wierzcholki == null || index < 0 || index >= ksztalt.Wierzcholki.Count)
            {
                Console.WriteLine("❌ Nieprawidłowe dane wejściowe");
                return;
            }

            var stringValue = e.Value?.ToString()?.Replace(",", ".");
            if (float.TryParse(stringValue, NumberStyles.Any, CultureInfo.InvariantCulture, out var newY))
            {
                var punkt = ksztalt.Wierzcholki[index];
                punkt.Y = newY;
                ksztalt.Wierzcholki[index] = punkt;
                Console.WriteLine($"✅ ZmienY: indeks {index}, nowa wartość Y: {newY}");
            }
            else
            {
                Console.WriteLine($"⚠️ Nie można sparsować: {stringValue}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ZmienY: {ex.Message}");
        }
    }


    private async Task EdytujKsztalt(string id)
    {
        // Zwalniamy poprzednią instancję
        if (_dotNetHelper != null)
        {
            _dotNetHelper.Dispose();
            await JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper = null;
        }

        // Tworzymy nową i ustawiamy ją w JS
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("setDotNetHelper", _dotNetHelper);
        Console.WriteLine($"🆕 DotNetObjectReference.Create(this) dla obiektu {this.GetHashCode()}");

        edytowanyId = id;
        Console.WriteLine($"edytowanyId: {edytowanyId}");
    }

    private async Task ZapiszKsztalt()
    {
        // Nie zmieniaj listy ksztalty – dane są już w niej zaktualizowane przez binding
        edytowanyId = "";
        await RenderFrame(false);
    }


    private void AnulujEdycje()
    {
        edytowanyId = "";
    }

    private void ZmienXRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var x))
        {
            var punkt = region.Wierzcholki[index];
            punkt.X = x;// / _currentScale;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private void ZmienYRegion(ShapeRegion region, int index, ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var y))
        {
            var punkt = region.Wierzcholki[index];
            punkt.Y = y;
            region.Wierzcholki[index] = punkt; // ✅ Zapisz zmodyfikowany punkt z powrotem
        }
    }

    private async Task ZapiszRegion()
    {
        edytowanyRegionId = null;
        await RedrawCanvas();
        //StateHasChanged(); // aby odświeżyć widok
    }


    private void ZamknijModal()
    {
        classShowTWZ = "";
        displayTWZ = "none";
    }

    public void PokazModal()
    {
        classShowTWZ = "show";
        displayTWZ = "block";
    }

    [JSInvokable("UpdateCanvasSizeFromResize")]
    public async Task UpdateCanvasSizeFromResize()
    {
        await ApplyZoom(_currentScale);
    }

    private async Task RedrawCanvas()
    {
        if (_context == null)
        {
            Console.WriteLine("❌ Brak kontekstu canvas!");
            return;
        }

        // Najpierw wyczyść canvas o rozmiarze docelowym
        await ClearCanvas();

        await _context.SaveAsync();

        // Skaluj kontekst według aktualnej skali
        await _context.ScaleAsync(_currentScale, _currentScale);

        Console.WriteLine($"🎨 Rysowanie {_shapes.Count} kształtów ---> RedrawCanvas");

        // Rysuj wszystkie kształty w przeskalowanym kontekście
        foreach (var shape in _shapes)
        {
            Console.WriteLine($"🖌️ Rysuję {shape.GetType().Name}");
            await shape.Draw(_context);
        }

        Console.WriteLine("Rozpoczynam przekazywanie danych z _shapes do GenerujRegionyZPodzialu");

        await _context.RestoreAsync();
    }

    private async Task ClearCanvas()
    {
        if(_context == null)
        {
            Console.WriteLine("❌ ClearCanvas --> Brak kontekstu canvas!");
            return;
        }
        await _context.SetFillStyleAsync("white");
        await _context.FillRectAsync(0, 0, CanvasWidth, CanvasHeight);

        //_currentScale = 1.0; // Reset skali
    }

    private async Task ZoomIn()
    {
        var newScale = _currentScale * 1.2;
        await ApplyZoom(newScale);
    }

    private async Task ZoomOut()
    {
        var newScale = _currentScale / 1.2;
        await ApplyZoom(Math.Max(newScale, 0.12));
    }

    private async Task ApplyZoom(double newScale)
    {
        if (CanvasWidth == 0 || CanvasHeight == 0)
            return;

        // 📌 Środek canvasu jako punkt odniesienia do zoomu
        _zoomCenterX = CanvasWidth / 2.0;
        _zoomCenterY = CanvasHeight / 2.0;

        Console.WriteLine($"🔍 ZOOM: nowa skala = {newScale:F2}, aktualna skala = {_currentScale:F2}");

        var ratio = 1 - (newScale / _currentScale);
        _panX += (_zoomCenterX - _panX) * ratio;
        _panY += (_zoomCenterY - _panY) * ratio;

        _currentScale = newScale;

        isTextureLoaded = false;

        await RedrawCanvas();
        await DrawStructureAndRestrykcje();
        await RenderFrame();

        // Rysuj wszystkie kształty w przeskalowanym kontekście
        if (_context != null && _shapes != null)
        {
            foreach (var shape in _shapes)
            {
                await shape.Draw(_context);
            }
        }

    }

    private async Task FitToCanvas(IShapeDC targetShape, string idRegion, bool skalaAutomatyczna)
    {

        Console.WriteLine($"🔍 FitToCanvas --> Dopasowano do shape: scale={_currentScale:F2}, panX={_panX:F2}, panY={_panY:F2}");

        isTextureLoaded = false;

        await DrawStructureAndRestrykcje(0);

        await DodajWybranyKwadratOkna(idRegion); // teraz z idRegion

        // await UpdateCanvasSizeFromDiv();
        await RenderFrame();

    }

    private async Task MouseMove(MouseEventArgs e)
    {
        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);
        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na przestrzeń logiczną
        double logicalX = relativeX / _currentScale;
        double logicalY = relativeY / _currentScale;

        mousePosition = $"X: {logicalX:F2}, Y: {logicalY:F2}";
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_context == null) return;

        if (CanvasRef == null)
        {
            Console.WriteLine("⚠️ Brak referencji do canvasu!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            await _message.Warning("Wybierz system okienny przed przeciągnięciem modelu.", 1.5);
            return;
        }

        if (WybranyModel == null)
        {
            await _message.Warning("Wybierz model z listy przed przeciągnięciem.", 1.0);
            return;
        }

        Console.WriteLine($"🖱️ DropX: {DropX}, DropY: {DropY}");
        Console.WriteLine($"🔧 PanX: {_panX}, PanY: {_panY}, Scale: {_currentScale}");
        Console.WriteLine($"📌 Pozycja w modelu: X={(DropX - _panX) / _currentScale}, Y={(DropY - _panY) / _currentScale}");


        // Pobierz informacje o przeciąganym modelu
        var draggedInfo = await GetDraggedModelInfoAsync();
        if (draggedInfo != null && !string.IsNullOrEmpty(draggedInfo.Type))
        {
            SelectedModelType = draggedInfo.Type;
            SelectedRowIdType = draggedInfo.RowId;
        }

        var rect = await JS.InvokeAsync<DOMRect>("getCanvasBoundingRect", CanvasRef.CanvasReference);
        double relativeX = e.ClientX - rect.Left;
        double relativeY = e.ClientY - rect.Top;

        // Przeliczenie na przestrzeń logiczną
        double modelX = relativeX / _currentScale;
        double modelY = relativeY / _currentScale;

        // Przelicz współrzędne na przestrzeń logiczną (z uwzględnieniem skali i przesunięcia)
        // double modelX = (DropX - _panX) / _currentScale;
        // double modelY = (DropY - _panY) / _currentScale;

        bool tylkoRama = false;

        if (SelectedModelType == "Rama") tylkoRama = true;

        // 🔍 Znajdź region, w który kliknięto
        var region = FindRegionAtPosition(modelX, modelY, tylkoRama);

        if (region == null)
        {
            await _message.Warning($"❌ Nie znaleziono regionu dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🔍 Znajdź shape wewnątrz regionu
        var shape = _shapes.FirstOrDefault(s =>
        {
            var bbox = s.GetBoundingBox();
            var testPoints = new[]
            {
            new XPoint(bbox.X, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y),
            new XPoint(bbox.X + bbox.Width, bbox.Y + bbox.Height),
            new XPoint(bbox.X, bbox.Y + bbox.Height),
            new XPoint(bbox.X + bbox.Width / 2, bbox.Y + bbox.Height / 2)
            };

            return testPoints.Any(p => IsPointInPolygon(region.Wierzcholki, p.X, p.Y));
        });

        if (shape == null)
        {
            await _message.Warning($"❌ Nie znaleziono kształtu w regionie {region.Id} dla pozycji (X: {modelX:F2}, Y: {modelY:F2})", 1.5);
            return;
        }

        // 🎯 Dopasuj widok do kształtu i regionu
        await FitToCanvas(shape, region.Id, false);

        foreach (var shapeX in _shapes)
        {
            Console.WriteLine($"🖌️ Rysuję {shapeX.GetType().Name}");
            await shapeX.Draw(_context);
        }

        // Resetuj kursor JS
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        WybranyModel = null;
    }

    private ShapeRegion? FindRegionAtPosition(double x, double y, bool tylkoRama)
    {
        Console.WriteLine($"🔍 Szukam regionu w pozycji (model): X={x:F2}, Y={y:F2}");

        if (_regionsDualRama == null || !_regionsDualRama.Any() || _regionsSkrzydlo == null || !_regionsSkrzydlo.Any())
        {
            Console.WriteLine("❌ Brak regionów do sprawdzenia!");
            return null;
        }

        if (tylkoRama)
        {
            foreach (var region in _regionsDualRama)
            {
                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region DualRama {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }
        else
        {
            foreach (var region in _regionsSkrzydlo)
            {
                if (region.Wierzcholki.Count >= 3)
                {
                    if (IsPointInPolygon(region.Wierzcholki, x, y))
                    {
                        Console.WriteLine($"✅ Trafiono w region: {region.Id} - Typ: {region.TypKsztaltu}");
                        return region;
                    }
                }
                else
                {
                    Console.WriteLine($"⚠️ Region Skrzydło {region.Id} pominięty - za mało wierzchołków: {region.Wierzcholki.Count}");
                }
            }
        }

        Console.WriteLine("❌ Żaden region nie zawiera podanego punktu.");
        return null;
    }

    private bool IsPointInPolygon(List<XPoint> polygon, double x, double y)
    {
        bool inside = false;
        int n = polygon.Count;

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            var xi = polygon[i].X;
            var yi = polygon[i].Y;
            var xj = polygon[j].X;
            var yj = polygon[j].Y;

            bool intersect = ((yi > y) != (yj > y)) &&
                             (x < (xj - xi) * (y - yi) / (yj - yi + 0.00001) + xi); // +epsilon by uniknąć dzielenia przez 0

            if (intersect)
                inside = !inside;
        }

        return inside;
    }

    private async Task OnlyRestrykcje()
    {

        if (!string.IsNullOrEmpty(SelectedModelType))
        {

            if (ListaModeli != null)
            {
                Console.WriteLine($"OnlyRestrykcje - Typ --> SelectedModelType: {SelectedModelType}");

                var _ListaModeliResrykcje = ListaModeli.FirstOrDefault(x => x.Typ == SelectedModelType);

                if (_ListaModeliResrykcje != null)
                {
                    infoObiekt = new List<WyrobWymiaryOpis>();

                    string restrykcje = "Brak restrykcji :)";

                    if (_ListaModeliResrykcje.KonstrMinSzer > Szerokosc)
                    {
                        restrykcje = "<#SYS> Konstrukcja nie spełnia warunku MIN szerokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMinWys > Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MAX wysokości. ";
                    }
                    if (_ListaModeliResrykcje.KonstrMaxWys < Wysokosc)
                    {
                        restrykcje += "<#SYS> Konstrukcja nie spełnia warunku MIN wysokości. ";
                    }

                    // ✅ Poprawione: Utwórz nowy obiekt przed ustawieniem właściwości
                    WyrobWymiaryOpis opisy = new WyrobWymiaryOpis(Szerokosc, Wysokosc, SelectedModelType, restrykcje);

                    infoObiekt.Add(opisy);

                    if (KonfiguracjeSystemu != null)
                    {
                        var _KonfiguracjeSystemu = KonfiguracjeSystemu.OrderBy(x => x.Indeks);

                        if (_KonfiguracjeSystemu != null)
                        {
                            foreach (var _kon in _KonfiguracjeSystemu)
                            {
                                WygenerowaneMaterialy opisySys = new WygenerowaneMaterialy(
                                 _kon.PoziomDol ?? 0.0,
                                 _kon.Nazwa ?? "",
                                 _kon.Indeks ?? "",
                                 1,
                                 ""
                                 );

                                infoBoom.Add(opisySys);
                            }


                        }

                    }


                }

            }
        }

        await Task.CompletedTask;
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();

        Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");

        if (string.IsNullOrEmpty(SelectedSystemId))
        {

            if (KonfiguracjeSystemu != null) KonfiguracjeSystemu.Clear();
            return;
        }

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIN_DROWID/{SelectedSystemId}");

        ListaModeli = await Http.GetFromJsonAsync<List<KonfModele>>($"api/konfmodele/FIND_ONLY_TRUE/{SelectedSystemId}");

    }

    private bool isTextureLoaded = false;

    private async Task DrawStructureAndRestrykcje(int isTextureLoadedNZ = 999)
    {
        if (isTextureLoadedNZ == 0) isTextureLoaded = false;

        try
        {
            if (CanvasRef == null)
            {
                Console.WriteLine("⚠️ Brak referencji do canvasu!");
                return;
            }

            _context ??= await CanvasRef.CreateCanvas2DAsync();

            if (!isTextureLoaded)
            {
                // var baseUrl = Navigation.BaseUri;
                // var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

                // await JS.InvokeVoidAsync("loadAndDrawTexture",
                //     CanvasRef.CanvasReference,
                //     imageUrl,
                //     _dotNetHelper
                // );

                await OnlyRestrykcje();

                // StateHasChanged();
                // return;
            }

            //await RenderFrame();

            // Reszta kodu do rysowania...
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas rysowania: {ex.Message}");
        }
    }

    public async Task<DraggedModelInfo> GetDraggedModelInfoAsync()
    {
        try
        {
            var info = await JS.InvokeAsync<DraggedModelInfo>("getDraggedModelInfo");
            await JS.InvokeVoidAsync("clearCurrentModel"); // Opcjonalne czyszczenie po odczycie
            return info;
        }
        catch (JSException ex)
        {
            Console.WriteLine($"Błąd pobierania informacji o modelu: {ex.Message}");
            return null;
        }
    }

    [JSInvokable]
    public async Task OnDragError(string message)
    {
        await _message.Error(message);
        StateHasChanged();
    }

    public void Dispose()
    {
        try
        {
            //JS.InvokeVoidAsync("clearDotNetHelper");
            _dotNetHelper?.Dispose();
            _dotNetHelper = null;
            Console.WriteLine($"🧹 Dispose wywołany. Obiekt: {this.GetHashCode()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd Dispose: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("clearDotNetHelper");
        _dotNetHelper?.Dispose();
        _dotNetHelper = null;
        Console.WriteLine($"🧹 AsyncDispose wywołany. Obiekt: {this.GetHashCode()}");
    }


    [JSInvokable]
    public async Task OnTextureLoaded()
    {
        try
        {
            isTextureLoaded = true;
            Console.WriteLine("✅ Tekstura załadowana!");
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"🔥 Błąd podczas ładowania tekstury: {ex.Message}");
        }
    }

    private async Task ZmienWymiaryOkna()
    {
        if (_shapes == null || !_shapes.Any())
        {
            Console.WriteLine("❌ Brak kształtów do przeskalowania!");
            return;
        }

        // 1. Oblicz bounding box całego modelu
        double minX = double.MaxValue, minY = double.MaxValue;
        double maxX = double.MinValue, maxY = double.MinValue;

        foreach (var shape in _shapes)
        {
            var bbox = shape.GetBoundingBox();
            minX = Math.Min(minX, bbox.X);
            minY = Math.Min(minY, bbox.Y);
            maxX = Math.Max(maxX, bbox.X + bbox.Width);
            maxY = Math.Max(maxY, bbox.Y + bbox.Height);
        }

        double modelWidth = maxX - minX;
        double modelHeight = maxY - minY;

        if (modelWidth <= 0 || modelHeight <= 0)
        {
            Console.WriteLine("❌ Nieprawidłowe wymiary modelu.");
            return;
        }

        // 2. Oblicz skalę dopasowaną do rozmiaru canvasu
        double canvasW = CanvasWidth;
        double canvasH = CanvasHeight;
        double margin = 20;
        double scaleX = (canvasW - margin * 2) / modelWidth;
        double scaleY = (canvasH - margin * 2) / modelHeight;
        double newScale = Math.Min(scaleX, scaleY);

        _currentScale = newScale * 0.8;

        // 3. Wycentruj model na canvasie
        double modelCenterX = ((minX + maxX) / 2) * _currentScale;
        double modelCenterY = ((minY + maxY) / 2) * _currentScale;
        _panX = (canvasW / 2) - modelCenterX;
        _panY = (canvasH / 2) - modelCenterY;

        Console.WriteLine($"🔍 Zmieniono wymiary: skalowanie={_currentScale:F2}, panX={_panX:F2}, panY={_panY:F2}");

        // 4. Przeskaluj regiony (jeśli potrzebujesz dostosować ich szerokość i wysokość)
        _regionsDualRama = GeometryUtils.SkalujRegiony(_regionsDualRama, (int)Szerokosc, (int)Wysokosc);
        _regionsSkrzydlo = GeometryUtils.SkalujRegiony(_regionsSkrzydlo, (int)Szerokosc, (int)Wysokosc);

        GeometryUtils.GenerujRegionyZPodzialu(_shapes, (int)Szerokosc, (int)Wysokosc, true);

        // 5. Normalizacja wygenerowanych elementów w regionach
        foreach (var region in _regionsDualRama)
        {
            await NormalizeGeneratedElements(region, Szerokosc, Wysokosc);
        }

        foreach (var region in _regionsSkrzydlo)
        {
            await NormalizeGeneratedElements(region, Szerokosc, Wysokosc);
        }


        await ApplyZoom(_currentScale);
    }


    private async Task NormalizeGeneratedElements(ShapeRegion region, float nowaSzerokosc, float nowaWysokosc)
    {
        if (region == null || string.IsNullOrEmpty(region.Id))
        {
            Console.WriteLine("⚠️ Nieprawidłowy region.");
            return;
        }

        if (!_ksztaltyNaRegion.TryGetValue(region.Id, out var ksztaltyRegionu) || ksztaltyRegionu == null || ksztaltyRegionu.Count == 0)
        {
            Console.WriteLine($"⚠️ Brak wygenerowanych kształtów dla regionu {region.Id}.");
            return;
        }

        var regionPoints = region.Wierzcholki;
        if (regionPoints == null || regionPoints.Count < 3)
        {
            Console.WriteLine($"⚠️ Region {region.Id} ma za mało punktów.");
            return;
        }
        await GenerujElementyDlaRegionu(region.Id, nowaSzerokosc, nowaWysokosc);

        await Task.CompletedTask;
    }


    private async Task DodajWybranyKwadratOkna(string idRegion)
    {
        if (SelectedModelType == null || string.IsNullOrEmpty(SelectedModelType))
        {
            Console.WriteLine("❌ SelectedModelType jest puste, nie można kontynuować.");
            return;
        }

        Console.WriteLine($"📦 -> DodajWybranyKwadratOkna wywołane z idRegion: {idRegion} SelectedRowIdType: {SelectedRowIdType}");

        var generator = new Generator
        {
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82
        };

        if (KonfiguracjeSystemu != null)
        {
            generator.KonfiguracjeSystemu = KonfiguracjeSystemu;
            generator.RowIdSystemu = Guid.Parse(SelectedSystemId);

            if (Guid.TryParse(SelectedRowIdType, out var rowIdModeluSzukaj))
            {
                generator.RowIdModelu = rowIdModeluSzukaj;

                var powiazanyModel = await Http.GetFromJsonAsync<MVCKonfModele>($"api/konfmodeleelementy/powiazaniajuzzaznaczone/{SelectedRowIdType}");
                if (powiazanyModel != null)
                {
                    generator.PowiazanyModel = powiazanyModel;
                }
            }
        }
        else
        {
            if (string.IsNullOrEmpty(SelectedSystemId))
            {
                Console.WriteLine("❌ KonfiguracjeSystemu jest puste, nie można kontynuować.");
                return;
            }

            var kofiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>($"api/konfsystem/FIN_DROWID/{SelectedSystemId}");
            generator.KonfiguracjeSystemu = kofiguracjeSystemu;
            Console.WriteLine("---------> Ponownie pobrano kofiguracjeSystemu.");
        }

        generator.EdytowanyModel = WybranyModel;
        generator.TypKsztaltu = WybranyKsztalt;

        //--------------------------------------------------------------------------------------------------------------------------------

        double minX = 0;
        double maxX = 0;
        double minY = 0;
        double maxY = 0;


        Console.WriteLine($"📐📐📐 SelectedModelType  = {SelectedModelType} 📐📐📐");

        if(SelectedModelType.Trim() == "Rama")
        {
            var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionDualRama != null)
            {
                var regionPoints = wybranyRegionDualRama.Wierzcholki;
                if (regionPoints == null || regionPoints.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return;
                }

                // 1. Bounding box regionu
                minX = regionPoints.Min(p => p.X);
                maxX = regionPoints.Max(p => p.X);
                minY = regionPoints.Min(p => p.Y);
                maxY = regionPoints.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                generator.Zindesk = 0; // Ustawienie indeksowania dla ramy

                Console.WriteLine($"📐📐📐 Region Zindeks = 0 ID: {wybranyRegionDualRama.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc}");

                generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion);
            }
        }

        //--------------------------------------------------------------------------------------------------------------------------------

        if (SelectedModelType.Trim() == "Skrzydło" || SelectedModelType.Trim() == "Skrzydło z słupkiem ruchomym")
        {
            var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

            if (wybranyRegionSkrzydlo != null)
            {
                var regionPointsSkrzydlo = wybranyRegionSkrzydlo.Wierzcholki;
                if (regionPointsSkrzydlo == null || regionPointsSkrzydlo.Count < 3)
                {
                    Console.WriteLine("❌ Wybrany region nie zawiera wystarczającej liczby punktów!");
                    return;
                }

                // 1. Bounding box regionu
                minX = regionPointsSkrzydlo.Min(p => p.X);
                maxX = regionPointsSkrzydlo.Max(p => p.X);
                minY = regionPointsSkrzydlo.Min(p => p.Y);
                maxY = regionPointsSkrzydlo.Max(p => p.Y);

                generator.Szerokosc = (float)(maxX - minX);
                generator.Wysokosc = (float)(maxY - minY);
                if (SelectedModelType == "Skrzydło z słupkiem ruchomym")
                {
                    generator.Zindesk = 1; // Ustawienie indeksowania dla skrzydła
                }
                else
                {
                    generator.Zindesk = 2; // Ustawienie indeksowania dla skrzydła
                }

                Console.WriteLine($"📐📐📐 Region Zindeks = {generator.Zindesk} ID: {wybranyRegionSkrzydlo.Id} -> Szerokość: {generator.Szerokosc}, Wysokość: {generator.Wysokosc}");

                generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion);
            }
            else
            {
                Console.WriteLine($"📐📐📐 wybranyRegionSkrzydlo == null");
            }
        }

        //--------------------------------------------------------------------------------------------------------------------------------

        Console.WriteLine($"✅ ElementyRamyRysowane.Count: {generator.ElementyRamyRysowane.Count}");

        if(generator.ElementyRamyRysowane == null || generator.ElementyRamyRysowane.Count == 0)
        {
            Console.WriteLine("❌ Brak elementów do rysowania!");
            return;
        }

        // 2. Oblicz bounding box wygenerowanych kształtów
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        // 3. Skalowanie z zachowaniem proporcji
        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        // 4. Przesunięcie tak, aby dopasować obiekt do regionu
        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        // 5. Transformacja punktów
        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }
            }
        }

        // 6. Zapis do słownika i aktualizacja listy
        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

       // 7. Debug info
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"💡 ------ Liczba wygenerowanych kształtów: {ksztalty.Count}");

        for (int i = 0; i < ksztalty.Count; i++)
        {
            var ksztalt = ksztalty[i];
            sb.AppendLine($"Kształt {i + 1}:");
            sb.AppendLine($"- Typ: {ksztalt.TypKsztaltu}");
            sb.AppendLine($"- Grupa: {ksztalt.Grupa}");
            sb.AppendLine($"- Wypełnienie zewnętrzne: {ksztalt.WypelnienieZewnetrzne}");
            sb.AppendLine($"- Wypełnienie wewnętrzne: {ksztalt.WypelnienieWewnetrzne}");
            sb.AppendLine($"- Liczba punktów: {ksztalt.Wierzcholki?.Count ?? 0}");

            ksztalt.DlogoscElementu = (float)generator.DlugoscElementu(ksztalt.Wierzcholki);

            ksztalt.IdRegion = idRegion;

            if (ksztalt.Wierzcholki != null)
            {
                sb.AppendLine("  Punkty:");
                foreach (var punkt in ksztalt.Wierzcholki)
                {
                    sb.AppendLine($"  - X: {punkt.X}, Y: {punkt.Y}");
                }
            }
        }

        Console.WriteLine(sb.ToString());

        var state = new GeneratorState
        {
            KonfiguracjeSystemu = KonfiguracjeSystemu,
            RowIdSystemu = Guid.Parse(SelectedSystemId),
            RowIdModelu = Guid.TryParse(SelectedRowIdType, out var rowIdModelu) ? rowIdModelu : (Guid?)null,
            PowiazanyModel = generator.PowiazanyModel,
            WybranyModel = WybranyModel,
            WybranyKsztalt = WybranyKsztalt,
            GruboscDol = 82,
            GruboscGora = 82,
            GruboscLewo = 82,
            GruboscPrawo = 82,
        };

        ZapiszStanGeneratora(idRegion, state);

    }

    private void ZapiszStanGeneratora(string idRegion, GeneratorState state)
    {
        _generatorStates[idRegion] = state;
    }

    private async Task GenerujElementyDlaRegionu(string idRegion, float szerokosc, float wysokosc)
    {
        if (!_generatorStates.TryGetValue(idRegion, out var state))
        {
            Console.WriteLine($"❌ Brak stanu generatora dla regionu {idRegion}");
            return;
        }

        var generator = new Generator
        {
            KonfiguracjeSystemu = state.KonfiguracjeSystemu,
            RowIdSystemu = state.RowIdSystemu,
           // RowIdModelu = state.RowIdModelu,
            PowiazanyModel = state.PowiazanyModel,
            EdytowanyModel = state.WybranyModel,
            TypKsztaltu = state.WybranyKsztalt,
            GruboscDol = state.GruboscDol,
            GruboscGora = state.GruboscGora,
            GruboscLewo = state.GruboscLewo,
            GruboscPrawo = state.GruboscPrawo,
        };

        var wybranyRegionDualRama = _regionsDualRama.FirstOrDefault(r => r.Id == idRegion);
        var wybranyRegionSkrzydlo = _regionsSkrzydlo.FirstOrDefault(r => r.Id == idRegion);

        double minX = 0, maxX = 0, minY = 0, maxY = 0;

        if (wybranyRegionDualRama != null)
        {
            var regionPoints = wybranyRegionDualRama.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindesk = 0;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionDualRama }, idRegion);
        }
        else if (wybranyRegionSkrzydlo != null)
        {
            var regionPoints = wybranyRegionSkrzydlo.Wierzcholki;
            if (regionPoints == null || regionPoints.Count < 3) return;

            minX = regionPoints.Min(p => p.X);
            maxX = regionPoints.Max(p => p.X);
            minY = regionPoints.Min(p => p.Y);
            maxY = regionPoints.Max(p => p.Y);

            generator.Szerokosc = (float)(maxX - minX);
            generator.Wysokosc = (float)(maxY - minY);
            generator.Zindesk = 1;

            generator.AddElements(new List<ShapeRegion> { wybranyRegionSkrzydlo }, idRegion);
        }
        else
        {
            Console.WriteLine($"❌ Nie znaleziono regionu o ID {idRegion}");
            return;
        }

        // Skalowanie i przesunięcie jeśli zmieniasz szerokość/wysokość
        double shapeMinX = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.X));
        double shapeMaxX = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.X));
        double shapeMinY = generator.ElementyRamyRysowane.Min(e => e.Wierzcholki.Min(p => p.Y));
        double shapeMaxY = generator.ElementyRamyRysowane.Max(e => e.Wierzcholki.Max(p => p.Y));

        double shapeWidth = shapeMaxX - shapeMinX;
        double shapeHeight = shapeMaxY - shapeMinY;
        double regionWidth = maxX - minX;
        double regionHeight = maxY - minY;

        double scale = Math.Min(regionWidth / shapeWidth, regionHeight / shapeHeight);

        double offsetX = minX - shapeMinX * scale;
        double offsetY = minY - shapeMinY * scale;

        foreach (var ksztalt in generator.ElementyRamyRysowane)
        {
            if (ksztalt.Wierzcholki != null)
            {
                for (int i = 0; i < ksztalt.Wierzcholki.Count; i++)
                {
                    var p = ksztalt.Wierzcholki[i];
                    ksztalt.Wierzcholki[i] = new XPoint(
                        p.X * scale + offsetX,
                        p.Y * scale + offsetY
                    );
                }
            }
        }

        _ksztaltyNaRegion[idRegion] = new List<KsztaltElementu>(generator.ElementyRamyRysowane);
        ksztalty = _ksztaltyNaRegion.Values.SelectMany(k => k).ToList();

        Console.WriteLine($"✅ Wygenerowano elementy dla regionu {idRegion} po skalowaniu.");

        await Task.CompletedTask;
    }

    
    private async Task RenderFrame(bool calculate = true)
    {

        try
        {
            if (_context == null || ksztalty == null || !ksztalty.Any())
                return;

            // Przygotowanie canvas
            await _context.SetTransformAsync(1, 0, 0, 1, 0, 0);
            await _context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);
            //await _context.TranslateAsync(_panX, _panY);
             await _context.ScaleAsync(_currentScale, _currentScale);

            // Przygotowanie tekstury
            var baseUrl = Navigation.BaseUri;
            var imageUrl = $"{baseUrl}api/images/{woodPatternName}";

            // Rysowanie każdego kształtu
            foreach (var ksztalt in ksztalty)
            {
                Console.WriteLine($"Rysuję kształt: {ksztalt.TypKsztaltu}");
                if (ksztalt.Wierzcholki == null || ksztalt.Wierzcholki.Count < 3)
                    continue;
                Console.WriteLine($"*********** >>>>>> ksztalt: {ksztalt.Id}");

                await DrawShapeWithVariableOffset(_context, ksztalt, imageUrl, calculate);
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Błąd renderowania: {ex.Message}\n{ex.StackTrace}");
        }
    }

    private async Task DrawShapeWithVariableOffset(Canvas2DContext context, KsztaltElementu ksztalt, string textureUrl, bool calculate)
    {
        var outerPoints = ksztalt.Wierzcholki;

        Console.WriteLine($"outerPoints: {outerPoints.Count}");

        var offsets = GetOffsetsForGroup(ksztalt.Grupa);

        await DrawSingleContour(context, outerPoints);

        // await DrawDoubleContour(context, outerPoints, innerPoints);
        if (_dotNetHelper != null)
       {
            await JS.InvokeVoidAsync("loadAndDrawTexture",
                CanvasRef.CanvasReference,
                textureUrl,
                _dotNetHelper
            ); 
       }


        await context.SetStrokeStyleAsync("#000000");
        await context.SetLineWidthAsync(1.5f);
        await context.StrokeAsync();
    }


    private (float left, float right, float top, float bottom) GetOffsetsForGroup(string grupa)
    {
        // Domyślne wartości (można dostosować)
        float grLewo = 82;
        float grPrawo = 82;
        float grGora = 82;
        float grDol = 92;

        return grupa switch
        {
            "Lewo" => (grLewo, 0, 0, 0),
            "Prawo" => (0, grPrawo, 0, 0),
            "Gora" => (0, 0, grGora, 0),
            "Dol" => (0, 0, 0, grDol),
            _ => (grLewo, grPrawo, grGora, grDol) // Domyślne dla innych przypadków
        };
    }

    private async Task DrawSingleContour(Canvas2DContext context, List<XPoint> outerPoints)
    {
        if (outerPoints == null || outerPoints.Count < 2) return;

        // Rysuj pojedynczy kontur zewnętrzny
        await context.BeginPathAsync();

        // Rozpocznij od pierwszego punktu
        await context.MoveToAsync(outerPoints[0].X, outerPoints[0].Y);

        // Rysuj linie do kolejnych punktów
        for (int i = 1; i < outerPoints.Count; i++)
        {
            await context.LineToAsync(outerPoints[i].X, outerPoints[i].Y);
        }

        // Zamknij kształt
        await context.ClosePathAsync();

        // Opcjonalne stylowanie
        await context.SetStrokeStyleAsync("black");
        await context.SetLineWidthAsync(2);
        await context.StrokeAsync();
    }

    private async Task GoBack()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task GoCAD()
    {
        await JS.InvokeVoidAsync("ResetCursorGlobal");

        NavigationManager.NavigateTo($"/DrawCAD");

        await Task.CompletedTask;
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "SystemyOkienne";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId ?? "??????";
                    }
                }
            }
        }
    }

    public class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }

    private class PointClassification
    {
        public bool IsLeft { get; set; }
        public bool IsRight { get; set; }
        public bool IsTop { get; set; }
        public bool IsBottom { get; set; }
    }

    public class DraggedModelInfo
    {
        public string? Type { get; set; }
        public string? RowId { get; set; }
    }

    private class DomSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

}