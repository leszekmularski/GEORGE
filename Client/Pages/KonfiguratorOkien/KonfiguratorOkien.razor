@page "/KonfiguratorOkien"
@using GEORGE.Shared.Models
@using GEORGE.Shared.Class
@inject HttpClient Http
@using AntDesign
@inject IMessageService _message
@inject INotificationService _notice
@inject Utilities.ILocalStorage LocalStorage
@using System.Net
@using System.Xml
@using System.Text.Json
@using System.Text.RegularExpressions
@using System.Globalization
@inject IJSRuntime JSRuntime
@inject DxfService DxfService
@inject DxfToSvgConverter Converter
@inject NavigationManager NavigationManager
@inject AntDesign.ModalService _modalService

<style>
    .scaled-svg {
    position: relative;
    width: 505px;
    height: 505px;
    overflow: auto;
    border: 1px solid #ccc;
    }

    svg {
    width: 100%;
    height: 100%;
    transform-origin: center; /* 🔥 Kluczowe dla poprawnego zoomu */
    transition: transform 0.2s ease-in-out; /* 🔄 Płynna animacja */
    }

    #guide-line-vertical, #guide-line-horizontal, #guide-line-verticalMax, #guide-line-horizontalMax {
    pointer-events: auto;
    opacity: 1;
    z-index: 10; /* Przesunięcie na wierzch */
    }

    line {
    cursor: pointer; /* Zmieniaj kursor przy interakcji */
    }

</style>

<script>

    let isDraggingOKN = false;
    let draggedLine = null;
    let offsetX = 0; // 🔥 Przechowuje różnicę między kliknięciem a aktualnym X
    let deleteMode = false; // 🔥 Tryb usuwania

    // 🔥 Nowe zmienne do przechwycenia wartości prowadnic
    let verticalGuides = {};
    let horizontalGuides = {};

    let zoomLevel = 1;  // 🔥 Domyślny poziom zoomu
    const zoomFactor = 1.1; // 🔥 O ile zmieniamy skalę (10%)

    function zoomInSvg() {
    console.log("🔍 Powiększam rysunek SVG!");
    zoomLevel *= zoomFactor;
    updateSvgZoom();
    }

    function zoomOutSvg() {
    console.log("🔎 Pomniejszam rysunek SVG!");
    zoomLevel /= zoomFactor;
    updateSvgZoom();
    }

    function fitSvgToContent() {
        console.log("🔍 Dopasowuję SVG do zawartości i koryguję współrzędne...");

        const group = document.getElementById("rotate-group");
        if (!group) {
            console.error("❌ Nie znaleziono grupy 'rotate-group'");
            return;
        }

        const svg = group.closest("svg");
        if (!svg) {
            console.error("❌ Nie znaleziono elementu SVG");
            return;
        }

        // 1. Zapisz aktualną transformację
        const originalTransform = group.getAttribute("transform") || "";

        // 2. Tymczasowo usuń transformację, aby uzyskać prawdziwy bounding box
        group.removeAttribute("transform");
        const bbox = group.getBBox();

        // 3. Przywróć transformację
        group.setAttribute("transform", originalTransform);

        // 4. Oblicz minimalne wartości współrzędnych
        const minX = bbox.x;
        const minY = bbox.y;
        const margin = 10;

        // 5. Oblicz potrzebną korektę pozycji
        const correctionX = -minX + margin;
        const correctionY = -minY + margin;

        // 6. Oblicz nowe wymiary
        const newWidth = bbox.width + 2 * margin;
        const newHeight = bbox.height + 2 * margin;

        // 7. Ustaw viewBox zaczynający się od (0,0)
        svg.setAttribute("viewBox", `0 0 ${newWidth} ${newHeight}`);

        // 8. Zastosuj korektę pozycji
        applyAbsoluteGroupTranslation(group, correctionX, correctionY);

        // 9. Zresetuj zoom
        zoomLevel = 1;
        svg.style.transform = "scale(1)";

        console.log(`✅ Wszystkie współrzędne >= ${margin}`);
        console.log(`✅ Nowy viewBox: 0 0 ${newWidth} ${newHeight}`);
        console.log(`✅ Korekta: X=${correctionX}, Y=${correctionY}`);

        // 10. Aktualizuj prowadnice
        updateGuideValues();
    }

    function applyAbsoluteGroupTranslation(group, tx, ty) {
        // Pobierz aktualny obrót
        const currentTransform = group.getAttribute("transform") || "";
        const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);

        // Zastosuj tylko obrót + nowe przesunięcie
        group.setAttribute("transform",
            rotateMatch
                ? `rotate(${rotateMatch[1]}) translate(${tx} ${ty})`
                : `translate(${tx} ${ty})`
        );
    }

    function resetGroupPosition(group) {
        const currentTransform = group.getAttribute("transform") || "";
        const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);

        group.setAttribute("transform", rotateMatch ? `rotate(${rotateMatch[1]})` : "");
    }

    function applyGroupTranslation(group, tx, ty) {
        const currentTransform = group.getAttribute("transform") || "";
        group.setAttribute("transform", `${currentTransform} translate(${tx} ${ty})`);
    }
  

    function updateSvgZoom() {
    let svgContainer = document.querySelector(".scaled-svg");
    let svg = svgContainer.querySelector("svg");

    if (!svg) {
    console.error("❌ Nie znaleziono rysunku SVG!");
    return;
    }

    // 🔥 Skalowanie poprzez `transform: scale()`
    svg.style.transform = `scale(${zoomLevel})`;
    svg.style.transformOrigin = "center";

    console.log(`✅ Nowy poziom zoomu: ${zoomLevel}`);

    // 🔄 Aktualizacja wartości prowadnic
    updateGuideValues();
    }

    function enableDrag() {
    console.log("🔧 enableDrag uruchomiony!");

    let elements = document.querySelectorAll("svg line, svg circle, svg path");

    //  console.log(`📊 Znaleziono ${elements.length} elementów SVG do aktywacji.`);

    let activatedCount = 0;

    elements.forEach((element, index) => {
    //console.log(`🔹 [${index + 1}/${elements.length}] ID: ${element.id || "(brak)"} - Typ: ${element.tagName}`);

    if (element.tagName === "line" || element.tagName === "circle" || element.tagName === "path") {
    element.removeEventListener('mousedown', startDragOrDelete);
    element.addEventListener('mousedown', startDragOrDelete);
    element.dataset.dragEnabled = "true";
    activatedCount++;
    // console.log(`✅ Aktywowano przesuwanie dla ${element.tagName} (ID: ${element.id || "(brak)"})`);
    } else {
    console.warn(`⚠️ Pominięto element ${element.tagName} (ID: ${element.id || "(brak)"})`);
    }
    });

    //console.log(`🟢 Aktywowano przesuwanie dla ${activatedCount} z ${elements.length} elementów SVG.`);

    let deleteModeCheckbox = document.getElementById("deleteMode");
    if (!deleteModeCheckbox) {
    console.warn("⚠️ Ostrzeżenie: Nie znaleziono elementu #deleteMode! Czekam...");
    setTimeout(enableDrag, 500);
    return;
    }

    deleteModeCheckbox.addEventListener("change", function () {
    deleteMode = this.checked;
    console.log(`🗑️ Tryb usuwania: ${deleteMode ? "WŁĄCZONY" : "WYŁĄCZONY"}`);
    });

    console.log("🟢 enableDrag() zakończone!");
    }

    function startDrag(event) {
        if (!event) {
            console.error("❌ startDrag wywołane bez eventu!");
            return;
        }
    event.preventDefault();
    isDraggingOKN = true;
    draggedLine = event.target;

    const svg = draggedLine.closest('svg');
    const rect = svg.getBoundingClientRect();
    const viewBox = svg.viewBox.baseVal;

    let scaleX = viewBox.width / rect.width; // Skalowanie X
    let scaleY = viewBox.height / rect.height; // Skalowanie Y

    let mouseX = (event.clientX - rect.left) * scaleX + viewBox.x;
    let mouseY = (event.clientY - rect.top) * scaleY + viewBox.y;

    if (draggedLine.id.includes('vertical')) {
    let currentX = parseFloat(draggedLine.getAttribute('x1'));
    offsetX = mouseX - currentX; // 🔥 Poprawiona wartość offsetX
    }

    console.log(`🚀 Rozpoczęto przeciąganie: ${draggedLine.id}, offsetX=${offsetX}`);

    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
    }

    function drag(event) {
    if (isDraggingOKN && draggedLine) {
    const svg = draggedLine.closest('svg');
    const rect = svg.getBoundingClientRect();
    const viewBox = svg.viewBox.baseVal;

    let scaleX = viewBox.width / rect.width;
    let scaleY = viewBox.height / rect.height;

    let newX = (event.clientX - rect.left) * scaleX + viewBox.x - offsetX;
    let newY = (event.clientY - rect.top) * scaleY + viewBox.y;

    // 🔹 Zaokrąglenie do 2 miejsc po przecinku
    newX = parseFloat(newX.toFixed(2));
    newY = parseFloat(newY.toFixed(2));

    //console.log(`🎯 Przesuwam ${draggedLine.id} do X=${newX}, Y=${newY}`);

    if (draggedLine.id.includes('vertical')) {
    draggedLine.setAttribute('x1', newX);
    draggedLine.setAttribute('x2', newX);
    } else if (draggedLine.id.includes('horizontal')) {
    draggedLine.setAttribute('y1', newY);
    draggedLine.setAttribute('y2', newY);
    }

    console.log(`✅ ${draggedLine.id} nowa pozycja: x1=${draggedLine.getAttribute('x1')}, y1=${draggedLine.getAttribute('y1')}`);
    }
    }

    // 🔥 Aktualizacja wartości w panelu bocznym

    // 🔥 Mapa zamiany ID na czytelne nazwy
    const guideLabels = {
    "guide-line-vertical": "Linia lewa rysunku",
    "guide-line-verticalMax": "Linia prawa rysunku",
    "guide-line-verticalOdlSzyby": "Pionowa linia szkła",
    "guide-line-verticalOsSymetrii": "Oś poprzeczki",
    "guide-line-horizontal": "Linia górna rysunku",
    "guide-line-horizontalMax": "Linia dolna rysunku",
    "guide-line-horizontal-korpus": "Linia korpusu",
    "guide-line-horizontal-liniaSzklenia": "Pozioma linia szkła",
    "guide-line-horizontal-okucie": "Pozioma linia OKUCIA",
    "guide-line-horizontal-dormas": "Pozioma linia DORMAS",
    "guide-line-horizontal-OsSymetrii": "Oś ruchomego słupka"
    };


    // 🔥 Aktualizacja wartości w panelu bocznym
       function updateGuideValues() {
        let verticalList = document.getElementById("verticalValues");
        let horizontalList = document.getElementById("horizontalValues");

        verticalList.innerHTML = "";
        horizontalList.innerHTML = "";

        let svg = document.querySelector("svg");
        if (!svg) {
            console.error("❌ Nie znaleziono SVG!");
            return;
        }

        let minY = Infinity;
        let maxY = -Infinity;

        const elements = svg.querySelectorAll("line, path, circle, rect, ellipse, polygon, polyline");

        elements.forEach(el => {
            // Pobierz bounding box elementu (w lokalnych współrzędnych SVG)
            let bbox;
            try {
                bbox = el.getBBox();
            } catch (e) {
                // Niektóre elementy mogą nie mieć bbox (np. niewidoczne)
                bbox = null;
            }
            if (bbox) {
                if (bbox.y < minY) minY = bbox.y;
                if ((bbox.y + bbox.height) > maxY) maxY = bbox.y + bbox.height;
            }
        });

        // if (!isFinite(minY) || !isFinite(maxY)) {
        //     console.warn("⚠️ Nie znaleziono poprawnych wartości Y! Ustawiam minY = 0, maxY = 100.");
             minY = 0;
             maxY = 100;
        // }

        console.log(`📐 minY = ${minY}, maxY = ${maxY}`);

        // Pionowe prowadnice - bez zmian
        Object.keys(verticalGuides).forEach(id => {
            let line = document.getElementById(id);
            let color = line ? line.getAttribute("stroke") : "black";
            let displayName = guideLabels[id] || id;

            let li = document.createElement("li");
            li.innerHTML = `<span style="background-color:${color}; width: 15px; height: 15px; display: inline-block; margin-right: 5px;"></span>
            ${displayName}: ${parseFloat(verticalGuides[id].toFixed(2))}mm`;
            verticalList.appendChild(li);
        });

        // Poziome prowadnice z flippedY względem minY
        Object.keys(horizontalGuides).forEach(id => {
            let line = document.getElementById(id);
            let color = line ? line.getAttribute("stroke") : "black";
            let originalY = horizontalGuides[id];
            let flippedY = originalY - minY;  // 0 przy minY

            let displayName = guideLabels[id] || id;

            let li = document.createElement("li");
            li.innerHTML = `<span style="background-color:${color}; width: 15px; height: 15px; display: inline-block; margin-right: 5px;"></span>
            ${displayName}: ${parseFloat(flippedY.toFixed(2))}mm`;
            horizontalList.appendChild(li);
        });
    }


    function stopDrag() {
    if (draggedLine) {
    console.log(`🛑 Zatrzymano przeciąganie: ${draggedLine.id}`);

    let testLine = document.getElementById(draggedLine.id);
    if (!testLine) {
    console.error(`❌ Linia ${draggedLine.id} zniknęła z DOM!`);
    } else {
    console.log(`✅ Linia ${draggedLine.id} nadal istnieje w DOM.`);
    }

    if (draggedLine.id.includes("vertical")) {
    verticalGuides[draggedLine.id] = parseFloat(draggedLine.getAttribute("x1"));
    } else if (draggedLine.id.includes("horizontal")) {
    horizontalGuides[draggedLine.id] = parseFloat(draggedLine.getAttribute("y1"));
    }

    updateGuideValues(); // 🔥 Aktualizacja wartości po przesunięciu linii
    }

    isDraggingOKN = false;
    draggedLine = null;
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', stopDrag);
    }

    // 🔥 Nowa funkcja: wybiera czy usunąć czy przesuwać
    function startDragOrDelete(event) {
        if (!event) {
            console.error("❌ startDragOrDelete wywołane bez eventu!");
            return;
        }
    event.preventDefault();

    if (deleteMode) {
    deleteLine(event.target);
    } else {
    startDrag(event);
    }
    }

    // 🔥 Usuwanie linii
    function deleteLine(element) {
    console.log(`🗑️ Próbuję usunąć element: ${element.tagName}, ID: ${element.id || "brak"}`);

    // Jeśli to prowadnica, NIE usuwamy jej!
    if (element.id && element.id.includes("guide-line")) {
    console.warn("❌ Nie można usunąć prowadnic!");
    return;
    }

    // Sprawdzenie, czy kliknięto w element SVG
    if (element.tagName === "line" || element.tagName === "path" || element.tagName === "circle") {
    element.remove();
    console.log(`✅ Usunięto element: ${element.tagName}, ID: ${element.id || "brak"}`);
    } else {
    console.warn("⚠️ Kliknięto w element, który nie jest linią, łukiem ani okręgiem.");
    }
    }

    function rotateSvgElements() {
        console.log("🔄 Obracam o 90 stopni");

        let group = document.getElementById("rotate-group");
        if (!group) return;

        // Pobierz aktualną transformację
        let currentTransform = group.getAttribute("transform") || "";

        // Parsuj istniejące wartości
        let translateMatch = currentTransform.match(/translate\((-?\d+\.?\d*)[,\s]*(-?\d+\.?\d*)\)/);
        let rotateMatch = currentTransform.match(/rotate\(([-\d.]+)(?:[,\s]+([-\d.]+))?(?:[,\s]+([-\d.]+))?\)/);

        // Wartości domyślne
        let currentTx = 0;
        let currentTy = 0;
        let currentAngle = 0;
        let cx = 0;
        let cy = 0;

        if (translateMatch) {
            currentTx = parseFloat(translateMatch[1]);
            currentTy = parseFloat(translateMatch[2]);
        }

        if (rotateMatch) {
            currentAngle = parseFloat(rotateMatch[1]);
            if (rotateMatch[3]) {
                cx = parseFloat(rotateMatch[2]);
                cy = parseFloat(rotateMatch[3]);
            }
        }

        // Nowy kąt
        const newAngle = (currentAngle + 90) % 360;

        // Jeśli nie mamy środka obrotu, oblicz go
        if (!rotateMatch) {
            const bbox = group.getBBox();
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }

        // Zbuduj nową transformację
        let newTransform = `rotate(${newAngle} ${cx} ${cy}) `;
        newTransform += `translate(${currentTx} ${currentTy})`;

        // Zastosuj transformację
        group.setAttribute("transform", newTransform);
        console.log(`🔄 Nowy kąt: ${newAngle}°, środek: (${cx}, ${cy})`);

        // Aktualizuj widok
        updateGuideValues();
    }

    function updateTransform(dx, dy) {
        let group = document.getElementById("rotate-group");
        if (!group) return;

        // Pobierz aktualną transformację
        let currentTransform = group.getAttribute("transform") || "";

        // Parsuj istniejące wartości
        let translateMatch = currentTransform.match(/translate\((-?\d+\.?\d*)[,\s]*(-?\d+\.?\d*)\)/);
        let rotateMatch = currentTransform.match(/rotate\(([-\d.]+)(?:[,\s]+([-\d.]+))?(?:[,\s]+([-\d.]+))?\)/);

        // Wartości domyślne
        let currentTx = 0;
        let currentTy = 0;
        let angle = 0;
        let cx = 0;
        let cy = 0;

        // Aktualne przesunięcie
        if (translateMatch) {
            currentTx = parseFloat(translateMatch[1]);
            currentTy = parseFloat(translateMatch[2]);
        }

        // Aktualny obrót
        if (rotateMatch) {
            angle = parseFloat(rotateMatch[1]);
            if (rotateMatch[3]) {
                cx = parseFloat(rotateMatch[2]);
                cy = parseFloat(rotateMatch[3]);
            }
        }

        // Transformacja wektora zgodnie z kątem
        let [transformedDx, transformedDy] = transformVector(dx, dy, angle);

        // Nowe przesunięcie
        const newTx = currentTx + transformedDx;
        const newTy = currentTy + transformedDy;

        // Zbuduj nową transformację
        let newTransform = "";

        // Dodaj obrót jeśli istnieje
        if (angle !== 0) {
            newTransform = `rotate(${angle} ${cx} ${cy}) `;
        }

        // Dodaj przesunięcie
        newTransform += `translate(${newTx} ${newTy})`;

        // Zastosuj nową transformację
        group.setAttribute("transform", newTransform);
        console.log(`✅ Nowa transformacja: ${newTransform}`);
    }

    function transformVector(dx, dy, angle) {
        // Normalizuj kąt do zakresu 0-360
        angle = angle % 360;
        if (angle < 0) angle += 360;

        // Dla wielokrotności 90 stopni
        if (angle === 90) return [-dy, dx];
        if (angle === 180) return [-dx, -dy];
        if (angle === 270) return [dy, -dx];

        return [dx, dy]; // Dla 0° i innych kątów
    }

    function shiftRightSvgElements() {
        console.log("➡️ Przesuwam w prawo (wizualnie)");
        updateTransform(1, 0);
    }

    function shiftLeftSvgElements() {
        console.log("⬅️ Przesuwam w lewo (wizualnie)");
        updateTransform(-1, 0);
    }

    function shiftUpSvgElements() {
        console.log("⬆️ Przesuwam w górę (wizualnie)");
        updateTransform(0, -1);
    }

    function shiftDownSvgElements() {
        console.log("⬇️ Przesuwam w dół (wizualnie)");
        updateTransform(0, 1);
    }

    // Bardziej odporna funkcja: konwertuje SVG string -> base64 PNG
    window.generatePngFromSvg = function (svgContent) {
        return new Promise((resolve, reject) => {
            try {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, "image/svg+xml");

                // Parser error?
                const parseError = svgDoc.querySelector("parsererror");
                if (parseError) {
                    console.error("generatePngFromSvg: parsererror:", parseError.textContent);
                    reject("Błąd parsera SVG: " + parseError.textContent);
                    return;
                }

                const svgEl = svgDoc.documentElement;
                if (!svgEl || svgEl.nodeName.toLowerCase() !== "svg") {
                    console.error("generatePngFromSvg: brak elementu <svg>");
                    reject("Brak elementu <svg> w przekazanym stringu.");
                    return;
                }

                // Ensure xmlns
                if (!svgEl.getAttribute("xmlns")) {
                    svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                }

                // Ustal viewBox / width / height
                let width = parseFloat(svgEl.getAttribute("width")) || NaN;
                let height = parseFloat(svgEl.getAttribute("height")) || NaN;
                const vb = svgEl.getAttribute("viewBox");

                if (!vb) {
                    if (!isFinite(width) || !isFinite(height)) {
                        // brak viewBox i brak width/height -> ustaw domyślne wymiary
                        width = 800;
                        height = 800;
                        svgEl.setAttribute("viewBox", `0 0 ${width} ${height}`);
                    } else {
                        // ustaw viewBox z width/height (usuwa jednostki, jeśli były)
                        svgEl.setAttribute("viewBox", `0 0 ${width} ${height}`);
                    }
                } else {
                    const parts = vb.trim().split(/\s+|,/).map(Number);
                    if (parts.length >= 4 && parts.every(p => !isNaN(p))) {
                        const vbW = parts[2], vbH = parts[3];
                        if (!isFinite(width)) width = vbW;
                        if (!isFinite(height)) height = vbH;
                        svgEl.setAttribute("width", width);
                        svgEl.setAttribute("height", height);
                    } else {
                        // fallback
                        if (!isFinite(width)) width = 800;
                        if (!isFinite(height)) height = 800;
                        svgEl.setAttribute("width", width);
                        svgEl.setAttribute("height", height);
                    }
                }

                // Serializacja
                const svgString = new XMLSerializer().serializeToString(svgDoc);

                // Uwaga: obecność <image href="..."> może powodować błędy lub tzw. tainting canvas (CORS).
                const hasImages = svgEl.querySelectorAll("image").length > 0;
                if (hasImages) {
                    console.warn("generatePngFromSvg: SVG zawiera <image> — może powodować błędy lub problemy CORS.");
                }

                // Utwórz blob i objectURL
                const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
                const url = URL.createObjectURL(blob);

                let triedDataUri = false;
                const img = new Image();
                img.crossOrigin = "anonymous";

                img.onload = function () {
                    try {
                        const canvas = document.createElement("canvas");
                        // używamy ustalonych wymiarów z atrybutów SVG
                        canvas.width = Math.round(width);
                        canvas.height = Math.round(height);

                        // const ctx = canvas.getContext("2d"); // będzie białe tło
                        // // opcjonalne białe tło
                        // ctx.fillStyle = "#ffffff";
                        // ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        const ctx = canvas.getContext("2d", { willReadFrequently: true });

                        // 🟢 bez tła – przezroczysty PNG
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        URL.revokeObjectURL(url);
                        const base64 = canvas.toDataURL("image/png").split(",")[1];
                        resolve(base64);
                    } catch (err) {
                        URL.revokeObjectURL(url);
                        console.error("generatePngFromSvg: błąd rysowania na canvas:", err);
                        reject("Błąd rysowania na canvas: " + err.message);
                    }
                };

                img.onerror = function (e) {
                    console.error("generatePngFromSvg: Błąd ładowania SVG do <img>:", e);
                    // spróbuj fallbacku: data URI (może pomóc przy niektórych konfiguracjach)
                    if (!triedDataUri) {
                        triedDataUri = true;
                        try {
                            const dataUri = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
                            img.src = dataUri;
                            return;
                        } catch (err) {
                            console.error("generatePngFromSvg: fallback dataURI failed:", err);
                        }
                    }

                    URL.revokeObjectURL(url);
                    // dla debugowania pokaż kawałek SVG
                    console.error("generatePngFromSvg: SVG head:", svgString.substring(0, 500));
                    reject("Błąd ładowania SVG do obrazu");
                };

                // Start load using objectURL
                img.src = url;
            } catch (err) {
                console.error("generatePngFromSvg: wyjątek:", err);
                reject("Wyjątek generatePngFromSvg: " + err.message);
            }
        });
    };

    function getGuidesData() {
    console.log("📡 Pobieram dane prowadnic...");

    //let verticalGuides = {};
    //let horizontalGuides = {};

    // Pobieramy wszystkie prowadnice
    document.querySelectorAll("line[id^='guide-line']").forEach(line => {
    let id = line.id;
    let x1 = parseFloat(line.getAttribute("x1"));
    let y1 = parseFloat(line.getAttribute("y1"));

    if (id.includes("vertical")) {
    verticalGuides[id] = x1;
    } else if (id.includes("horizontal")) {
    horizontalGuides[id] = y1;
    }
    });

    console.log("✅ Prowadnice pobrane:", { vertical: verticalGuides, horizontal: horizontalGuides });

    return { vertical: verticalGuides, horizontal: horizontalGuides };
    }


    function getUpdatedSvg() {
    let svg = document.querySelector(".scaled-svg svg");
    if (!svg) {
    console.error("❌ Nie znaleziono rysunku SVG!");
    return "";
    }

    let clonedSvg = svg.cloneNode(true);

    // 🔥 Naprawiamy problem z obrotem `rotate(...)`
    clonedSvg.querySelectorAll("[transform]").forEach(element => {
    let transformValue = element.getAttribute("transform");

    if (transformValue && transformValue.includes("rotate")) {
    // Zamiana przecinków na spacje (poprawny format dla SVG)
    transformValue = transformValue.replace(/,/g, " ");
    element.setAttribute("transform", transformValue);
    }
    });

    // 📏 Znajdź rzeczywisty obszar rysunku (bez prowadnic)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    clonedSvg.querySelectorAll("line, path, circle, rect, ellipse, polygon, polyline").forEach(el => {
    let xVals = [], yVals = [];

    ["x", "cx", "x1", "x2"].forEach(attr => {
    let val = parseFloat(el.getAttribute(attr) || "NaN");
    if (!isNaN(val)) xVals.push(val);
    });

    ["y", "cy", "y1", "y2"].forEach(attr => {
    let val = parseFloat(el.getAttribute(attr) || "NaN");
    if (!isNaN(val)) yVals.push(val);
    });

    if (xVals.length > 0) {
    minX = Math.min(minX, ...xVals);
    maxX = Math.max(maxX, ...xVals);
    }
    if (yVals.length > 0) {
    minY = Math.min(minY, ...yVals);
    maxY = Math.max(maxY, ...yVals);
    }
    });

    let width = maxX - minX;
    let height = maxY - minY;

    if (width <= 0 || height <= 0) {
    console.error(`❌ Błąd: Wymiary SVG są niepoprawne! width=${width}, height=${height}`);
    return new XMLSerializer().serializeToString(svg);
    }

    // 🔥 Skracamy prowadnice do granic rysunku!
    clonedSvg.querySelectorAll("line[id^='guide-line']").forEach(line => {
    let id = line.id;
    if (id.includes("vertical")) {
    let x = parseFloat(line.getAttribute("x1"));
    if (x < minX) x = minX;
    if (x > maxX) x = maxX;
    line.setAttribute("x1", x);
    line.setAttribute("x2", x);
    line.setAttribute("y1", minY);
    line.setAttribute("y2", maxY);
    } else if (id.includes("horizontal")) {
    let y = parseFloat(line.getAttribute("y1"));
    if (y < minY) y = minY;
    if (y > maxY) y = maxY;
    line.setAttribute("y1", y);
    line.setAttribute("y2", y);
    line.setAttribute("x1", minX);
    line.setAttribute("x2", maxX);
    }
    });

    // 🔥 Dopasowujemy `viewBox`
    clonedSvg.setAttribute("viewBox", `${minX} ${minY} ${width} ${height}`);
    clonedSvg.setAttribute("width", width);
    clonedSvg.setAttribute("height", height);

    console.log(`✅ Nowe viewBox: ${minX} ${minY} ${width} ${height}`);

    return new XMLSerializer().serializeToString(clonedSvg);
    }


    function setSvgContent(svgString) {
    let retries = 15; // Więcej prób na wypadek opóźnień Blazora
    let delay = 300; // Krótszy czas między próbami

    function tryInsertSvg() {
    let tabContent = document.querySelector(".ant-tabs-tab-active"); // Sprawdza aktywną zakładkę
    let svgContainer = document.querySelector(".scaled-svg");

    if (!tabContent || !svgContainer) {
    if (retries > 0) {
    console.warn(`❌ Nie znaleziono kontenera SVG lub zakładka nieaktywna! Próba ponownie za ${delay}ms...`);
    retries--;
    setTimeout(tryInsertSvg, delay);
    } else {
    console.error("🚨 Błąd krytyczny: Kontener SVG nadal nie został znaleziony!");
    }
    return;
    }

    svgContainer.innerHTML = svgString;
    console.log("✅ Zaktualizowano SVG w Blazorze!");

    // 🚀 Ponowne aktywowanie obsługi przesuwania linii
    enableDrag();
    }

    setTimeout(tryInsertSvg, delay);
    }

    // Automatyczne przypisanie eventów po załadowaniu SVG
    document.addEventListener('DOMContentLoaded', () => {
    console.log("🌟 Dokument załadowany, uruchamiam enableDrag()");
    enableDrag();
    });

    window.saveFileFromBytes = (filename, base64Data) => {
    const link = document.createElement('a');
    link.download = filename;
    link.href = 'data:application/dxf;base64,' + base64Data;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

    // Funkcja do resetowania całkowicie pozycji (użyj w razie potrzeby)
    function fullResetSvg() {
        const group = document.getElementById("rotate-group");
        if (group) {
            group.removeAttribute("transform");
        }

        const svg = document.querySelector(".scaled-svg svg");
        if (svg) {
            svg.removeAttribute("viewBox");
            svg.style.transform = "scale(1)";
        }

        zoomLevel = 1;
        console.log("✅ Zresetowano całkowicie pozycję SVG");
    }

        function flipVerticalSvg() {
        console.log("🪞 Stosuję odbicie lustrzane w pionie...");

        const group = document.getElementById("rotate-group");
        if (!group) return;

        // Pobierz aktualny bounding box
        const bbox = group.getBBox();
        const centerY = bbox.y + bbox.height / 2;

        // Pobierz aktualną transformację
        let currentTransform = group.getAttribute("transform") || "";

        // Sprawdź czy już istnieje odbicie
        const hasFlip = currentTransform.includes("scale(1, -1)");

        if (hasFlip) {
            // Usuń odbicie - przywróć oryginał
            currentTransform = currentTransform
                .replace(/scale\(1, -1\)\s*translate\(0, [-\d.]+\)/, "")
                .trim();
            group.setAttribute("transform", currentTransform);
            console.log("✅ Usunięto odbicie lustrzane");
        } else {
            // Dodaj nowe odbicie
            const flipTransform = `scale(1, -1) translate(0, ${-2 * centerY})`;
            group.setAttribute("transform", `${currentTransform} ${flipTransform}`);
            console.log(`✅ Dodano odbicie względem osi Y=${centerY}`);
        }

        updateGuideValues();
    }

</script>

<div class="d-flex align-items-center flex-wrap gap-2">
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoKonfiguratorNowegoSystemu">
        Dodaj nowy system
    </Button>
    <Button Icon="@IconType.Fill.Tool" Style="flex-grow: 1; height: 35px;" OnClick="GoBudujModeleOkien">
        Modele okien - buduj
    </Button>
    <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator nowego systemu lub wybierz go z listy">
        <Button Icon="@IconType.Fill.Windows" Style="flex-grow: 1; height: 35px;" OnClick="GoKonfiguratorPolaczen">
            Otwórz konfigurator połączeń naroży
        </Button>
    </Tooltip>
    <Tooltip Placement="@Placement.TopRight" Title="Otwórz konfigurator połączeń rama/skrzydło/słupek">
        <Button Icon="@IconType.Fill.Windows" Style="flex-grow: 1; height: 35px;" OnClick="GoKonfiguratorPolaczenKwadratow">
            Otwórz konfigurator połączeń rama/skrzydło/słupek
        </Button>
    </Tooltip>
    <Tooltip Placement="@Placement.TopRight" Title="Wróć do poprzedniej strony">
        <Button class="btn-back" Icon="@IconType.Fill.Backward" Style="width:25px" OnClick="GoBack" />
    </Tooltip>
</div>

<hr />

@if (Systemy != null && Systemy.Any())
{
    <select class="form-select me-2" style="flex-grow: 1;" @onchange="@(async (args) => await OnSystemSelected(args))">
        <option value="" disabled selected>-- Wybierz system --</option>
        @foreach (var system in Systemy)
        {
            <option value="@system.RowId">@system.Nazwa_Systemu</option>
        }
    </select>
}

<Divider Style="font-weight:bold; font-size:large; display:flex; justify-content:space-between; align-items:center;">

    <Tooltip Placement="@Placement.BottomCenter" Title="Zapisz ustawienia">
        <Button class="btn-back" Icon="@IconType.Fill.Save" Style="height:35px; padding-right:25px" OnClick="SaveLinieDXF" >Zapisz wszystkie ustawienia </Button>
    </Tooltip>
    @if (activeKey == "2")
    {
        <Tooltip Placement="@Placement.TopRight" Title="Obróć o 90 stopni">
            <Button class="btn-back" Icon="@IconType.Outline.Redo" Style="width:27px" OnClick="RotateObj" />
        </Tooltip>

        <Button class="btn-back" Icon="@IconType.Outline.ArrowLeft" Style="width:27px" OnClick="MoveLeftObj" />
        <Button class="btn-back" Icon="@IconType.Outline.ArrowRight" Style="width:27px" OnClick="MoveRightObj" />
        <Button class="btn-back" Icon="@IconType.Outline.ArrowDown" Style="width:27px" OnClick="MoveDownObj" />
        <Button class="btn-back" Icon="@IconType.Outline.ArrowUp" Style="width:27px" OnClick="MoveUpObj" />
        <Button class="btn-back" Icon="@IconType.Outline.ZoomIn" Style="width:27px" OnClick="ZoomInObj" />
        <Button class="btn-back" Icon="@IconType.Outline.ZoomOut" Style="width:27px" OnClick="ZoomOutObj" />
        <Button class="btn-back" Icon="@IconType.Outline.Drag" Style="width:27px" OnClick="FitSvg" />
        <Button class="btn-back" Icon="@IconType.Outline.Swap" Style="width:27px" OnClick="FlipVertical" />
       @*  <Button class="btn-back" Icon="@IconType.Outline.MergeCells" Style="width:27px" OnClick="FitResetSvg" /> *@
    }

</Divider>

<Tabs DefaultActiveKey="0" @bind-ActiveKey="activeKey">
    <TabPane Tab="Zapisane elementy w konfiguracji" Key="0">
        <h3 class="text-center mt-3">
            📌 Skonfigurowane elementy
            <Tooltip Placement="@Placement.TopRight" Title="Dodaj nowy element konstrukcyjny">
                <Button class="btn-back" Icon="@IconType.Outline.NodeIndex" OnClick="DodajNowy">Dodaj nowy profil</Button>
            </Tooltip>
        </h3>

        <div class="container mt-4">
            @*             <button class="btn btn-primary mb-3" @onclick="DodajNowy">
                <i class="fas fa-plus"></i> Dodaj Nowy System
            </button>
 *@
            @if (KonfiguracjeSystemu != null && KonfiguracjeSystemu.Any())
            {
                <table class="table table-striped table-hover">
                    <thead class="thead-dark">
                        <tr>
                            <th>Nazwa</th>
                            <th>Indeks</th>
                            <th>Uwagi</th>
                            <th>Miniaturka</th>
                            <th>Akcje</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var konf in KonfiguracjeSystemu)
                        {
                            <tr>
                                <td>@konf.Nazwa</td>
                                <td>@konf.Indeks</td>
                                <td>@konf.Uwagi</td>
                                <td>
                                    @if (konf.Rysunek != null && konf.Rysunek.Length > 0)
                                    {
                                        <img title="@konf.RowId" src="@RysunekToBase64(konf.Rysunek)" alt="Miniatura" style="width: 50px; height: auto;" />
                                    }
                                    else
                                    {
                                        <span class="text-muted">Brak</span>
                                    }
                                </td>
                                <td>
                                    <button class="btn btn-warning btn-sm me-2" @onclick="() => Edytuj(konf.Id)">
                                        <i class="fas fa-edit"></i> Edytuj
                                    </button>
                                    <button class="btn btn-danger btn-sm" @onclick="() => Usun(konf.Id)">
                                        <i class="fas fa-trash-alt"></i> Usuń
                                    </button>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>

            }
            else
            {
                <p class="text-muted text-center">Brak dostępnych.</p>
            }
        </div>
    </TabPane>
    <TabPane Tab="Opis systemu" Key="1">
        <div class="container mt-4">
            <h4 class="mb-3">📝 Konfiguracja Systemu</h4>

            <div class="card p-3">
                <div class="row">
                    <!-- Wybór Typu Profila -->
                    <div class="col-md-6">
                        <label class="form-label">Typ profilu</label>
                        <Select Mode="SelectMode.Default"
                        DataSource="@_typ"
                        @bind-Value="@konfSystem.Typ"
                        LabelName="@nameof(Typ.Nazwa)"
                        ValueName="@nameof(Typ.Nazwa)"
                        Class="form-select">
                        </Select>
                    </div>

                    <!-- Indeks -->
                    <div class="col-md-6">
                        <label class="form-label">Indeks</label>
                        <Input class="form-control" @bind-Value="@konfSystem.Indeks" />
                    </div>
                </div>

                <div class="row mt-3">
                    <!-- Nazwa -->
                    <div class="col-md-12">
                        <label class="form-label">Nazwa</label>
                        <TextArea class="form-control" @bind-Value="@konfSystem.Nazwa" />
                    </div>
                </div>

                <hr class="my-4" />

                <h5 class="mb-3">📏 Parametry Techniczne</h5>

                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Kąt Wystąpienia (min)</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.KatWystapieniaZakresOdMin" />
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Kąt Wystąpienia (max)</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.KatWystapieniaZakresOdMax" />
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-6">
                        <label class="form-label">Zakres Długości (min)</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.ZakresStosDlugoscOdMin" />
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Zakres Długości (max)</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.ZakresStosDlugoscOdMax" />
                    </div>
                </div>

                <hr class="my-4" />

                <h5 class="mb-3">💲 Koszty i Waga</h5>

                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Cena za 1 MB</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.Cena1MB" />
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Waga</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.Waga" />
                    </div>
                </div>

                <hr class="my-4" />

                <h5 class="mb-3">📐 Kantówki</h5>

                <div class="row">
                    <div class="col-md-4">
                        <label class="form-label">Wymiar X Kantówki</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.WymiarXKantowki1" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wymiar Y Kantówki</label>
                        <Input type="number" class="form-control" @bind-Value="@konfSystem.WymiarYKantowki1" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Cena za 1 MB Kantówki</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.Cena1MBKantowki1" />
                    </div>
                </div>

                <div class="row mt-3">
                    <div class="col-md-4">
                        <label class="form-label">Waga Kantówki</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.WagaKantowki1" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Długość Kantówki</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.DlugoscKantowki1" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Ilość Sztuk Kantówki</label>
                        <Input type="number" class="form-control" step="0.01" @bind-Value="@konfSystem.IloscSztukKantowki1" />
                    </div>
                </div>

                <hr class="my-4" />

                <h5 class="mb-3">📏 Linie opisujące gabaryty profila</h5>
                <div class="row">
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pozima dolna</label>
                        <input type="number" class="form-control" @bind="@konfSystem.PoziomDol" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pozima górna</label>
                        <input type="number" class="form-control" @bind="@konfSystem.PoziomGora" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pionowa lewa</label>
                        <input type="number" class="form-control" step="0.01" @bind="@konfSystem.PionLewa" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pionowa prawa</label>
                        <input type="number" class="form-control" step="0.01" @bind="@konfSystem.PionPrawa" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pionowa oś symetrii</label>
                        <input type="number" class="form-control" step="0.01" @bind="@konfSystem.PionOsSymetrii" />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">Wartość linia: pozioma oś symetrii</label>
                        <input type="number" class="form-control" step="0.01" @bind="@konfSystem.PoziomOsSymetrii" />
                    </div>
                </div>
                <br/>
                <br/>
                <!-- Przyciski akcji -->
                <div class="text-end">
                    <button class="btn btn-success" onclick="@SaveLinieDXF">
                        <i class="fas fa-save"></i> Zapisz zmiany
                    </button>
                </div>
            </div>
            <br/>
                    <br/>
            <br />
        </div>

    </TabPane>
    <TabPane Tab="Linie oraz rysunek DXF" Key="2">
        <h6>
            Podgląd DXF
            <Button OnClick="RefreshSvg" Icon="@IconType.Outline.Fire" Style="margin-left: 10px;">
                🔄 Odśwież rysunek
            </Button>
            <button class="btn btn-info" @onclick="DownloadDxf">Pobierz DXF</button>
        </h6>

        <!-- Wrapper dla SVG i wartości linii -->
        <div style="display: flex; align-items: flex-start; gap: 15px;">

            <!-- Wyświetlanie SVG -->
            <div class="scaled-svg" @key="SvgKey" style="flex: 1; padding: 15px">
                @if (czekajNaDane && !string.IsNullOrEmpty(SvgContent) && activeKey == "2")
                {
                    <div>
                        @((MarkupString)SvgContent)
                    </div>
                }
                else
                {
                    <p>⏳ Wczytywanie rysunku...</p>
                }
            </div>


            <!-- Panel po prawej stronie -->
            <div style="width: 300px; border-left: 2px solid #ccc; padding-left: 10px;">
                <div>
                    <label>Ustaw prezycje zapisu linii:</label>
                    <AntDesign.InputNumber @bind-Value="precyzjaZapisuLinii" Min="0" Max="2" DefaultValue="0" PlaceHolder="Precyzja zapisu"></AntDesign.InputNumber>
                </div>
                <h4>📊 Wartości linii</h4>

                <h5>🟥 Pionowe:</h5>
                <ul id="verticalValues">
                    <li>Brak danych</li>
                </ul>

                <h5>🟦 Poziome:</h5>
                <ul id="horizontalValues">
                    <li>Brak danych</li>
                </ul>

                <hr />

                <!-- 🔥 Checkbox do usuwania linii -->
                @if (czekajNaDane && !string.IsNullOrEmpty(SvgContent) && activeKey == "2")
                {
                    <label>
                        <input type="checkbox" id="deleteMode" /> Tryb usuwania linii 🗑️
                    </label>
                }

                <hr>
                <label>Występuje:</label> 
                <br/>
                <label>
                    <input type="checkbox" @bind="@konfSystem.WystepujeDol" /> Na dole
                </label>
                <label>
                    <input type="checkbox" @bind="@konfSystem.WystepujeLewa" /> Po lewej
                </label>
                <br/>
                <label>
                    <input type="checkbox" @bind="@konfSystem.WystepujeGora" /> U góra
                </label>
                <label>
                    <input type="checkbox" @bind="@konfSystem.WystepujePrawa" /> Po prawej
                </label>
                <hr />
                <label>
                    <input type="checkbox" @bind="@konfSystem.CzyMozeBycFix" /> Czy można wstawić szybę
                </label>
            </div>

        </div>

        <InputFile OnChange="HandleSelected" multiple accept=".dxf">Wybierz pliki DXF</InputFile>

    </TabPane>
</Tabs>

@code {

    [Inject] private AppState AppState { get; set; } = default!;

    private string? SvgContent { get; set; }
    private string? SelectIndesk { get; set; }
    private string SvgKey { get; set; } = Guid.NewGuid().ToString(); // 🔥 Zabezpieczenie przed nadpisywaniem

    private List<int> intProwadnicePionowe = new List<int>();
    private List<int> intProwadnicePoziome = new List<int>();

    private List<SystemyOkienne> Systemy = new();

    private string? SelectedSystemId;

    KonfSystem konfSystem = new KonfSystem();

    private List<KonfSystem>? KonfiguracjeSystemu;

    private string? activeKey;

    private int precyzjaZapisuLinii = 0;

    protected override async Task OnInitializedAsync()
    {
        if (AppState != null)
        {
            AppState.SomeData = "";
        }

        await Laduj_Uprawnienia();

        Systemy = await Http.GetFromJsonAsync<List<SystemyOkienne>>($"api/systemy-okienne") ?? new List<SystemyOkienne>();

        KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>("api/konfsystem");
    }

    private string RysunekToBase64(byte[]? imageData)
    {
        if (imageData == null || imageData.Length == 0)
        {
            return "data:image/png;base64,"; // Zapobiega błędom
        }

        return $"data:image/png;base64,{Convert.ToBase64String(imageData)}";
    }

    private async Task OnSystemSelected(ChangeEventArgs e)
    {
        SelectedSystemId = e.Value.ToString();
        Console.WriteLine($"Wybrano system o ID: {SelectedSystemId}");
        // Możesz dodać dalszą logikę, np. przekierowanie do szczegółów systemu

        await Task.CompletedTask;
    }

    private bool czekajNaDane = false;

    private async Task Edytuj(int id)
    {
        if (!boolZmiana)
        {
            await _message.Warning("Nie masz uprawnień do zmiany danych!");
            return;
        }

        activeKey = "2";

        czekajNaDane = false;

        // 📡 Pobierz dane z API
        konfSystem = await Http.GetFromJsonAsync<KonfSystem>($"api/konfsystem/{id}");

        if (konfSystem != null)
        {
            if (!string.IsNullOrEmpty(konfSystem.SVG))
            {
                SvgContent = konfSystem.SVG;

                SelectIndesk = konfSystem.Indeks;

                Console.WriteLine($"✅ Wczytano zapisany rysunek SVG konfSystem.RowId: {konfSystem.RowId}");

                try
                {
                    var doc = System.Xml.Linq.XDocument.Parse(SvgContent);
                    var svgElement = doc.Root;

                    if (svgElement != null && svgElement.Name.LocalName == "svg")
                    {
                        string? width = svgElement.Attribute("width")?.Value;
                        string? height = svgElement.Attribute("height")?.Value;
                        string? viewBox = svgElement.Attribute("viewBox")?.Value;

                        Console.WriteLine($"📐 SVG: width={width}, height={height}, viewBox={viewBox}");
                    }
                    else
                    {
                        Console.WriteLine("❌ Nie znaleziono głównego elementu <svg>");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ Błąd podczas parsowania SVG: {ex.Message}");
                }
            }
            else
            {
                Console.WriteLine("⚠️ Brak zapisanego SVG w bazie!");
            }

        }
        await Task.Delay(100);
        czekajNaDane = true;

    }

    private async Task DodajNowy()
    {
        SvgContent = "";
        SvgKey = Guid.NewGuid().ToString();
        konfSystem = new KonfSystem();

        activeKey = "2";

        await Task.CompletedTask;
    }

    private async Task Usun(int id)
    {
        if (!boolUsuniecia)
        {
            await _message.Warning("Nie masz uprawnień do usunięcia danych!");
            return;
        }
        await OpenModal("Potwierdzenie usunięcia", "Czy na pewno chcesz usunąć pozycję?");

        if (pytanieOK)
        {

            await Http.DeleteAsync($"api/konfsystem/{id}");
            KonfiguracjeSystemu = null;
            KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>("api/konfsystem");
        }
    }

    private async Task DownloadDxf()
    {
        if(string.IsNullOrEmpty(SvgContent))
        {
            Console.WriteLine("⚠️ Brak SVG do pobrania DXF!");
            SelectIndesk = "plik_dxf";
        }
        // zakładamy, że SvgContent masz jako string
        var response = await Http.PostAsJsonAsync($"api/DownloadDxf/{Uri.EscapeDataString(SelectIndesk)}", SvgContent);

        if (response.IsSuccessStatusCode)
        {
            var dxfBytes = await response.Content.ReadAsByteArrayAsync();

            // Wywołujemy JS, żeby zapisać plik
            await JSRuntime.InvokeVoidAsync("saveFileFromBytes", $"{Uri.EscapeDataString(SelectIndesk)}.dxf", Convert.ToBase64String(dxfBytes));
        }
        else
        {
            Console.WriteLine("❌ Błąd pobierania DXF: " + await response.Content.ReadAsStringAsync());
        }
    }

    private async Task RefreshSvg()
    {

        // czekajNaDane = false;
        //SvgKey = Guid.NewGuid().ToString(); // 🔥 Zabezpieczenie przed nadpisywaniem
        // Console.WriteLine("🔄 Rozpoczynam odświeżanie SVG...");
        // StateHasChanged(); // 🔄 Pełne odświeżenie UI (ponowne dodanie SVG)

        // 🔥 Czekamy na Blazor, żeby się upewnić, że SVG jest w DOM
        await Task.Delay(300);

        // 🔥 Ponowne aktywowanie obsługi prowadnic
        //await JSRuntime.InvokeVoidAsync("setSvgContent", LSvgContent);
        await JSRuntime.InvokeVoidAsync("enableDrag");
        //await JSRuntime.InvokeVoidAsync("stopDrag");


        //czekajNaDane = true;


        SvgKey = Guid.NewGuid().ToString(); // 🔥 Zabezpieczenie przed nadpisywaniem

        StateHasChanged();

        Console.WriteLine("✅ SVG odświeżone!");
    }


    // private async Task Zapisz()
    // {
    //     if (!boolZmiana)
    //     {
    //         await _message.Warning("Nie masz uprawnień do zmiany danych!");
    //         return;
    //     }

    //     Console.WriteLine($"Zapisano: {konfSystem.Nazwa}");
    //     await Http.PostAsJsonAsync("api/systemy-okienne", konfSystem);
    // }

    // private void Anuluj()
    // {
    //     konfSystem = new SystemyOkienne(); // Reset formularza
    // }

    private async Task RotateObj()
    {
        await JSRuntime.InvokeVoidAsync("rotateSvgElements");
        StateHasChanged();
    }

    private async Task MoveRightObj()
    {
        await JSRuntime.InvokeVoidAsync("shiftRightSvgElements");
        StateHasChanged();
    }

    private async Task MoveLeftObj()
    {
        await JSRuntime.InvokeVoidAsync("shiftLeftSvgElements");
        StateHasChanged();
    }

    private async Task MoveDownObj()
    {
        await JSRuntime.InvokeVoidAsync("shiftDownSvgElements");
        StateHasChanged();
    }

    private async Task MoveUpObj()
    {
        await JSRuntime.InvokeVoidAsync("shiftUpSvgElements");
        StateHasChanged();
    }

    private async Task ZoomInObj()
    {
        await JSRuntime.InvokeVoidAsync("zoomInSvg");
        StateHasChanged();
    }

    private async Task ZoomOutObj()
    {
        await JSRuntime.InvokeVoidAsync("zoomOutSvg");
        StateHasChanged();
    }

    private async Task FitResetSvg()
    {
        await JSRuntime.InvokeVoidAsync("fullResetSvg");
        StateHasChanged();
    }

    private async Task FitSvg()
    {
        await JSRuntime.InvokeVoidAsync("fitSvgToContent");
        StateHasChanged();
    }

    private async Task FlipVertical()
    {
        await JSRuntime.InvokeVoidAsync("flipVerticalSvg");
        StateHasChanged();
    }

    private async Task SaveLinieDXF()
    {
        if (!boolZmiana)
        {
            await _message.Warning("Nie masz uprawnień do zmiany danych!");
            return;
        }

        if (string.IsNullOrEmpty(SelectedSystemId))
        {
            _ = _notice.Info(new()
            {
                Message = "Informacja!!",
                Description = $"Wybierz System!!!!",
                Placement = NotificationPlacement.BottomLeft,
                Duration = 2
            });
            return;
        }

        if (string.IsNullOrEmpty(konfSystem.Nazwa) || string.IsNullOrEmpty(konfSystem.Indeks))
        {
            activeKey = "1";

            _ = _notice.Info(new()
            {
                Message = "Informacja!!",
                Description = $"Podaj Nazwę oraz Indeks elementu!!!!",
                Placement = NotificationPlacement.BottomLeft,
                Duration = 2
            });
            return;
        }

        try
        {
            // 🔥 Pobierz aktualne SVG z przeglądarki
            konfSystem.SVG = await JSRuntime.InvokeAsync<string>("getUpdatedSvg");

            // 🔥 Wczytaj do XmlDocument
            var svgDoc = new XmlDocument();
            string svgCleaned = CleanSvgXml(konfSystem.SVG);
            svgDoc.LoadXml(svgCleaned);

            var svgElement = svgDoc.DocumentElement;
            if (svgElement == null)
            {
                Console.WriteLine("❌ Błąd: SVG jest puste!");
                return;
            }

            // Pobierz wymiary SVG
            double width = ParseSvgDimension(svgElement.GetAttribute("width"));
            double height = ParseSvgDimension(svgElement.GetAttribute("height"));

            // 🔄 Zaktualizuj linie pionowe i poziome zgodnie z wartościami w konfSystem
            UpdateGuideLines(svgDoc, width, height);

            // Zaktualizuj SVG w konfSystem
            // 1. Zapisz SVG z prowadnicami
            konfSystem.SVG = svgDoc.OuterXml.Replace(",", ".");
            SvgContent = konfSystem.SVG;

            // 2. Usuń prowadnice dla PNG
            string svgWithoutGuides = RemoveGuideLines(konfSystem.SVG);

            // 3. Generuj PNG tylko z obrysem modelu
            string base64Image = await JSRuntime.InvokeAsync<string>("generatePngFromSvg", svgWithoutGuides);
            if (string.IsNullOrEmpty(base64Image))
            {
                Console.WriteLine("❌ Błąd: Nie udało się pobrać obrazka PNG!");
                return;
            }

            konfSystem.Rysunek = Convert.FromBase64String(base64Image);

            konfSystem.RowIdSystem = Guid.Parse(SelectedSystemId);

            HttpResponseMessage response;
            if (konfSystem.Id == 0)
            {
                response = await Http.PostAsJsonAsync("api/konfsystem", konfSystem);
            }
            else
            {
                response = await Http.PutAsJsonAsync($"api/konfsystem/{konfSystem.Id}", konfSystem);
            }

            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine("✅ Dane zapisane w bazie!");
                await _message.Success("✅ Dane zapisane w bazie!");

                KonfiguracjeSystemu = null;
                KonfiguracjeSystemu = await Http.GetFromJsonAsync<List<KonfSystem>>("api/konfsystem");
            }
            else
            {
                Console.WriteLine("❌ Błąd podczas zapisywania w bazie!");
                await _message.Error("❌ Błąd podczas zapisywania w bazie!");
                SvgKey = Guid.NewGuid().ToString();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Wystąpił błąd #1: {ex.Message} --> {ex.StackTrace}");

            _ = _notice.Error(new()
            {
                Message = "Błąd!!",
                Description = $"❌ Wystąpił błąd #1: {ex.Message}",
                Placement = NotificationPlacement.Top,
                Duration = 5
            });
        }
    }

    private static string RemoveGuideLines(string svgXml)
    {
        var svgDoc = new XmlDocument();
        svgDoc.LoadXml(svgXml);

        var svgElement = svgDoc.DocumentElement;
        if (svgElement == null)
            return svgXml;

        // usuń wszystkie <line> z id zaczynającym się na "guide-line-"
        var guideLines = svgElement.SelectNodes("//*[starts-with(@id, 'guide-line-')]");
        if (guideLines != null)
        {
            foreach (XmlNode node in guideLines)
            {
                node.ParentNode?.RemoveChild(node);
            }
        }

        return svgDoc.OuterXml;
    }


    private void UpdateGuideLines(XmlDocument svgDoc, double width, double height)
    {
        var svgElement = svgDoc.DocumentElement;
        if (svgElement == null) return;

        // ============================
        // 🔹 Pionowe linie
        // ============================
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-vertical", konfSystem.PionLewa, 0, konfSystem.PionLewa, height);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-verticalMax", konfSystem.PionPrawa, 0, konfSystem.PionPrawa, height);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-verticalOdlSzyby", konfSystem.PionOdSzybaOdZew, 0, konfSystem.PionOdSzybaOdZew, height);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-verticalDodatkowa4", konfSystem.PionDodatkowa4, 0, konfSystem.PionDodatkowa4, height);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-verticalDodatkowa5", konfSystem.PionDodatkowa5, 0, konfSystem.PionDodatkowa5, height);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-verticalOsSymetrii", konfSystem.PionOsSymetrii, 0, konfSystem.PionOsSymetrii, height);

        // ============================
        // 🔹 Poziome linie
        // ============================
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal", 0, konfSystem.PoziomDol, width, konfSystem.PoziomDol);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontalMax", 0, konfSystem.PoziomGora, width, konfSystem.PoziomGora);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-korpus", 0, konfSystem.PoziomKorpus, width, konfSystem.PoziomKorpus);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-liniaSzklenia", 0, konfSystem.PoziomLiniaSzkla, width, konfSystem.PoziomLiniaSzkla);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-okucie", 0, konfSystem.PoziomLiniaOkucia, width, konfSystem.PoziomLiniaOkucia);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-dormas", 0, konfSystem.PoziomOsDormas, width, konfSystem.PoziomOsDormas);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-dodatkowa6", 0, konfSystem.PoziomDodatkowa6, width, konfSystem.PoziomDodatkowa6);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-dodatkowa7", 0, konfSystem.PoziomDodatkowa7, width, konfSystem.PoziomDodatkowa7);
        UpdateOrCreateLine(svgDoc, svgElement, "guide-line-horizontal-OsSymetrii", 0, konfSystem.PoziomOsSymetrii, width, konfSystem.PoziomOsSymetrii);
    }

    /// <summary>
    /// Przyjmuje nullable double (double?) i podstawia 0.0 gdy wartość jest null.
    /// </summary>
    private void UpdateOrCreateLine(XmlDocument doc, XmlElement svgElement, string id, double? x1, double? y1, double? x2, double? y2)
    {
        var line = svgElement.SelectSingleNode($"//*[@id='{id}']") as XmlElement;
        if (line == null)
        {
            line = doc.CreateElement("line");
            line.SetAttribute("id", id);
            line.SetAttribute("stroke", "#ffa726");
            line.SetAttribute("stroke-width", "1");
            line.SetAttribute("stroke-dasharray", "5,5");
            svgElement.AppendChild(line);
        }

        // Zamieniamy null → 0.0 (zmień na inną wartość domyślną jeśli potrzebujesz)
        double x1v = x1 ?? 0.0;
        double y1v = y1 ?? 0.0;
        double x2v = x2 ?? 0.0;
        double y2v = y2 ?? 0.0;

        line.SetAttribute("x1", x1v.ToString("G", System.Globalization.CultureInfo.InvariantCulture));
        line.SetAttribute("y1", y1v.ToString("G", System.Globalization.CultureInfo.InvariantCulture));
        line.SetAttribute("x2", x2v.ToString("G", System.Globalization.CultureInfo.InvariantCulture));
        line.SetAttribute("y2", y2v.ToString("G", System.Globalization.CultureInfo.InvariantCulture));
    }

    private static string CleanSvgXml(string rawSvg)
    {
        if (string.IsNullOrWhiteSpace(rawSvg))
            return rawSvg;

        string result = rawSvg;

        // 1. Usuń wszystkie xmlns:* poza głównym
        result = Regex.Replace(result, @"\s+xmlns(:\w+)?=""[^""]*""", "", RegexOptions.IgnoreCase);

        // 2. Zamień ":" na "_"
        result = result.Replace(":", "_");

        // 3. Usuń style z <svg>
        result = Regex.Replace(result, @"<svg([^>]+)style=""[^""]*""", "<svg$1", RegexOptions.IgnoreCase);

        // 4. Usuń data-* atrybuty
        result = Regex.Replace(result, @"\s+data-[^=""\s]+=""[^""]*""", "", RegexOptions.IgnoreCase);

        // 5. Popraw literówki transform_
        result = result.Replace("transform_", "transform")
                       .Replace("transform-origin_", "transform-origin");

        // 6. Zamień puste <line/> i <path/>
        result = Regex.Replace(result, @"<line\s*/>", "<line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"0\" />");
        result = Regex.Replace(result, @"<path\s*/>", "<path d=\"\" />");

        // 7. Skróć liczby
        result = Regex.Replace(result, @"(\d+\.\d{3})\d+", "$1");

        // 8. Usuń puste style=""
        result = result.Replace("style=\"\"", "");

        // 9. Dodaj xmlns jeśli brakuje
        if (!result.Contains("xmlns="))
        {
            result = result.Replace("<svg", "<svg xmlns=\"http://www.w3.org/2000/svg\"");
        }

        return result.Trim();
    }


    // Metoda pomocnicza do parsowania wymiarów SVG
    private double ParseSvgDimension(string value)
    {
        // Usuń wszystkie znaki niebędące cyframi lub kropką (np. "100px" → "100")
        string numericPart = System.Text.RegularExpressions.Regex.Replace(value, @"[^\d.]", "");
        return double.Parse(numericPart, System.Globalization.CultureInfo.InvariantCulture);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (!string.IsNullOrEmpty(SvgContent) && czekajNaDane)
            {
                await Task.Delay(100);
                Console.WriteLine("🔄 Blazor skończył renderować SVG, uruchamiam enableDrag()");
                await JSRuntime.InvokeVoidAsync("enableDrag");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }

    private async Task HandleSelected(InputFileChangeEventArgs e)
    {

        SvgContent = "";
        czekajNaDane = false;
        SvgKey = Guid.NewGuid().ToString(); // 🔥 Zabezpieczenie przed nadpisywaniem

        foreach (var file in e.GetMultipleFiles())
        {
            Console.WriteLine($"Otwieranie pliku: {file.Name}");

            try
            {
                // Wczytanie pliku do pamięci
                using var stream = file.OpenReadStream();
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                memoryStream.Position = 0; // Resetowanie pozycji strumienia

                // Wczytanie DXF ze strumienia
                var dxf = DxfDocument.Load(memoryStream);

                // Sprawdzenie, czy DXF zawiera jakieś elementy
                if (dxf == null)
                {
                    Console.WriteLine("Plik DXF jest pusty lub nie zawiera obsługiwanych elementów.");

                    _ = _notice.Error(new()
                        {
                            Message = "Błąd!!!",
                            Description = "Plik DXF jest pusty lub nie zawiera obsługiwanych elementów.",
                            Placement = NotificationPlacement.BottomLeft
                        });
                    return;
                }
                else
                {
                    _ = _notice.Info(new()
                        {
                            Message = "Informacja!!",
                            Description = $"Plik DXF jest OK ilość linii: {dxf.Entities.Lines.Count()} łuków: {dxf.Entities.Arcs.Count()}, okręgów: {dxf.Entities.Circles.Count()}",
                            Placement = NotificationPlacement.BottomLeft,
                            Duration = 1
                        });
                }
                // Konwersja na SVG
                SvgContent = Converter.ConvertToSvg(dxf);

                // Dodanie linii prowadnicowych do SVG (po konwersji)
                var svgDoc = new XmlDocument();
                svgDoc.LoadXml(SvgContent);

                //await Task.Delay(100); // Krótkie opóźnienie, żeby upewnić się, że Blazor wyrenderował SVG
                // await JSRuntime.InvokeVoidAsync("enableDrag");

                // Wymuszenie odświeżenia UI
                StateHasChanged();

                Console.WriteLine($"🎯 Aktualne SVG: {SvgContent}");
                Console.WriteLine($"🎯 Aktualne SVG - OK");

                czekajNaDane = true;

                return; // Przetwarzamy tylko pierwszy plik
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Błąd podczas odczytu DXF: {ex.Message}");
                _ = _notice.Error(new()
                    {
                        Message = "Błąd!!!",
                        Description = $"Błąd podczas odczytu DXF: {ex.Message}",
                        Placement = NotificationPlacement.BottomLeft
                    });
            }
        }
    }

    private async Task GoBack()
    {
        await JSRuntime.InvokeVoidAsync("history.back");
    }

    private async Task GoKonfiguratorNowegoSystemu()
    {

        NavigationManager.NavigateTo($"/Systemy-okienne");

        await Task.CompletedTask;
    }

    private async Task GoBudujModeleOkien()
    {

        NavigationManager.NavigateTo($"/Modele-okienne");

        await Task.CompletedTask;
    }

    private async Task GoKonfiguratorPolaczen()
    {

        NavigationManager.NavigateTo($"/KonfiguratorPolaczen");

        await Task.CompletedTask;
    }

    private async Task GoKonfiguratorPolaczenKwadratow()
    {

        NavigationManager.NavigateTo($"/KonfiguratorPolaczenKwadratow");

        await Task.CompletedTask;
    }

    private bool boolOdczyt = false;
    private bool boolZmiana = false;
    private bool boolUsuniecia = false;
    private bool boolAdmin = false;
    private bool boolNowy = false;
    private string RowIdPracownika = "";
    private string? user;
    private bool isNotDisabled => !boolZmiana;
    private List<UprawnieniaPracownikaViewModel>? uprawnienia;

    private async Task Laduj_Uprawnienia()
    {
        user = await LocalStorage.GetStringAsync("user");

        if (string.IsNullOrEmpty(user))
        {
            //NavigationManager.NavigateTo($"", true);
            return;
        }

        string nazwaTabeli = "KonfSystem";

        Console.WriteLine($"api/ZwrocSatus/{user}/{nazwaTabeli}");

        try
        {
            uprawnienia = await Http.GetFromJsonAsync<List<UprawnieniaPracownikaViewModel>>($"/api/ZwrocSatus/{user}/{nazwaTabeli}");
        }
        catch (System.Net.Http.HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound)
        {
            Console.WriteLine("Brak danych!!!");
            await _message.Error("Brak danych - status użytkownika");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            await _message.Error(ex.Message);
        }

        if (uprawnienia != null)
        {
            if (uprawnienia.Count > 0)
            {
                var znalezioneElementy = uprawnienia.Where(uprawnienie => uprawnienie.TableName == nazwaTabeli);
                Console.WriteLine("Znaleziono uprawnienia dla użytkownika: " + user + " w tabeli: " + nazwaTabeli + " ilość rekordów: " + znalezioneElementy.Count());
                if (znalezioneElementy.Any())
                {
                    var szuk = znalezioneElementy.FirstOrDefault(x => x.TableName == nazwaTabeli);
                    if (szuk != null)
                    {
                        boolOdczyt = szuk.Odczyt;
                        boolZmiana = szuk.Zmiana;
                        boolUsuniecia = szuk.Usuniecie;
                        boolAdmin = szuk.Administrator;
                        boolNowy = szuk.Zapis;
                        RowIdPracownika = szuk.RowId;
                    }
                }
            }
        }
    }

    bool pytanieOK;
    private async Task OpenModal(string _title, string _contentText)
    {
        var modalCompletionSource = new TaskCompletionSource<bool>();

        RenderFragment content = @<div>@_contentText</div>;

        var options = new ConfirmOptions()
        {
            Title = _title,
            Width = 350,
            Content = content,
            OkText = "Tak",
            CancelText = "Nie",
            OnOk = async e =>
            {
                Console.WriteLine("OnOk");
                pytanieOK = true;
                modalCompletionSource.SetResult(true);
                await Task.CompletedTask;
            },
            OnCancel = async e =>
            {
                Console.WriteLine("OnCancel");
                pytanieOK = false;
                modalCompletionSource.SetResult(false);
                await Task.CompletedTask;
            }
        };

        var confirmRef = await _modalService.CreateConfirmAsync(options);

        confirmRef.OnOpen = () =>
        {
            Console.WriteLine("Open Modal");
            return Task.CompletedTask;
        };

        confirmRef.OnClose = () =>
        {
            Console.WriteLine("Close Modal");
            return Task.CompletedTask;
        };

        // Czekaj na zakończenie działania modalu
        await modalCompletionSource.Task;
    }

    record Typ(string Nazwa);
    private List<Typ> _typ = new List<Typ>
        {
            new Typ(""),
            new Typ("Rama"),
            new Typ("Skrzydło"),
            new Typ("Słupek ruchomy"),
            new Typ("Słupek stały"),
            new Typ("Listwa przyszybowa"),
        };
}